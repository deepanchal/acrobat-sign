{
  "openapi": "3.0.3",
  "info": {
    "title": "secure.na3.adobesign.com",
    "version": "6.0.0"
  },
  "servers": [
    {
      "url": "https://secure.na3.adobesign.com/api/rest/v6"
    }
  ],
  "paths": {
    "/accounts": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-account_write\">account_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountCreateResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "account_write"
            ]
          }
        ],
        "operationId": "createAccount",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountCreationInfo"
              }
            }
          },
          "description": "Information required for creating the account",
          "required": true
        },
        "summary": "Creates an Acrobat Sign account under the partner channel"
      }
    },
    "/accounts/{accountId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The account identifier.",
            "in": "path",
            "name": "accountId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getAccount",
        "summary": "Retrieves the information for an account."
      }
    },
    "/accounts/{accountId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The account identifier.",
            "in": "path",
            "name": "accountId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountEventsList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getAccountEvents",
        "summary": "Retrieves all events for account"
      }
    },
    "/agreements": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Case-sensitive ExternalID for which you would like to retrieve agreement information. ExternalId is passed in the call to the agreement creation API. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "in": "query",
            "name": "externalId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch all the hidden agreements along with the visible agreements. Default value is false.",
            "in": "query",
            "name": "showHiddenAgreements",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserAgreements"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreements",
        "summary": "Retrieves agreements for the user."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "This is a primary endpoint which is used to create a new agreement. An agreement can be created using transientDocument, libraryDocument or a URL. You can create an agreement in one of the 3 mentioned states: a) <b>DRAFT</b> - to incrementally build the agreement before sending out, b) <b>AUTHORING</b> - to add/edit form fields in the agreement, c) <b>IN_PROCESS</b> - to immediately send the agreement. You can use the PUT /agreements/{agreementId}/state endpoint to transition an agreement between the above mentioned states. An allowed transition would follow the following sequence: DRAFT -> AUTHORING -> IN_PROCESS -> CANCELLED.",
        "operationId": "createAgreement",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AgreementCreationInfo"
              }
            }
          },
          "description": "Information about the agreement that you want to create.",
          "required": true
        },
        "summary": "Creates an agreement. Sends it out for signatures, and returns the agreementID in the response to the client."
      }
    },
    "/agreements/{agreementId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FetchedAgreementInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementInfo",
        "summary": "Retrieves the current status of an agreement."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateAgreement",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AgreementInfo"
              }
            }
          },
          "description": "Information necessary to update a modifiable agreement that is presently out for signature.",
          "required": true
        },
        "summary": "Updates the agreement in draft state, or update the expirationTime on an existing agreement that is already out for signature."
      }
    },
    "/agreements/{agreementId}/auditTrail": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "description": "PDF file stream containing audit trail information",
        "operationId": "getAuditTrail",
        "summary": "Retrieves the audit trail of an agreement identified by agreementId."
      }
    },
    "/agreements/{agreementId}/combinedDocument": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of agreement as provided by the API which retrieves information of a specific agreement. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier to be used to retrieve documents. If not mentioned, the participation of api caller is used.",
            "in": "query",
            "name": "participantId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, attach corresponding supporting documents to the signed agreement PDF. Default value of this parameter is true.",
            "in": "query",
            "name": "attachSupportingDocuments",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "When set to true, attach an audit report to the signed agreement PDF. The default value is false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getCombinedDocument",
        "summary": "Retrieves a single combined PDF document for the documents associated with an agreement."
      }
    },
    "/agreements/{agreementId}/combinedDocument/pagesInfo": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, returns info of all pages of supporting documents as well. Else, return the info of pages of only the original document.",
            "in": "query",
            "name": "includeSupportingDocumentsPagesInfo",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CombinedDocumentPagesInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getCombinedDocumentPagesInfo",
        "summary": "Retrieves info of all pages of a combined PDF document for the documents associated with an agreement."
      }
    },
    "/agreements/{agreementId}/combinedDocument/url": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of agreement as provided by the API which retrieves information of a specific agreement. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier to be used to retrieve documents. If not mentioned, the participation of api caller is used.",
            "in": "query",
            "name": "participantId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, attach corresponding supporting documents to the signed agreement PDF. Default value of this parameter is true.",
            "in": "query",
            "name": "attachSupportingDocuments",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "When set to true, attach an audit report to the signed agreement PDF. The default value is false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentUrl"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getCombinedDocumentUrl",
        "summary": "Retrieves url of all visible pages of all the documents associated with an agreement."
      }
    },
    "/agreements/{agreementId}/documents": {
      "delete": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_retention\">agreement_retention</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_retention"
            ]
          }
        ],
        "operationId": "deleteDocuments",
        "summary": "Deletes all the documents of an agreement."
      },
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of agreement as provided by the API which retrieves information of a specific agreement. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier to be used to retrieve documents. If not mentioned, the participation of api caller is used.",
            "in": "query",
            "name": "participantId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Content format of the supported documents. It can have two possible values ORIGINAL or CONVERTED_PDF. Default value is CONVERTED_PDF.",
            "in": "query",
            "name": "supportingDocumentContentFormat",
            "required": false,
            "schema": {
              "enum": [
                "ORIGINAL",
                "CONVERTED_PDF"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementDocuments"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAllDocuments",
        "summary": "Retrieves the IDs of the documents of an agreement identified by agreementId."
      }
    },
    "/agreements/{agreementId}/documents/imageUrls": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of agreement as provided by the API which retrieves information of a specific agreement. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier to be used to retrieve documents. If not mentioned, the participation of api caller is used.",
            "in": "query",
            "name": "participantId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma separated list of image sizes i.e. {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_50_PERCENT, ZOOM_75_PERCENT, ZOOM_100_PERCENT, ZOOM_125_PERCENT, ZOOM_150_PERCENT, ZOOM_200_PERCENT}. Default sizes returned are {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_100_PERCENT}. ",
            "in": "query",
            "name": "imageSizes",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, returns image urls of supporting documents as well. Else, returns image urls of only the original documents.",
            "in": "query",
            "name": "includeSupportingDocumentsImageUrls",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "When set to true, returns only image availability. Else, returns both image urls and its availability.",
            "in": "query",
            "name": "showImageAvailabilityOnly",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentsImageUrlsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAllDocumentsImageUrls",
        "summary": "Retrieves image urls of all visible pages of all the documents associated with an agreement."
      }
    },
    "/agreements/{agreementId}/documents/{documentId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API which fetches the documents of a specified agreement",
            "in": "path",
            "name": "documentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "*/*": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "*/*;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getDocument",
        "summary": "Retrieves the file stream of a document of an agreement."
      }
    },
    "/agreements/{agreementId}/documents/{documentId}/imageUrls": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API which fetches the documents of a specified agreement",
            "in": "path",
            "name": "documentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma separated list of image sizes i.e. {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_50_PERCENT, ZOOM_75_PERCENT, ZOOM_100_PERCENT, ZOOM_125_PERCENT, ZOOM_150_PERCENT, ZOOM_200_PERCENT}. Default sizes returned are {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_100_PERCENT}. ",
            "in": "query",
            "name": "imageSizes",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, returns only image availability. Else, returns both image urls and its availability.",
            "in": "query",
            "name": "showImageAvailabilityOnly",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Start of page number range for which imageUrls are requested. Starting page number should be greater than 0.",
            "in": "query",
            "name": "startPage",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "End of page number range for which imageUrls are requested.",
            "in": "query",
            "name": "endPage",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementDocumentImageUrlsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getDocumentImageUrls",
        "summary": "Retrieves image urls of all visible pages of a document associated with an agreement."
      }
    },
    "/agreements/{agreementId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementEventList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getEvents",
        "summary": "Retrieves the events information for an agreement."
      }
    },
    "/agreements/{agreementId}/formData": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "text/csv": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "description": "This API can only be called by the creator of the agreement",
        "operationId": "getFormData",
        "summary": "Retrieves data entered into the interactive form fields of the agreement."
      }
    },
    "/agreements/{agreementId}/formFields": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The email address of the participant to be used to retrieve its associated form fields.",
            "in": "query",
            "name": "participantEmail",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getFormFields",
        "summary": "Retrieves details of form fields of an agreement."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "addTemplateFieldsToAgreement",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormFieldPostInfo"
              }
            }
          },
          "description": "List of form fields to add or replace",
          "required": true
        },
        "summary": "Adds template fields to an agreement"
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateFormFields",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormFieldPutInfo"
              }
            }
          },
          "description": "List of form fields to set for agreement",
          "required": true
        },
        "summary": "Updates form fields of an agreement.  This will replace all fields in AUTHORING mode agreements, and will replace all fields except for text tag generated fields in DRAFT mode agreements."
      }
    },
    "/agreements/{agreementId}/formFields/mergeInfo": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FormFieldMergeInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMergeInfo",
        "summary": "Retrieves the merge info stored with an agreement."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateAgreementMergeInfo",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormFieldMergeInfo"
              }
            }
          },
          "description": "A mapping indicating the default values to set for form fields",
          "required": true
        },
        "summary": "Set the merge info for an agreement."
      }
    },
    "/agreements/{agreementId}/me": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyAgreementInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementInfoForUser",
        "summary": "Retrieves the agreement information related to the api caller"
      }
    },
    "/agreements/{agreementId}/me/note": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Note"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementNoteForApiUser",
        "summary": "Retrieves the latest note associated with an agreement."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateAgreementNoteForApiUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Note"
              }
            }
          },
          "description": "The note to be associated with the agreement.",
          "required": true
        },
        "summary": "Updates the latest note associated with an agreement."
      }
    },
    "/agreements/{agreementId}/me/visibility": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateAgreementVisibility",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VisibilityInfo"
              }
            }
          },
          "description": "Information to update visibility of agreement",
          "required": true
        },
        "summary": "Updates the visibility of an agreement."
      }
    },
    "/agreements/{agreementId}/members": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch next active participation members. Default value is false.",
            "in": "query",
            "name": "includeNextParticipantSet",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MembersInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAllMembers",
        "summary": "Retrieves information of members of the agreement."
      }
    },
    "/agreements/{agreementId}/members/participantSets/{participantSetId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetailedParticipantSetInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getParticipantSet",
        "summary": "Retrieves the participant set of an agreement identified by agreementId in the path."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateParticipantSet",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetailedParticipantSetInfo"
              }
            }
          },
          "description": "The new participant set info.",
          "required": true
        },
        "summary": "Updates the participant set of an agreement identified by agreementId in the path."
      }
    },
    "/agreements/{agreementId}/members/participantSets/{participantSetId}/delegatedParticipantSets": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DelegationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "Participants marked as delegator can call this API endpoint.",
        "operationId": "createDelegatedParticipantSets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DelegatedParticipantSetInfo"
              }
            }
          },
          "description": "Information about the delegate participant Set",
          "required": true
        },
        "summary": "Creates a participantSet to which the agreement is forwarded for taking appropriate action."
      }
    },
    "/agreements/{agreementId}/members/participantSets/{participantSetId}/participants/{participantId}/reject": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier",
            "in": "path",
            "name": "participantId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "rejectAgreementForParticipation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AgreementRejectionInfo"
              }
            }
          },
          "description": "Participant rejection information required for rejecting the agreement",
          "required": true
        },
        "summary": "Rejects the agreement for a participant."
      }
    },
    "/agreements/{agreementId}/members/participantSets/{participantSetId}/participants/{participantId}/securityOptions": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier",
            "in": "path",
            "name": "participantId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipantSecurityOption"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementSecurityOptionsForParticipation",
        "summary": "Retrieves the security options for a particular participant."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier",
            "in": "path",
            "name": "participantId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateAgreementSecurityOptionsForParticipation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ParticipantSecurityOption"
              }
            }
          },
          "description": "Security options that apply to the participant",
          "required": true
        },
        "summary": "Updates the security options for a particular participant."
      }
    },
    "/agreements/{agreementId}/members/share": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareCreationResponseList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "createShareOnAgreement",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShareCreationInfoList"
              }
            }
          },
          "description": "List of agreement share creation information objects.",
          "required": true
        },
        "summary": "Share an agreement with someone."
      }
    },
    "/agreements/{agreementId}/reminders": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma-separated list of reminder statuses of the reminders which should be returned in the response. Currently supported values are ACTIVE, CANCELED, COMPLETE",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemindersResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementReminders",
        "summary": "Retrieves the reminders of an agreement, identified by agreementId in the path."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReminderCreationResult"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "createReminderOnParticipant",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReminderInfo"
              }
            }
          },
          "description": "The information about a reminder associated with a recipient of an agreement.",
          "required": true
        },
        "summary": "Creates a reminder on the specified participants of an agreement identified by agreementId in the path."
      }
    },
    "/agreements/{agreementId}/reminders/{reminderId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The reminder identifier",
            "in": "path",
            "name": "reminderId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReminderInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementReminder",
        "summary": "Retrieves a specific reminder associated with an agreement"
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The reminder identifier",
            "in": "path",
            "name": "reminderId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "You can only update an ACTIVE reminder, and can only update the status to 'CANCELED', update reminderParticipantIds, or update note.",
        "operationId": "updateAgreementReminder",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReminderInfo"
              }
            }
          },
          "description": "The information about a reminder associated with a recipient of an agreement.",
          "required": true
        },
        "summary": "Updates an existing reminder for an agreement"
      }
    },
    "/agreements/{agreementId}/sender": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "changeAgreementOwner",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewSenderInfo"
              }
            }
          },
          "description": "Information of the new sender of the agreement",
          "required": true
        },
        "summary": "This API can change sender for an agreement that has status of draft"
      }
    },
    "/agreements/{agreementId}/settings": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementSettingsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAgreementSettings",
        "summary": "Get the settings for the agreement"
      }
    },
    "/agreements/{agreementId}/signerIdentityReport": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "description": "PDF file stream containing signer identify information",
        "operationId": "createSignerIdentityReport",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignerIdentityReportInfo"
              }
            }
          },
          "description": "Information about the agreement for which you want to create signer identity report."
        },
        "summary": "Retrieves the signer identity report of an agreement identified by agreementId."
      }
    },
    "/agreements/{agreementId}/signingUrls": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Lifetime of the esignUrl, between 30 and 315360000 seconds. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "expiry",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "An optional field to provide the comma-separated list of parent domain urls where the returned URLs may be iframed. If provided with non-empty and valid list of parent domain urls, it will be used to allow framing for the same. By default the value is null and the Acrobat Sign pages will not be viewable in an iframe.",
            "in": "query",
            "name": "frameParent",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SigningUrlResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "getSigningUrl",
        "summary": "Retrieves the URL for the e-sign page for the current signer(s) of an agreement."
      }
    },
    "/agreements/{agreementId}/state": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "This endpoint can be used by originator/sender of an agreement to transition between the states of agreement. An allowed transition would follow the following sequence: DRAFT -> AUTHORING -> IN_PROCESS -> CANCELLED.",
        "operationId": "updateAgreementState",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AgreementStateInfo"
              }
            }
          },
          "required": true
        },
        "summary": "Updates the state of an agreement identified by agreementId in the path."
      }
    },
    "/agreements/{agreementId}/vaulted": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_vault\">agreement_vault</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_vault"
            ]
          }
        ],
        "operationId": "updateAgreementVaulted",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VaultEventInfo"
              }
            }
          },
          "description": "Information to vault an agreement",
          "required": true
        },
        "summary": "Complete the vaulting process and update the agreement as vaulted."
      }
    },
    "/agreements/{agreementId}/views": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a> - agreement read is always required</li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_login\">user_login</a> - Required additionally if the autoLoginUser parameter is set to true</li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The agreement identifier, as returned by the agreement creation API or retrieved from the API to fetch agreements.",
            "in": "path",
            "name": "agreementId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementViews"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read",
              "user_login"
            ]
          }
        ],
        "operationId": "createAgreementView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AgreementViewInfo"
              }
            }
          },
          "description": "Name of the required view and its desired configuration.",
          "required": true
        },
        "summary": "Retrieves the latest state view url of agreement."
      }
    },
    "/baseUris": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with any of the valid scopes<ul></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BaseUriInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read",
              "agreement_sign",
              "agreement_vault",
              "agreement_write",
              "agreement_retention",
              "library_read",
              "library_write",
              "library_retention",
              "user_login",
              "user_read",
              "account_read",
              "account_write",
              "user_write",
              "widget_read",
              "widget_write",
              "widget_sign",
              "application_read",
              "application_write",
              "agreement_send",
              "workflow_read",
              "webhook_read",
              "webhook_write",
              "webhook_retention"
            ]
          }
        ],
        "operationId": "getBaseUris",
        "summary": "Gets the base uri to access other APIs. In case other APIs are accessed from a different end point, it will be considered an invalid request."
      }
    },
    "/groups": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getGroups",
        "summary": "Retrieves all the groups in an account."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "createGroup",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetailedGroupInfo"
              }
            }
          },
          "description": "Information necessary to create a group.",
          "required": true
        },
        "summary": "Creates a new group in an account."
      }
    },
    "/groups/{groupId}": {
      "delete": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups",
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "deleteGroup",
        "summary": "Delete an existing group."
      },
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups",
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetailedGroupInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getGroupDetails",
        "summary": "Retrieves detailed information about the group."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups",
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "modifyGroup",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetailedGroupInfo"
              }
            }
          },
          "description": "Information necessary to update a group.",
          "required": true
        },
        "summary": "Update an existing group."
      }
    },
    "/groups/{groupId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups",
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupEventsList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getGroupEvents",
        "summary": "Retrieves all events for group"
      }
    },
    "/groups/{groupId}/users": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups",
            "in": "path",
            "name": "groupId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GroupUsersInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getUsersInGroup",
        "summary": "Retrieves all the users in a group."
      }
    },
    "/libraryDocuments": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch all the hidden library documents along with the visible library documents. Default value is false.",
            "in": "query",
            "name": "showHiddenLibraryDocuments",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocuments"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocuments",
        "summary": "Retrieves library documents for a user."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_write"
            ]
          }
        ],
        "operationId": "createLibraryDocument",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LibraryDocumentCreationInfoV6"
              }
            }
          },
          "description": "Information about the library document that you want to create.",
          "required": true
        },
        "summary": "Creates a template that is placed in the library of the user for reuse."
      }
    },
    "/libraryDocuments/{libraryDocumentId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentCreationInfoV6"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocumentInfo",
        "summary": "Retrieves the details of a library document."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_write"
            ]
          }
        ],
        "description": "Currently status, name, sharingMode and templateTypes of the library document can only be updated.",
        "operationId": "updateLibraryDocument",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LibraryDocumentInfo"
              }
            }
          },
          "description": "Information about the library document that you want to create.",
          "required": true
        },
        "summary": "Updates the library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/auditTrail": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocumentAuditTrail",
        "summary": "Retrieves the audit trail associated with a library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/combinedDocument": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to YES attach an audit report to the library document PDF. Default value will be false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "When set to true, return non sealed library document PDF. The default value is false.",
            "in": "query",
            "name": "skipDocumentSealing",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getCombinedDocument1",
        "summary": "Retrieves the combined document associated with a library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/combinedDocument/url": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, attach an audit report to the library document PDF. The default value is false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentUrl"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryCombinedDocumentUrl",
        "summary": "Retrieves url of all visible pages of all the documents associated with a library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/documents": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of library_document as provided by the API which retrieves information of a specific library document. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Documents"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getDocuments",
        "summary": "Retrieves the IDs of the documents associated with library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/documents/{documentId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API which fetches the documents of a specified library document",
            "in": "path",
            "name": "documentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocument",
        "summary": "Retrieves the file stream of a document of library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/documents/{documentId}/imageUrls": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API which fetches the documents of a specified library document",
            "in": "path",
            "name": "documentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma separated list of image sizes i.e. {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_50_PERCENT, ZOOM_75_PERCENT, ZOOM_100_PERCENT, ZOOM_125_PERCENT, ZOOM_150_PERCENT, ZOOM_200_PERCENT}. Default sizes returned are {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_100_PERCENT}. ",
            "in": "query",
            "name": "imageSizes",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Start of page number range for which imageUrls are requested. Starting page number should be greater than 0.",
            "in": "query",
            "name": "startPage",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "End of page number range for which imageUrls are requested.",
            "in": "query",
            "name": "endPage",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentImageUrlsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocumentImageUrls",
        "summary": "Retrieves image urls of all visible pages of a document associated with a library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentEventList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getEvents1",
        "summary": "Retrieves the events information for a library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/formData": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "text/csv": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "description": "This API can only be called by the creator of the library document",
        "operationId": "getFormData1",
        "summary": "Retrieves data entered into the interactive form fields of the library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/formFields": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getFormFields1",
        "summary": "Retrieves details of form fields of a library document."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_write"
            ]
          }
        ],
        "operationId": "updateFormFields1",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormFieldPutInfo"
              }
            }
          },
          "description": "List of form fields to set for library document",
          "required": true
        },
        "summary": "Updates details of form fields of a library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/me": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyAgreementInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocumentInfoForUser",
        "summary": "Retrieves the library document information related to the api caller"
      }
    },
    "/libraryDocuments/{libraryDocumentId}/me/note": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Note"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getLibraryDocumentNoteForApiUser",
        "summary": "Retrieves the latest note of a library document for the API user."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_write"
            ]
          }
        ],
        "operationId": "updateLibraryDocumentNoteForApiUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Note"
              }
            }
          },
          "description": "The note to be associated with the library document.",
          "required": true
        },
        "summary": "Updates the latest note of a library document for the API user."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/me/visibility": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_write"
            ]
          }
        ],
        "operationId": "updateLibraryDocumentVisibility",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VisibilityInfo"
              }
            }
          },
          "description": "Information to update visibility of agreement",
          "required": true
        },
        "summary": "Updates the visibility of library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/members": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentMembersInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read"
            ]
          }
        ],
        "operationId": "getAllLibraryDocumentMembers",
        "summary": "Retrieves information of members (creator) of the library document."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/state": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_write"
            ]
          }
        ],
        "description": "Currently state can be changed from AUTHORING to ACTIVE, AUTHORING to REMOVED or ACTIVE to REMOVED",
        "operationId": "updateLibraryDocumentState",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LibraryDocumentStateInfo"
              }
            }
          },
          "description": "Information about the state of library document to which you want to update",
          "required": true
        },
        "summary": "Updates the library document's state."
      }
    },
    "/libraryDocuments/{libraryDocumentId}/views": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_read\">library_read</a> - library document read is always required</li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_login\">user_login</a> - Required additionally if the autoLoginUser parameter is set to true</li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API to fetch library documents.",
            "in": "path",
            "name": "libraryDocumentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LibraryDocumentViewResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "library_read",
              "user_login"
            ]
          }
        ],
        "operationId": "createLibraryDocumentView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LibraryViewInfo"
              }
            }
          },
          "description": "Name of the required view and its desired configuration.",
          "required": true
        },
        "summary": "Retrieves the latest state view url of a library document."
      }
    },
    "/megaSigns": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch all the hidden bulk send agreements along with the visible bulk send agreements. Default value is false.",
            "in": "query",
            "name": "showHiddenMegaSigns",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSigns"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSigns",
        "summary": "Retrieves Send in Bulk parent agreements for a user."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "This is a primary endpoint which is used to create a new bulk send. A bulk send can be created using transientDocument, libraryDocument or a URL. You can create a bulk send in <b>AUTHORING</b> state to prepare the document before send or in <b>IN_PROCESS</b> to immediately send it. You can use the PUT/megaSigns/{megaSignId}/state endpoint to transition the state of bulk send. An allowed transition would follow the following sequence: AUTHORING->IN_PROCESS -> CANCELLED.",
        "operationId": "createMegaSign",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MegaSignCreationInfo"
              }
            }
          },
          "description": "Information about the bulk send that you want to send.",
          "required": true
        },
        "summary": "Send an agreement out for signature to multiple recipients. Each recipient will receive and sign their own copy of the agreement."
      }
    },
    "/megaSigns/{megaSignId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FetchedMegaSignInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignInfo",
        "summary": "Get detailed information of the specified Send in Bulk parent agreement."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateMegaSign",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MegaSignInfo"
              }
            }
          },
          "description": "Information necessary to update a modifiable bulk send parent that is presently out for signature.",
          "required": true
        },
        "summary": "Update the expirationTime on an existing bulk send parent and all the child agreements that are already out for signature."
      }
    },
    "/megaSigns/{megaSignId}/agreements": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignChildAgreements"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignChildAgreements",
        "summary": "Get all the child agreements of the specified Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/childAgreementsInfo/{childAgreementsInfoFileId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the childAgreementsInfoFile that has been uploaded by sender while creating the bulk send or retrieved from the API to fetch megaSignInfo ",
            "in": "path",
            "name": "childAgreementsInfoFileId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "text/csv": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "description": "CSV file stream containing form data information",
        "operationId": "getChildAgreementsInfoFile",
        "summary": "Retrieves the file stream of the original childAgreementsInfoFile that was uploaded by sender while creating the Send in Bulk."
      }
    },
    "/megaSigns/{megaSignId}/combinedDocument": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true attach an audit report to the bulk send document PDF. Default value will be false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignCombinedDocument",
        "summary": "Retrieves a single combined PDF document for the documents associated with the Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/combinedDocument/url": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, attach an audit report to the bulk send PDF. The default value is false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentUrl"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignCombinedDocumentUrl",
        "summary": "Retrieves url of all visible pages of all the documents associated with the Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/documents": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AgreementDocuments1"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignAllDocuments",
        "summary": "Retrieves the IDs of the documents associated with a Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/documents/imageUrls": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma separated list of image sizes i.e. {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_50_PERCENT, ZOOM_75_PERCENT, ZOOM_100_PERCENT, ZOOM_125_PERCENT, ZOOM_150_PERCENT, ZOOM_200_PERCENT}. Default sizes returned are {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_100_PERCENT}. ",
            "in": "query",
            "name": "imageSizes",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, returns only image availability. Else, returns both image urls and its availability.",
            "in": "query",
            "name": "showImageAvailabilityOnly",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BasicDocumentsImageUrlsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignAllDocumentsImageUrls",
        "summary": "Retrieves image urls of all visible pages of a document associated with a Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/documents/{documentId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API which fetches the documents of a specified bulk send parent",
            "in": "path",
            "name": "documentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "description": "Raw stream of the file",
        "operationId": "getMegaSignDocumentInfo",
        "summary": "Retrieves the file stream of a document of a Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegasignEventList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getEvents2",
        "summary": "Retrieves the events information for the Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/formData": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "text/csv": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "description": "CSV/JSON file stream containing form data information",
        "operationId": "getMegaSignFormData",
        "summary": "Retrieves data entered by recipients into interactive form fields at the time they signed the child agreements of the specified Send in Bulk agreement"
      }
    },
    "/megaSigns/{megaSignId}/formFields": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getFormFields2",
        "summary": "Retrieves details of form fields of a Send in Bulk parent agreement."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateFormFields2",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormFieldPutInfo1"
              }
            }
          },
          "description": "List of form fields to be set for bulk send parent agreement",
          "required": true
        },
        "summary": "Updates the details of form fields of a Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/me": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyAgreementInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignInfoForUser",
        "summary": "Retrieves the Send in Bulk parent agreement information related to the api caller"
      }
    },
    "/megaSigns/{megaSignId}/me/note": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Note"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignNoteForUser",
        "summary": "Retrieves the latest note of a Send in Bulk parent agreement for the user."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateMegaSignNoteForUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Note"
              }
            }
          },
          "description": "The note to be associated with the bulk send parent agreement.",
          "required": true
        },
        "summary": "Updates the latest note of a Send in Bulk parent agreement for the user."
      }
    },
    "/megaSigns/{megaSignId}/me/visibility": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "updateMegaSignVisibility",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VisibilityInfo"
              }
            }
          },
          "description": "Information to update visibility of agreement",
          "required": true
        },
        "summary": "Updates the visibility of a bulk send."
      }
    },
    "/megaSigns/{megaSignId}/members": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignMembersInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getAllMegaSignMembers",
        "summary": "Retrieves detailed member info along with IDs for different types of participants associated with the Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/members/share": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareCreationResponseList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "createShareOnMegaSign",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShareCreationInfoList"
              }
            }
          },
          "description": "List of agreement share creation information objects.",
          "required": true
        },
        "summary": "Share a bulk send parent and all the child agreements with someone."
      }
    },
    "/megaSigns/{megaSignId}/reminders": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma-separated list of reminder statuses of the reminders which should be returned in the response. Currently supported values are ACTIVE, CANCELED, COMPLETE",
            "in": "query",
            "name": "status",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignRemindersResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignReminders",
        "summary": "Retrieves the reminders of the specified Send in Bulk parent agreement."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReminderCreationResult"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "operationId": "createReminderOnMegaSign",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReminderInfo1"
              }
            }
          },
          "description": "The information about a reminder associated with a recipient of an agreement.",
          "required": true
        },
        "summary": "Creates a reminder on the specified participants of the bulk send parent."
      }
    },
    "/megaSigns/{megaSignId}/reminders/{reminderId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The reminder identifier",
            "in": "path",
            "name": "reminderId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ReminderInfo1"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read"
            ]
          }
        ],
        "operationId": "getMegaSignReminder",
        "summary": "Retrieves a specific reminder given the reminder id for the specified Send in Bulk parent agreement."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The reminder identifier",
            "in": "path",
            "name": "reminderId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "You can only update an ACTIVE reminder, and can only update the status to 'CANCELED', update reminderParticipantIds, update allUnsigned or update note.",
        "operationId": "updateMegaSignReminder",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReminderInfo1"
              }
            }
          },
          "description": "The information about a reminder associated with a recipient of an agreement.",
          "required": true
        },
        "summary": "Updates an existing reminder for a Send in Bulk parent agreement."
      }
    },
    "/megaSigns/{megaSignId}/state": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write"
            ]
          }
        ],
        "description": "This endpoint can be used by creator of the bulk send to transition between the states of a bulk send. An allowed transition would follow the following sequence :  AUTHORING->IN_PROCESS->CANCELLED.",
        "operationId": "updateMegaSignState",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MegaSignStateInfo"
              }
            }
          },
          "description": "Bulk send state update information object.",
          "required": true
        },
        "summary": "Updates the state of a bulk send identified by MegaSignId in the path."
      }
    },
    "/megaSigns/{megaSignId}/views": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_read\">agreement_read</a> - agreement read is always required</li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_login\">user_login</a> - Required additionally if the autoLoginUser parameter is set to true</li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The identifier of the bulk send parent agreement, as returned by the bulk send creation API or retrieved from the API to fetch the bulk send agreements",
            "in": "path",
            "name": "megaSignId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MegaSignViewResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read",
              "user_login"
            ]
          }
        ],
        "operationId": "getMegaSignView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MegaSignViewInfo"
              }
            }
          },
          "description": "Name of the required view and its desired configuration.",
          "required": true
        },
        "summary": "Retrieves the requested views of a bulk send agreement."
      }
    },
    "/messageTemplates": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Message template locale",
            "in": "query",
            "name": "locale",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MessageTemplates"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getMessageTemplates",
        "summary": "Retrieves a list of message templates applicable to the current user."
      }
    },
    "/search": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth-search\" target=\"oauthDoc\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth-search\" data-link-scope=\"agreement_read\" target=\"oauthDoc\">agreement_read</a></li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth-search\" data-link-scope=\"library_read\" target=\"oauthDoc\">library_read</a></li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth-search\" data-link-scope=\"widget_read\" target=\"oauthDoc\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Ownership scope of the agreement documents to include in this search request (defaults to OWNED):<ul><li style='list-style-type: square'><b>OWNED</b> - Fetch only agreement documents that belong to the requesting user (default).</li><li style='list-style-type: square'><b>SHARED</b> - Fetch all agreement documents that have been shared with the requesting user but exclude agreement documents that belong to him.</li><li style='list-style-type: square'><b>SHARED_AND_OWNED</b> - Fetch all agreements documents that have been shared with the requesting user and include the agreements that belong to him.</li></ul>",
            "in": "header",
            "name": "x-ownership-scope",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResults"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_read",
              "library_read",
              "widget_read"
            ]
          }
        ],
        "operationId": "searchResources",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchRequestBody"
              }
            }
          },
          "description": "The parameters of your search request.",
          "required": true
        },
        "summary": "Retrieves, searches, filters, and sorts agreements for the user."
      }
    },
    "/transientDocuments": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with any of the following scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_write\">agreement_write</a></li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-agreement_sign\">agreement_sign</a></li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-library_write\">library_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransientDocumentResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "agreement_write",
              "agreement_sign",
              "widget_write",
              "library_write"
            ]
          }
        ],
        "description": "The document uploaded through this call is referred to as transient since it is available only for 7 days after the upload. The returned transient document ID can be used in the API calls where the uploaded file needs to be referred. The transient document request is a multipart request consisting of three parts - filename, mime type and the file stream. You can only upload one file at a time in this request.",
        "operationId": "createTransientDocument",
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "format": "binary",
                "type": "string"
              }
            }
          },
          "required": true
        },
        "summary": "Uploads a document and obtains the document's ID."
      }
    },
    "/users": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UsersInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getUsers",
        "summary": "Retrieves all the users in an account."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "createUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetailedUserInfo"
              }
            }
          },
          "description": "Information necessary to create a user.",
          "required": true
        },
        "summary": "Creates a new user in the Acrobat Sign system"
      }
    },
    "/users/{userId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as returned by the user creation API or retrieved from the API to fetch users. To get the details for the token owner, UserId can be replaced by \"me\" without quotes.",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetailedUserInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getUserDetail",
        "summary": "Retrieves detailed information about the user in the caller account."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as provided by GET /users or POST /users",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "modifyUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetailedUserInfo"
              }
            }
          },
          "description": "This information is used to update the user attributes. Request model of PUT /users/{userId} should be same as response returned by GET /users/{userId}.",
          "required": true
        },
        "summary": "Update an user."
      }
    },
    "/users/{userId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as provided by GET /users or POST /users",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserEventsList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getUserEvents",
        "summary": "Retrieves all events for user"
      }
    },
    "/users/{userId}/groups": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as returned by the user creation API or retrieved from the API to fetch users. To get the details for the token owner, UserId can be replaced by \"me\" without quotes.",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserGroupsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read"
            ]
          }
        ],
        "operationId": "getGroupsOfUser",
        "summary": "Retrieves the groups of the user."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as returned by the user creation API or retrieved from the API to fetch users. To update the details for the token owner, UserId can be replaced by \"me\" without quotes.",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "updateGroupsOfUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserGroupsInfo"
              }
            }
          },
          "required": true
        },
        "summary": "Updates the groups of the user."
      }
    },
    "/users/{userId}/locale": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as provided by GET /users or POST /users",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "modifyUserLocale",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserLocaleInfo"
              }
            }
          },
          "required": true
        },
        "summary": "Updates the user locale."
      }
    },
    "/users/{userId}/state": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_write\">user_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as returned by the user creation API or retrieved from the API to fetch users. To update the details for the token owner, UserId can be replaced by \"me\" without quotes.",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserStatusUpdateResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_write"
            ]
          }
        ],
        "operationId": "modifyUserState",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserStateInfo"
              }
            }
          },
          "required": true
        },
        "summary": "Activate/Deactivate a given user."
      }
    },
    "/users/{userId}/views": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_read\">user_read</a> - user read is always required</li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_login\">user_login</a> - Required additionally if the autoLoginUser parameter is set to true</li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The user identifier, as returned by the user creation API or retrieved from the API to fetch users. To get the details for the token owner, UserId can be replaced by \"me\" without quotes.",
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserViewResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "user_read",
              "user_login"
            ]
          }
        ],
        "operationId": "getUserViews",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserViewInfo"
              }
            }
          },
          "description": "Name of the required view and its desired configuration.",
          "required": true
        },
        "summary": "Retrieves the URL of manage, account settings and user profile page."
      }
    },
    "/webhooks": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-webhook_read\">webhook_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch all the inactive webhooks along with the active webhooks.",
            "in": "query",
            "name": "showInActiveWebhooks",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Scope of webhook. The possible values are ACCOUNT, GROUP, USER or RESOURCE",
            "in": "query",
            "name": "scope",
            "required": false,
            "schema": {
              "enum": [
                "ACCOUNT",
                "GROUP",
                "USER",
                "RESOURCE"
              ],
              "type": "string"
            }
          },
          {
            "description": "The type of resource on which webhook was created. The possible values are AGREEMENT, WIDGET, MEGASIGN and LIBRARY_DOCUMENT.",
            "in": "query",
            "name": "resourceType",
            "required": false,
            "schema": {
              "enum": [
                "AGREEMENT",
                "WIDGET",
                "MEGASIGN",
                "LIBRARY_DOCUMENT"
              ],
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserWebhooks"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "webhook_read"
            ]
          }
        ],
        "operationId": "getWebhooks",
        "summary": "Retrieves webhooks for a user."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-webhook_write\">webhook_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "webhook_write"
            ]
          }
        ],
        "description": "This is a primary endpoint which is used to create a new webhook. A webhook can only be created in ACTIVE state. Currently, webhooks are supported at four scopes - Account, Group, User and Resource. <br/> <br/> Before creating a webhook successfully at any of these scopes, Acrobat Sign <a href='https://www.adobe.io/apis/documentcloud/sign/docs.html#!adobedocs/adobe-sign/master/webhooks.md#verificationofintentofthewebhookurl'>verifies</a> that the webhook URL that is provided in the registration request really intends to receive notifications and is a valid URL. <br/>There is a defined mechanism for this validation where Acrobat Sign makes an HTTPS GET request to the webhook URL. This request has a custom HTTP header X-AdobeSign-ClientId. The value of this header is the client ID of the application that is requesting to create the webhook. To register a webhook successfully, the webhook URL must respond to this verification request with an HTTPS 2XX response code, and also it must send back the same client ID value in one of the following two ways:<ol><li>In a custom response header, X-AdobeSign-ClientId. This is the same header which was passed in the request, and can be echoed back in the response.</li><li> In the JSON response body of the response with the key of xAdobeSignClientId and its value being the same client ID that was sent in the request. </li></ol><p>On successful registration,  Acrobat Sign sends a success response (any HTTPS 2XX code) to your client app with the unique webhook identifier and a Location header, which contains the URL of the webhook resource created in Acrobat Sign.<br/> To learn more, please refer <a href='https://www.adobe.io/apis/documentcloud/sign/docs.html#!adobedocs/adobe-sign/master/webhooks.md'>Webhooks in Acrobat Sign Guide</a>.</p>",
        "operationId": "createWebhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookInfo"
              }
            }
          },
          "description": "Information about the webhook that you want to create",
          "required": true
        },
        "summary": "Creates a webhook."
      }
    },
    "/webhooks/{webhookId}": {
      "delete": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-webhook_retention\">webhook_retention</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The webhook identifier, as returned by the webhook creation API or retrieved from the API to fetch webhooks.",
            "in": "path",
            "name": "webhookId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "webhook_retention"
            ]
          }
        ],
        "operationId": "deleteWebhook",
        "summary": "Deletes a webhook."
      },
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-webhook_read\">webhook_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The webhook identifier, as returned by the webhook creation API or retrieved from the API to fetch webhooks.",
            "in": "path",
            "name": "webhookId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "webhook_read"
            ]
          }
        ],
        "operationId": "getWebhookInfo",
        "summary": "Retrieves the details of a webhook."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-webhook_write\">webhook_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The webhook identifier, as returned by the webhook creation API or retrieved from the API to fetch webhooks.",
            "in": "path",
            "name": "webhookId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "webhook_write"
            ]
          }
        ],
        "operationId": "updateWebhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookInfo"
              }
            }
          },
          "description": "Information necessary to update a webhook",
          "required": true
        },
        "summary": "Updates a webhook."
      }
    },
    "/webhooks/{webhookId}/state": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-webhook_write\">webhook_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The webhook identifier, as returned by the webhook creation API or retrieved from the API to fetch webhooks.",
            "in": "path",
            "name": "webhookId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "webhook_write"
            ]
          }
        ],
        "operationId": "updateWebhookState",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookStateInfo"
              }
            }
          },
          "required": true
        },
        "summary": "Updates the state of a webhook identified by webhookId in the path."
      }
    },
    "/widgets": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch all the hidden web forms along with the visible web forms. Default value is false.",
            "in": "query",
            "name": "showHiddenWidgets",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "An optional field to provide the comma-separated list of parent domain urls where the returned URLs may be iframed. If provided with non-empty and valid list of parent domain urls, it will be used to allow framing for the same. By default the value is null and the Acrobat Sign pages will not be viewable in an iframe.",
            "in": "query",
            "name": "frameParent",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserWidgets"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgets",
        "summary": "Retrieves web forms for a user."
      },
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetCreationResponse"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "description": "This is a primary endpoint which is used to create a new web form. You can create a web form in one of the 3 mentioned states: a) <b>DRAFT</b> - to incrementally build the web form, b) <b>AUTHORING</b> - to add/edit form fields in the web form, c) <b>ACTIVE</b> - to immediately host the web form. You can use the PUT /widgets/{widgetId}/state endpoint to transition a web form between the above mentioned states. An allowed transition would follow the any of the following sequences: DRAFT->AUTHORING->ACTIVE, ACTIVE<->INACTIVE, DRAFT->CANCELLED.",
        "operationId": "createWidget",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WidgetCreationInfoV6"
              }
            }
          },
          "description": "Information about the web form that you want to create.",
          "required": true
        },
        "summary": "Creates a web form and and returns the widgetId in the response to the client."
      }
    },
    "/widgets/{widgetId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FetchedWidgetInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetInfo",
        "summary": "Retrieves the details of a web form."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateWidget",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WidgetInfo"
              }
            }
          },
          "description": "Web Form update information object.",
          "required": true
        },
        "summary": "Updates a web form."
      }
    },
    "/widgets/{widgetId}/agreements": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A query parameter to fetch all the hidden agreements along with the visible agreements. Default value is false.",
            "in": "query",
            "name": "showHiddenAgreements",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetAgreements"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetAgreements",
        "summary": "Retrieves agreements for the web form."
      }
    },
    "/widgets/{widgetId}/auditTrail": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetAuditTrail",
        "summary": "Retrieves the audit trail of a web form identified by widgetId."
      }
    },
    "/widgets/{widgetId}/combinedDocument": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of web form as provided by the API which retrieves information of a specific web form. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The ID of the participant to be used to retrieve documents. If not mentioned, the participation of api caller is used.",
            "in": "query",
            "name": "participantId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to YES, attach an audit report to the signed Web Form PDF. Default value is false",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetCombinedDocument",
        "summary": "Retrieves a single combined PDF document for the documents associated with a web form."
      }
    },
    "/widgets/{widgetId}/combinedDocument/url": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, attach an audit report to the web form PDF. The default value is false.",
            "in": "query",
            "name": "attachAuditReport",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentUrl"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetCombinedDocumentUrl",
        "summary": "Retrieves url of all visible pages of all the documents associated with a web form."
      }
    },
    "/widgets/{widgetId}/documents": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The version identifier of web form as provided by the API which retrieves information of a specific web form. If not provided then latest version will be used.",
            "in": "query",
            "name": "versionId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The ID of the participant to be used to retrieve documents. If not mentioned, the participation of api caller is used.",
            "in": "query",
            "name": "participantId",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetDocuments"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetDocuments",
        "summary": "Retrieves the IDs of the documents associated with web form."
      }
    },
    "/widgets/{widgetId}/documents/imageUrls": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A comma separated list of image sizes i.e. {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_50_PERCENT, ZOOM_75_PERCENT, ZOOM_100_PERCENT, ZOOM_125_PERCENT, ZOOM_150_PERCENT, ZOOM_200_PERCENT}. Default sizes returned are {FIXED_WIDTH_50px, FIXED_WIDTH_250px, FIXED_WIDTH_675px, ZOOM_100_PERCENT}. ",
            "in": "query",
            "name": "imageSizes",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "When set to true, returns only image availability. Else, returns both image urls and its availability.",
            "in": "query",
            "name": "showImageAvailabilityOnly",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BasicDocumentsImageUrlsInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetAllDocumentsImageUrls",
        "summary": "Retrieves image urls of all visible pages of a document associated with a web form."
      }
    },
    "/widgets/{widgetId}/documents/{documentId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The document identifier, as retrieved from the API which fetches the documents of a specified web form",
            "in": "path",
            "name": "documentId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/pdf": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "application/pdf;encoding=base64": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetDocumentInfo",
        "summary": "Retrieves the file stream of a document of a web form."
      }
    },
    "/widgets/{widgetId}/events": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetEventList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getEvents3",
        "summary": "Retrieves the events information for a web form."
      }
    },
    "/widgets/{widgetId}/formData": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Used to navigate through the pages. If not provided, returns the first page.",
            "in": "query",
            "name": "cursor",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Number of intended items in the response page. If not provided, it is decided by the application settings.",
            "in": "query",
            "name": "pageSize",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              },
              "text/csv": {
                "schema": {
                  "format": "byte",
                  "type": "string"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "description": "CSV/JSON file stream containing form data information",
        "operationId": "getWidgetFormData",
        "summary": "Retrieves data entered by the user into interactive form fields at the time they signed the web form"
      }
    },
    "/widgets/{widgetId}/formFields": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetFormFields",
        "summary": "Retrieves form fields for a web form."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetFormFields"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateFormFields3",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormFieldPutInfo"
              }
            }
          },
          "description": "List of form fields to set for web form",
          "required": true
        },
        "summary": "Updates details of form fields of a web form."
      }
    },
    "/widgets/{widgetId}/me": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MyAgreementInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetInfoForUser",
        "summary": "Retrieves the web form information related to the api caller"
      }
    },
    "/widgets/{widgetId}/me/note": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Note"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetNoteForApiUser",
        "summary": "Retrieves the latest note of a web form for the API user."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateWidgetNoteForApiUser",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Note"
              }
            }
          },
          "description": "The note to be associated with the web form.",
          "required": true
        },
        "summary": "Updates the latest note of a web form for the API user."
      }
    },
    "/widgets/{widgetId}/me/visibility": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateWidgetVisibility",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VisibilityInfo"
              }
            }
          },
          "description": "Information to update visibility of web form",
          "required": true
        },
        "summary": "Updates the visibility of web form."
      }
    },
    "/widgets/{widgetId}/members": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetMembersInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getAllWidgetMembers",
        "summary": "Retrieves detailed member info along with IDs for different types of participants."
      }
    },
    "/widgets/{widgetId}/members/ccParticipants": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateWidgetCCParticipantEmail",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CcInfos"
              }
            }
          },
          "description": "List of new CC emails",
          "required": true
        },
        "summary": "Updates the Email of CC participant of a Web Form identified by WidgetId in the path."
      }
    },
    "/widgets/{widgetId}/members/participantSets/{participantSetId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DetailedWidgetParticipantSetInfo"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getParticipantSet1",
        "summary": "Retrieves the participant set of a web form identified by widgetId in the path."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateWidgetParticipantSetEmail",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DetailedWidgetParticipantSetInfo"
              }
            }
          },
          "description": "Information about the Participant that is to be Updated.",
          "required": true
        },
        "summary": "Updates the Email of participant set of a Web Form identified by WidgetId in the path."
      }
    },
    "/widgets/{widgetId}/members/participantSets/{participantSetId}/participants/{participantId}/securityOptions": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Pass the value of the e-tag header obtained from the previous response to the same request to get a RESOURCE_NOT_MODIFIED(304) if the resource hasn't changed.",
            "in": "header",
            "name": "If-None-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier",
            "in": "path",
            "name": "participantId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ParticipantSecurityOption1"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read"
            ]
          }
        ],
        "operationId": "getWidgetSecurityOptionsForParticipation",
        "summary": "Retrieves the security options for a particular participant."
      },
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant set identifier",
            "in": "path",
            "name": "participantSetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The participant identifier",
            "in": "path",
            "name": "participantId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "updateWidgetSecurityOptionsForParticipation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ParticipantSecurityOption1"
              }
            }
          },
          "description": "Security options that apply to the participant",
          "required": true
        },
        "summary": "Updates the security options for a particular participant."
      }
    },
    "/widgets/{widgetId}/members/share": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ShareCreationResponseList"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "operationId": "createShareOnWidget",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ShareCreationInfoList"
              }
            }
          },
          "description": "List of agreement share creation information objects.",
          "required": true
        },
        "summary": "Share a web form with someone."
      }
    },
    "/widgets/{widgetId}/state": {
      "put": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_write\">widget_write</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The server will only update the resource if it matches the listed ETag otherwise error RESOURCE_MODIFIED(412) is returned.",
            "in": "header",
            "name": "If-Match",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_write"
            ]
          }
        ],
        "description": "This endpoint can be used by creator of the web form to transition between the states of web form. An allowed transition would follow any of the following sequence :  DRAFT->AUTHORING->ACTIVE, ACTIVE<->INACTIVE, DRAFT->CANCELLED.",
        "operationId": "updateWidgetState",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WidgetStateInfo"
              }
            }
          },
          "required": true
        },
        "summary": "Updates the state of a web form identified by widgetId in the path."
      }
    },
    "/widgets/{widgetId}/views": {
      "post": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-widget_read\">widget_read</a> - web form read is always required</li><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-user_login\">user_login</a> - Required additionally if the autoLoginUser parameter is set to true</li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The web form identifier, as returned by the web form creation API or retrieved from the API to fetch web forms.",
            "in": "path",
            "name": "widgetId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WidgetViews"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "widget_read",
              "user_login"
            ]
          }
        ],
        "operationId": "getWidgetView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WidgetViewInfo"
              }
            }
          },
          "description": "Name of the required view and its desired configuration.",
          "required": true
        },
        "summary": "Retrieves the requested views for a web form."
      }
    },
    "/workflows": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-workflow_read\">workflow_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier for which the workflows will be fetched",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Include draft workflows",
            "in": "query",
            "name": "includeDraftWorkflows",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Include inactive workflows",
            "in": "query",
            "name": "includeInactiveWorkflows",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserWorkflows"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "workflow_read"
            ]
          }
        ],
        "operationId": "getWorkflows",
        "summary": "Retrieves workflows for a user."
      }
    },
    "/workflows/{workflowId}": {
      "get": {
        "parameters": [
          {
            "description": "An <a href=\"#\" class=\"link-oauth\">OAuth Access Token</a> with scopes:<ul><li style='list-style-type: square'><a href=\"#\" class=\"link-oauth\" data-link-scope=\"scope-workflow_read\">workflow_read</a></li></ul>in the format <b>'Bearer {accessToken}'.",
            "in": "header",
            "name": "Authorization",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email of API caller using the account or group token in the format <b>userid:{userId} OR email:{email}.</b> If it is not specified, then the caller is inferred from the token.",
            "in": "header",
            "name": "x-api-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The userId or email in the format <b>userid:{userId} OR email:{email}.</b> of the user that has shared his/her account",
            "in": "header",
            "name": "x-on-behalf-of-user",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The workflow identifier, as retrieved from the API to fetch workflows.",
            "in": "path",
            "name": "workflowId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "in": "query",
            "name": "groupId",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowDescription"
                }
              }
            },
            "description": "No response was specified"
          }
        },
        "security": [
          {
            "oauth2": [
              "workflow_read"
            ]
          }
        ],
        "operationId": "getWorkflowInfo",
        "summary": "Retrieves the details of a workflow."
      }
    }
  },
  "components": {
    "schemas": {
      "Account": {
        "description": "Account resource for the User",
        "properties": {
          "accountType": {
            "description": "The provisioned type of the account. This is a server generated attributed and can not be provided in POST/PUT calls.",
            "enum": [
              "FREE",
              "FREE_LEGACY",
              "TEAM_TRIAL",
              "TEAM",
              "TEAM_LEGACY",
              "ENTERPRISE_TRIAL",
              "ENTERPRISE",
              "ENTERPRISE_LEGACY",
              "GLOBAL_TRIAL",
              "GLOBAL",
              "DEVELOPER",
              "PRO_DOC_CLOUD",
              "TRIAL_EXPIRED",
              "ANONYMOUS",
              "PRO_DOC_CLOUD_MULTI",
              "PRO_PLUS_DOC_CLOUD",
              "PRO_PLUS_DOC_CLOUD_MULTI",
              "GLOBAL_TRIAL_V2",
              "GLOBAL_TRIAL_EXPIRED_V2"
            ],
            "type": "string"
          },
          "company": {
            "description": "The company associated with the account. This is a server generated attributed and can not be provided in POST/PUT calls. ",
            "type": "string"
          },
          "created": {
            "description": "Date when the account was created. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "id": {
            "description": "Identifier of the account. This is a server generated attributed and can not be provided in POST/PUT calls. ",
            "type": "string"
          },
          "modified": {
            "description": "The last date that the account information was updated. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name which the account is known. This is a server generated attributed and can not be provided in POST/PUT calls. ",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AccountCreateResponse": {
        "description": "AccountCreateResponse",
        "properties": {
          "accountId": {
            "description": "Account id of the created account",
            "type": "string"
          },
          "adminDetails": {
            "$ref": "#/components/schemas/AdminDetails",
            "description": "Admin user details",
            "items": {
              "$ref": "#/components/schemas/AdminDetails"
            }
          }
        },
        "type": "object"
      },
      "AccountCreationInfo": {
        "description": "AccountCreationInfo",
        "properties": {
          "accountType": {
            "description": "Type of account",
            "enum": [
              "FREE",
              "ENTERPRISE",
              "ENTERPRISE_TRIAL",
              "GLOBAL",
              "GLOBAL_TRIAL",
              "DEVELOPER"
            ],
            "type": "string"
          },
          "adminUserInfo": {
            "$ref": "#/components/schemas/AdminUserInfo",
            "description": "Admin user information",
            "items": {
              "$ref": "#/components/schemas/AdminUserInfo"
            }
          },
          "company": {
            "description": "Company name",
            "type": "string"
          },
          "countryCode": {
            "description": "Account country code",
            "type": "string"
          },
          "externalId": {
            "description": "External id for the account",
            "type": "string"
          },
          "locale": {
            "description": "Account locale",
            "type": "string"
          },
          "numSeats": {
            "description": "Number of seats",
            "type": "integer"
          },
          "trialDuration": {
            "description": "Account trial duration",
            "type": "integer"
          }
        },
        "required": [
          "accountType",
          "adminUserInfo",
          "countryCode",
          "numSeats"
        ],
        "type": "object"
      },
      "AccountEvent": {
        "description": "A JSON of one account event, null",
        "properties": {
          "accountEventId": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "accountId": {
            "description": "Identifier of the account. This is a server generated attributed and can not be provided in POST/PUT calls. ",
            "type": "string"
          },
          "adminUserId": {
            "description": "Account admin user ID",
            "type": "string"
          },
          "date": {
            "description": "The date of the user event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "event": {
            "description": "Type of account event",
            "enum": [
              "CREATED",
              "CANCELLED",
              "USER_ADDED",
              "USER_REMOVED",
              "USER_DISABLED",
              "ACCOUNT_TYPE_UPDATED",
              "ACCOUNT_SETUP_EMAIL_SENT"
            ],
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the signing participant.",
            "type": "string"
          }
        },
        "required": [
          "adminUserId",
          "date",
          "userId"
        ],
        "type": "object"
      },
      "AccountEventsList": {
        "description": "A JSON list of all account events",
        "properties": {
          "accountEvents": {
            "description": "List of account events",
            "items": {
              "$ref": "#/components/schemas/AccountEvent"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "accountEvents",
          "page"
        ],
        "type": "object"
      },
      "AdminDetails": {
        "description": "AdminDetails",
        "properties": {
          "email": {
            "description": "Email ID of the admin user",
            "type": "string"
          },
          "status": {
            "description": "Status of the admin user",
            "type": "string"
          },
          "userId": {
            "description": "Id of the admin user",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AdminUserInfo": {
        "description": "AdminUserInfo",
        "properties": {
          "email": {
            "description": "Email ID of the admin user",
            "type": "string"
          },
          "firstName": {
            "description": "First name of the admin user",
            "type": "string"
          },
          "lastName": {
            "description": "Last name of the admin user",
            "type": "string"
          },
          "locale": {
            "description": "Locale of the admin user",
            "type": "string"
          },
          "phone": {
            "description": "Phone number of the admin user",
            "type": "string"
          },
          "title": {
            "description": "Title of the admin user",
            "type": "string"
          }
        },
        "required": [
          "email",
          "firstName",
          "lastName"
        ],
        "type": "object"
      },
      "PageInfo": {
        "properties": {
          "nextCursor": {
            "description": "Used to navigate to the next page. If not returned, there are no further pages.",
            "type": "string"
          }
        },
        "required": [
          "nextCursor"
        ],
        "type": "object"
      },
      "AccountSharerInfo": {
        "properties": {
          "email": {
            "description": "The email address of the user",
            "type": "string"
          },
          "fullName": {
            "description": "Full name of this account sharer.",
            "type": "string"
          },
          "permissions": {
            "description": "A list of permissions given for this account sharing.",
            "items": {
              "enum": [
                "VIEW",
                "SEND",
                "MODIFY"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "userId": {
            "description": "A unique identifier of the user resource for REST APIs as issued by Acrobat Sign.",
            "type": "string"
          }
        },
        "required": [
          "email",
          "fullName",
          "permissions",
          "userId"
        ],
        "type": "object"
      },
      "AgreementCancellationInfo": {
        "properties": {
          "comment": {
            "description": "An optional comment describing to the recipients why you want to cancel the transaction",
            "type": "string"
          },
          "notifyOthers": {
            "description": "Whether or not you would like the recipients to be notified that the transaction has been cancelled. The default value is false",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "AgreementCcInfo": {
        "properties": {
          "email": {
            "description": "Email of the CC participant of the agreement",
            "type": "string"
          },
          "label": {
            "description": "Label of the CC list as returned in workflow description",
            "type": "string"
          },
          "visiblePages": {
            "description": "When you enable limited document visibility (documentVisibilityEnabled), you can specify which file (fileInfo) should be made visible to which specific participant set.<br>Specify one or more label values of a fileInfos element.<br>Each signer participant sets must contain at least one required signature field in at least one visible file included in this API call; if not a page with a signature field is automatically appended for any missing participant sets. If there is a possibility that one or more participant sets do not have a required signature field in the files included in the API call, all signer participant sets should include a special index value of '0' to make this automatically appended signature page visible to the signer. Not doing so may result in an error. For all other roles, you may omit this value to exclude this page.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "AgreementCreationInfo": {
        "properties": {
          "agreementSettingsInfo": {
            "$ref": "#/components/schemas/AgreementSettingsInfo",
            "description": "Agreement Settings Info",
            "items": {
              "$ref": "#/components/schemas/AgreementSettingsInfo"
            }
          },
          "ccs": {
            "description": "A list of one or more CCs that will be copied in the agreement transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/AgreementCcInfo"
            },
            "type": "array"
          },
          "createdDate": {
            "description": "Date when agreement was created. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/OfflineDeviceInfo",
            "description": "Device info of the offline device. It should only be provided in case of offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/OfflineDeviceInfo"
            }
          },
          "documentRetentionAppliedDate": {
            "description": "Document retention applied date for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "format": "date",
            "type": "string"
          },
          "documentVisibilityEnabled": {
            "description": "If set to true, enable limited document visibility. Should not be provided in offline agreement creation.",
            "type": "boolean"
          },
          "emailOption": {
            "$ref": "#/components/schemas/EmailOption",
            "description": "Email configurations for the agreement. Should not be provided in offline agreement creation or when updating a non draft agreement.",
            "items": {
              "$ref": "#/components/schemas/EmailOption"
            }
          },
          "expirationTime": {
            "description": "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.",
            "format": "date",
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/ExternalId",
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Should not be provided in offline agreement creation. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            }
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            },
            "type": "array"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Should not be provided in offline agreement creation.",
            "type": "integer"
          },
          "formFieldGenerators": {
            "description": "List of form field generators to produce form fields on the resulting agreement",
            "items": {
              "$ref": "#/components/schemas/FormFieldGenerator"
            },
            "type": "array"
          },
          "formFieldLayerTemplates": {
            "description": "Specifies the form field layer template or source of form fields to apply on the files in this transaction. If specified, the FileInfo for this parameter must refer to a form field layer template via libraryDocumentId or libraryDocumentName, or if specified via transientDocumentId or documentURL, it must be of a supported file type. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the agreement belongs to. If not provided during agreement creation, primary group of the creator will be used",
            "type": "string"
          },
          "hasFormFieldData": {
            "description": "True if form field data is present.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "hasSignerIdentityReport": {
            "description": "True if agreement has signer identity report available.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement.If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender",
            "type": "string"
          },
          "mergeFieldInfo": {
            "description": "Optional default values for fields to merge into the document. The values will be presented to the signers for editable fields; for read-only fields the provided values will not be editable during the signing process.",
            "items": {
              "$ref": "#/components/schemas/MergefieldInfo"
            },
            "type": "array"
          },
          "message": {
            "description": "An optional message to the participants, describing what is being sent or why their signature is required",
            "type": "string"
          },
          "name": {
            "description": "The name of the agreement that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "notaryInfo": {
            "$ref": "#/components/schemas/NotaryInfo",
            "description": "Notary information",
            "items": {
              "$ref": "#/components/schemas/NotaryInfo"
            }
          },
          "parentId": {
            "description": "The parent id of a bulk send child *OR* the originating id of a web form agreement instance",
            "type": "string"
          },
          "participantSetsInfo": {
            "description": "A list of one or more participant set. A participant set may have one or more participant. If any member of the participant set takes the action that has been assigned to the set(Sign/Approve/Acknowledge etc), the action is considered as the action taken by whole participation set. For regular (non-Send in Bulk) documents, there is no limit on the number of electronic signatures in a single document. Written signatures are limited to four per document",
            "items": {
              "$ref": "#/components/schemas/ParticipantSetInfo"
            },
            "type": "array"
          },
          "postSignOption": {
            "$ref": "#/components/schemas/PostSignOption",
            "description": "URL and associated properties for the success page the user will be taken to after completing the signing process. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/PostSignOption"
            }
          },
          "reminderFrequency": {
            "description": "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used. Should not be provided in offline agreement creation. If provided in PUT as a different value than the current one, an error will be thrown.",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED",
              "ONCE"
            ],
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Optional secondary security parameters for the agreement. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          },
          "sendType": {
            "description": "Indicates the experience being used by the originator to send an agreement. <br>FILL_SIGN: originator is using Fill and Sign experience <br>SELF_SIGN: originator is using Self Signing experience <br>REGULAR_SEND: originator is using regular Send experience",
            "enum": [
              "FILL_SIGN",
              "SELF_SIGN",
              "REGULAR_SEND"
            ],
            "type": "string"
          },
          "senderEmail": {
            "description": "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored",
            "type": "string"
          },
          "signatureType": {
            "description": "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>,\nWRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system",
            "enum": [
              "ESIGN",
              "WRITTEN"
            ],
            "type": "string"
          },
          "state": {
            "description": "The state in which the agreement should land. The state field can only be provided in POST calls, will never get returned in GET /agreements/{ID} and will be ignored if provided in PUT /agreements/{ID} call. The eventual status of the agreement can be obtained from GET /agreements/ID",
            "enum": [
              "AUTHORING",
              "DRAFT",
              "IN_PROCESS",
              "RESTART"
            ],
            "type": "string"
          },
          "status": {
            "description": "This is a server generated attribute which provides the detailed status of an agreement.",
            "enum": [
              "OUT_FOR_SIGNATURE",
              "OUT_FOR_DELIVERY",
              "OUT_FOR_ACCEPTANCE",
              "OUT_FOR_FORM_FILLING",
              "OUT_FOR_APPROVAL",
              "AUTHORING",
              "CANCELLED",
              "SIGNED",
              "APPROVED",
              "DELIVERED",
              "ACCEPTED",
              "FORM_FILLED",
              "EXPIRED",
              "ARCHIVED",
              "PREFILL",
              "WIDGET_WAITING_FOR_VERIFICATION",
              "DRAFT",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "WAITING_FOR_FAXIN",
              "WAITING_FOR_VERIFICATION",
              "WAITING_FOR_NOTARIZATION"
            ],
            "type": "string"
          },
          "type": {
            "description": "The kind of agreement",
            "enum": [
              "AGREEMENT",
              "MEGASIGN_CHILD",
              "WIDGET_INSTANCE"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          },
          "workflowId": {
            "description": "The identifier of custom workflow which defines the routing path of an agreement. Should not be provided in offline agreement creation.",
            "type": "string"
          }
        },
        "required": [
          "fileInfos",
          "name",
          "participantSetsInfo",
          "signatureType",
          "state"
        ],
        "type": "object"
      },
      "AgreementCreationResponse": {
        "description": "A JSON  that contains both the id of the newly created agreement and URL / embedded code to direct the user to tne next step in the creation process.",
        "properties": {
          "id": {
            "description": "The unique identifier of the agreement",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "AgreementDocumentImageUrlsInfo": {
        "properties": {
          "documentId": {
            "description": "Id of the document",
            "type": "string"
          },
          "documentImageUrlsList": {
            "description": "A list of documents image URLs.",
            "items": {
              "$ref": "#/components/schemas/DocumentImageUrls"
            },
            "type": "array"
          }
        },
        "required": [
          "documentId",
          "documentImageUrlsList"
        ],
        "type": "object"
      },
      "AgreementDocuments": {
        "properties": {
          "documents": {
            "description": "A list of documents",
            "items": {
              "$ref": "#/components/schemas/Document"
            },
            "type": "array"
          },
          "supportingDocuments": {
            "description": "A list of supporting documents",
            "items": {
              "$ref": "#/components/schemas/SupportingDocument"
            },
            "type": "array"
          }
        },
        "required": [
          "documents"
        ],
        "type": "object"
      },
      "AgreementEvent": {
        "properties": {
          "actingUserEmail": {
            "description": "Email address of the user that created the event",
            "type": "string"
          },
          "actingUserIpAddress": {
            "description": "The IP address of the user that created the event",
            "type": "string"
          },
          "actingUserName": {
            "description": "The name of the acting user",
            "type": "string"
          },
          "comment": {
            "description": "The event comment. For RECALLED or REJECTED, the reason given by the user that initiates the event. For DELEGATE or SHARE, the message from the acting user to the participant",
            "type": "string"
          },
          "date": {
            "description": "The date of the audit event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "description": {
            "description": "A description of the audit event",
            "type": "string"
          },
          "device": {
            "description": "The device used for the event.",
            "type": "string"
          },
          "deviceLocation": {
            "$ref": "#/components/schemas/DeviceLocation",
            "description": "Location of the device that generated the event (This value may be null due to limited privileges)",
            "items": {
              "$ref": "#/components/schemas/DeviceLocation"
            }
          },
          "devicePhoneNumber": {
            "description": "Phone number from the device used when the participation is completed on a mobile phone",
            "type": "string"
          },
          "digitalSignatureInfo": {
            "$ref": "#/components/schemas/DigitalSignatureInfo",
            "description": "This is present for ESIGNED events when the participation is signed digitally",
            "items": {
              "$ref": "#/components/schemas/DigitalSignatureInfo"
            }
          },
          "electronicSealInfo": {
            "$ref": "#/components/schemas/ElectronicSealInfo",
            "description": "This is present for ELECTRONICLY_SIGNED events when the participation places an electronic seal on the agreement.",
            "items": {
              "$ref": "#/components/schemas/ElectronicSealInfo"
            }
          },
          "id": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "initiatingUserEmail": {
            "description": "Email address of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "initiatingUserName": {
            "description": "Full name of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "participantEmail": {
            "description": "Email address of the user that is the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantRole": {
            "description": "Role assumed by all participants in the participant set the participant belongs to (signer, approver etc.).",
            "enum": [
              "SIGNER",
              "DELEGATE_TO_SIGNER",
              "APPROVER",
              "DELEGATE_TO_APPROVER",
              "ACCEPTOR",
              "DELEGATE_TO_ACCEPTOR",
              "FORM_FILLER",
              "DELEGATE_TO_FORM_FILLER",
              "CERTIFIED_RECIPIENT",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "SHARE",
              "RESOURCE_SHARE",
              "SENDER",
              "NOTARY_SIGNER",
              "ELECTRONIC_SEALER"
            ],
            "type": "string"
          },
          "reminderParticipants": {
            "description": "A list of one or more participants who received the reminders",
            "items": {
              "$ref": "#/components/schemas/ReminderParticipant"
            },
            "type": "array"
          },
          "replacedParticipantEmail": {
            "description": "Email of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "replacedParticipantName": {
            "description": "Full name of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "signerNewName": {
            "description": "Signer changed name at signing : new name used to sign.",
            "type": "string"
          },
          "signerOldName": {
            "description": "Signer changed name at signing : name used previous to signing.",
            "type": "string"
          },
          "signingReason": {
            "description": "Signing reason captured during ESIGN or DIGSIGN",
            "type": "string"
          },
          "synchronizationId": {
            "description": "A unique identifier linking offline events to synchronization events (specified for offline signing events and synchronization events, else null)",
            "type": "string"
          },
          "type": {
            "description": "Type of agreement event",
            "enum": [
              "ACCESS_CODE_GENERATED",
              "ACCESS_CODE_CONSUMED",
              "AUTO_CANCELLED_CONVERSION_PROBLEM",
              "ACTION_AUTO_DELEGATED",
              "ACTION_COMPLETED",
              "ACTION_COMPLETED_HOSTED",
              "ACTION_COMPLETED_OFFLINE",
              "ACTION_COMPLETED_OFFLINE_HOSTED",
              "ACTION_COMPLETED_WIDGET_VERIFIED",
              "ACTION_COMPLETED_WIDGET_VERIFIED_API_TOKEN",
              "ACTION_COMPLETED_WIDGET_VERIFICATION_WAIVED",
              "ACTION_DELEGATED",
              "ACTION_REPLACED_SIGNER",
              "ACTION_REQUESTED",
              "CREATED",
              "CREATED_FROM_WIDGET",
              "CREATED_OFFLINE",
              "CREATED_VIA_UPLOAD",
              "CREATED_VIA_ACROBAT",
              "CREATED_VIA_READER",
              "ACTIVATED",
              "DIGITAL_SIGN_UIDAI_SIGNER_CONSENT",
              "DIGSIGNED",
              "DEACTIVATED",
              "DOCUMENTS_DELETED",
              "DOWNLOADED",
              "DELETED",
              "EMAIL_BOUNCED",
              "EMAIL_VIEWED",
              "EXPIRED",
              "EXPIRED_AUTOMATICALLY",
              "FAXED_BY_SENDER",
              "FAXIN_RECEIVED",
              "KBA_AUTHENTICATED",
              "MODIFIED",
              "OFFLINE_SYNC",
              "OTHER",
              "PAID",
              "PRESIGNED",
              "RECALLED",
              "RECALLED_MAX_SIGNING_KBA_ATTEMPTS",
              "RECALLED_MAX_SIGNING_PASSWORD_ATTEMPTS",
              "RECALLED_MAX_SIGNING_PHONE_ATTEMPTS",
              "REJECTED",
              "RESTARTED",
              "RECOVERED",
              "SENDER_CREATED_NEW_REVISION",
              "SHARED",
              "SIGNED",
              "SIGNING_URL_REQUESTED",
              "UPLOADED_BY_SENDER",
              "USER_ACK_AGREEMENT_MODIFIED",
              "READY_TO_VAULT",
              "VAULTED",
              "WEB_IDENTITY_AUTHENTICATED",
              "WEB_IDENTITY_SPECIFIED",
              "WRITTEN_DOWNLOAD",
              "WRITTEN_SIGNED",
              "READY_TO_NOTARIZE",
              "NOTARIZED",
              "NOTARY_TRANSACTION",
              "SIGNER_NAME_CHANGED_BY_SIGNER",
              "ELECTRONICALLY_SEALED",
              "URL_REAUTHENTICATION_REQUESTED",
              "REMINDER_SENT",
              "DOCUMENTS_VIEWED",
              "DOCUMENTS_VIEWED_HOSTED",
              "DOCUMENTS_VIEWED_PASSWORD_PROTECTED",
              "REMINDER_INITIATED"
            ],
            "type": "string"
          },
          "vaultEventId": {
            "description": "The identifier assigned by the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "vaultProviderName": {
            "description": "Name of the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "versionId": {
            "description": "An ID which uniquely identifies the version of the document associated with this audit event",
            "type": "string"
          }
        },
        "required": [
          "actingUserEmail",
          "actingUserIpAddress",
          "actingUserName",
          "date",
          "description",
          "device",
          "deviceLocation",
          "devicePhoneNumber",
          "digitalSignatureInfo",
          "electronicSealInfo",
          "initiatingUserEmail",
          "initiatingUserName",
          "participantEmail",
          "participantId",
          "participantRole",
          "synchronizationId",
          "type",
          "vaultEventId",
          "vaultProviderName",
          "versionId"
        ],
        "type": "object"
      },
      "AgreementEventList": {
        "properties": {
          "events": {
            "description": "An array of event objects.",
            "items": {
              "$ref": "#/components/schemas/AgreementEvent"
            },
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "type": "object"
      },
      "AgreementFormFields": {
        "description": "A JSON list of all of the fields for a form",
        "properties": {
          "fields": {
            "description": "List of the form fields in an agreement",
            "items": {
              "$ref": "#/components/schemas/FormField"
            },
            "type": "array"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "AgreementInfo": {
        "properties": {
          "agreementSettingsInfo": {
            "$ref": "#/components/schemas/AgreementSettingsInfo",
            "description": "Agreement Settings Info",
            "items": {
              "$ref": "#/components/schemas/AgreementSettingsInfo"
            }
          },
          "ccs": {
            "description": "A list of one or more CCs that will be copied in the agreement transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/AgreementCcInfo"
            },
            "type": "array"
          },
          "createdDate": {
            "description": "Date when agreement was created. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/OfflineDeviceInfo",
            "description": "Device info of the offline device. It should only be provided in case of offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/OfflineDeviceInfo"
            }
          },
          "documentRetentionAppliedDate": {
            "description": "Document retention applied date for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "format": "date",
            "type": "string"
          },
          "documentVisibilityEnabled": {
            "description": "If set to true, enable limited document visibility. Should not be provided in offline agreement creation.",
            "type": "boolean"
          },
          "emailOption": {
            "$ref": "#/components/schemas/EmailOption",
            "description": "Email configurations for the agreement. Should not be provided in offline agreement creation or when updating a non draft agreement.",
            "items": {
              "$ref": "#/components/schemas/EmailOption"
            }
          },
          "expirationTime": {
            "description": "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.",
            "format": "date",
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/ExternalId",
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Should not be provided in offline agreement creation. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            }
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            },
            "type": "array"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Should not be provided in offline agreement creation.",
            "type": "integer"
          },
          "formFieldGenerators": {
            "description": "List of form field generators to produce form fields on the resulting agreement",
            "items": {
              "$ref": "#/components/schemas/FormFieldGenerator"
            },
            "type": "array"
          },
          "formFieldLayerTemplates": {
            "description": "Specifies the form field layer template or source of form fields to apply on the files in this transaction. If specified, the FileInfo for this parameter must refer to a form field layer template via libraryDocumentId or libraryDocumentName, or if specified via transientDocumentId or documentURL, it must be of a supported file type. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the agreement belongs to. If not provided during agreement creation, primary group of the creator will be used",
            "type": "string"
          },
          "hasFormFieldData": {
            "description": "True if form field data is present.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "hasSignerIdentityReport": {
            "description": "True if agreement has signer identity report available.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement.If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender",
            "type": "string"
          },
          "mergeFieldInfo": {
            "description": "Optional default values for fields to merge into the document. The values will be presented to the signers for editable fields; for read-only fields the provided values will not be editable during the signing process.",
            "items": {
              "$ref": "#/components/schemas/MergefieldInfo"
            },
            "type": "array"
          },
          "message": {
            "description": "An optional message to the participants, describing what is being sent or why their signature is required",
            "type": "string"
          },
          "name": {
            "description": "The name of the agreement that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "notaryInfo": {
            "$ref": "#/components/schemas/NotaryInfo",
            "description": "Notary information",
            "items": {
              "$ref": "#/components/schemas/NotaryInfo"
            }
          },
          "parentId": {
            "description": "The parent id of a bulk send child *OR* the originating id of a web form agreement instance",
            "type": "string"
          },
          "participantSetsInfo": {
            "description": "A list of one or more participant set. A participant set may have one or more participant. If any member of the participant set takes the action that has been assigned to the set(Sign/Approve/Acknowledge etc), the action is considered as the action taken by whole participation set. For regular (non-Send in Bulk) documents, there is no limit on the number of electronic signatures in a single document. Written signatures are limited to four per document",
            "items": {
              "$ref": "#/components/schemas/ParticipantSetInfo"
            },
            "type": "array"
          },
          "postSignOption": {
            "$ref": "#/components/schemas/PostSignOption",
            "description": "URL and associated properties for the success page the user will be taken to after completing the signing process. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/PostSignOption"
            }
          },
          "reminderFrequency": {
            "description": "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used. Should not be provided in offline agreement creation. If provided in PUT as a different value than the current one, an error will be thrown.",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED",
              "ONCE"
            ],
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Optional secondary security parameters for the agreement. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          },
          "sendType": {
            "description": "Indicates the experience being used by the originator to send an agreement. <br>FILL_SIGN: originator is using Fill and Sign experience <br>SELF_SIGN: originator is using Self Signing experience <br>REGULAR_SEND: originator is using regular Send experience",
            "enum": [
              "FILL_SIGN",
              "SELF_SIGN",
              "REGULAR_SEND"
            ],
            "type": "string"
          },
          "senderEmail": {
            "description": "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored",
            "type": "string"
          },
          "signatureType": {
            "description": "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>,\nWRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system",
            "enum": [
              "ESIGN",
              "WRITTEN"
            ],
            "type": "string"
          },
          "state": {
            "description": "The state in which the agreement should land. The state field can only be provided in POST calls, will never get returned in GET /agreements/{ID} and will be ignored if provided in PUT /agreements/{ID} call. The eventual status of the agreement can be obtained from GET /agreements/ID",
            "enum": [
              "AUTHORING",
              "DRAFT",
              "IN_PROCESS",
              "RESTART"
            ],
            "type": "string"
          },
          "status": {
            "description": "This is a server generated attribute which provides the detailed status of an agreement.",
            "enum": [
              "OUT_FOR_SIGNATURE",
              "OUT_FOR_DELIVERY",
              "OUT_FOR_ACCEPTANCE",
              "OUT_FOR_FORM_FILLING",
              "OUT_FOR_APPROVAL",
              "AUTHORING",
              "CANCELLED",
              "SIGNED",
              "APPROVED",
              "DELIVERED",
              "ACCEPTED",
              "FORM_FILLED",
              "EXPIRED",
              "ARCHIVED",
              "PREFILL",
              "WIDGET_WAITING_FOR_VERIFICATION",
              "DRAFT",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "WAITING_FOR_FAXIN",
              "WAITING_FOR_VERIFICATION",
              "WAITING_FOR_NOTARIZATION"
            ],
            "type": "string"
          },
          "type": {
            "description": "The kind of agreement",
            "enum": [
              "AGREEMENT",
              "MEGASIGN_CHILD",
              "WIDGET_INSTANCE"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          },
          "workflowId": {
            "description": "The identifier of custom workflow which defines the routing path of an agreement. Should not be provided in offline agreement creation.",
            "type": "string"
          }
        },
        "required": [
          "fileInfos",
          "name",
          "participantSetsInfo",
          "signatureType",
          "status"
        ],
        "type": "object"
      },
      "AgreementRejectionInfo": {
        "properties": {
          "comment": {
            "description": "Comment describing the reason to reject this agreement.",
            "type": "string"
          }
        },
        "required": [
          "comment"
        ],
        "type": "object"
      },
      "AgreementRestartInfo": {
        "properties": {
          "message": {
            "description": "Message explaining the reason for the agreement restart",
            "type": "string"
          }
        },
        "required": [
          "message"
        ],
        "type": "object"
      },
      "AgreementSettingsInfo": {
        "properties": {
          "canEditAgreementSettings": {
            "description": " if false, the user will not be allowed to modify any agreement settings. defaults to true.",
            "type": "boolean"
          },
          "canEditElectronicSeals": {
            "description": "if false, the user will not be allowed to modify electronic seal, defaults to true.",
            "type": "boolean"
          },
          "canEditFiles": {
            "description": "if false, the user will not be permitted to modify the set of files being sent out for signature, defaults to true.",
            "type": "boolean"
          },
          "hipaaEnabled": {
            "description": "True if the Agreement sender had HIPAA protections enabled for their agreements at the time the agreement was created.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "AgreementStateInfo": {
        "properties": {
          "agreementCancellationInfo": {
            "$ref": "#/components/schemas/AgreementCancellationInfo",
            "description": "Cancellation information for the agreement",
            "items": {
              "$ref": "#/components/schemas/AgreementCancellationInfo"
            }
          },
          "agreementRestartInfo": {
            "$ref": "#/components/schemas/AgreementRestartInfo",
            "description": "Information regarding agreement restart",
            "items": {
              "$ref": "#/components/schemas/AgreementRestartInfo"
            }
          },
          "state": {
            "description": "The state in which the agreement should land",
            "enum": [
              "AUTHORING",
              "CANCELLED",
              "IN_PROCESS",
              "RESTART"
            ],
            "type": "string"
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "AgreementView": {
        "properties": {
          "embeddedCode": {
            "description": "Embedded code of url of resource ",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration of user url ",
            "format": "date",
            "type": "string"
          },
          "isCurrent": {
            "description": "True if this view is the current view",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the requested agreement view",
            "enum": [
              "COMPOSE",
              "MODIFY",
              "PREFILL",
              "AUTHORING",
              "SEND_PROGRESS",
              "POST_CREATE",
              "DOCUMENT",
              "MANAGE",
              "SIGNING",
              "ALL"
            ],
            "type": "string"
          },
          "url": {
            "description": "Url of resource location",
            "type": "string"
          }
        },
        "required": [
          "isCurrent",
          "name"
        ],
        "type": "object"
      },
      "AgreementViewConfiguration": {
        "properties": {
          "autoLoginUser": {
            "description": "Auto LogIn Flag. If true, the URL returned will automatically log the user in. If false, the URL returned will require the credentials. By default its value is false",
            "type": "boolean"
          },
          "frameParent": {
            "description": "An optional field to provide the comma-separated list of parent domain urls where the returned URLs may be iframed. If provided with non-empty and valid list of parent domain urls, it will be used to allow framing for the same. By default the value is null and the Acrobat Sign pages will not be viewable in an iframe.",
            "type": "string"
          },
          "locale": {
            "description": "Message template locale",
            "type": "string"
          },
          "noChrome": {
            "description": "No Chrome Flag. If true, the embedded page is shown without a navigation header or footer. If false, the standard page header and footer will be present. By default its value is false",
            "type": "boolean"
          },
          "postSendOption": {
            "$ref": "#/components/schemas/PostSendOption",
            "description": "Optional field available only in COMPOSE, AUTHORING and PREFILL views or as part of ALL view. Allows API client to configure a URL to redirect the sender to after the SEND flow is complete. User must be logged in or autoLoginUser=true must be specified to configure the redirect. The view URL returned in the API response must be visited within 60 seconds of the response to configure the redirect. If not the user will be redirected to the default POST_SEND view",
            "items": {
              "$ref": "#/components/schemas/PostSendOption"
            }
          }
        },
        "type": "object"
      },
      "AgreementViewInfo": {
        "properties": {
          "commonViewConfiguration": {
            "$ref": "#/components/schemas/AgreementViewConfiguration",
            "description": "Common view configuration for all the available views",
            "items": {
              "$ref": "#/components/schemas/AgreementViewConfiguration"
            }
          },
          "composeViewConfiguration": {
            "$ref": "#/components/schemas/ComposeViewConfiguration",
            "description": "Compose page view configuration",
            "items": {
              "$ref": "#/components/schemas/ComposeViewConfiguration"
            }
          },
          "name": {
            "description": "Name of the requested agreement view",
            "enum": [
              "COMPOSE",
              "MODIFY",
              "PREFILL",
              "AUTHORING",
              "SEND_PROGRESS",
              "POST_CREATE",
              "DOCUMENT",
              "MANAGE",
              "SIGNING",
              "ALL"
            ],
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "AgreementViews": {
        "properties": {
          "agreementViewList": {
            "description": "List of agreement views",
            "items": {
              "$ref": "#/components/schemas/AgreementView"
            },
            "type": "array"
          }
        },
        "required": [
          "agreementViewList"
        ],
        "type": "object"
      },
      "AnchorTextInfo": {
        "description": "Information required for generating form fields relative to text content within the agreement documents",
        "properties": {
          "anchorText": {
            "description": "Text to search for to generate form fields relative to",
            "type": "string"
          },
          "anchoredFormFieldLocation": {
            "$ref": "#/components/schemas/AnchoredFormFieldLocation",
            "description": "Information on the relative location to generate form fields",
            "items": {
              "$ref": "#/components/schemas/AnchoredFormFieldLocation"
            }
          },
          "pages": {
            "description": "An array of page numbers to search for anchored text to generate form fields on. By default all pages will be searched",
            "items": {
              "format": "int32",
              "type": "integer"
            },
            "type": "array"
          }
        },
        "required": [
          "anchorText",
          "anchoredFormFieldLocation"
        ],
        "type": "object"
      },
      "AnchoredFormFieldLocation": {
        "description": "Location information for placing generated form fields relative to the location of text content found within the agreement documents",
        "properties": {
          "height": {
            "description": "The generated form field height in default user space units",
            "format": "double",
            "type": "number"
          },
          "offsetX": {
            "description": "The x offset from the anchor text to the form field in default user space units",
            "format": "double",
            "type": "number"
          },
          "offsetY": {
            "description": "The y offset from the anchor text to the form field in default user space units",
            "format": "double",
            "type": "number"
          },
          "width": {
            "description": "The generated form field width in default user space units",
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "height",
          "width"
        ],
        "type": "object"
      },
      "CCParticipantInfo": {
        "properties": {
          "company": {
            "description": "Company of the CC participant, if available.",
            "type": "string"
          },
          "email": {
            "description": "Email of the CC participant of the agreement",
            "type": "string"
          },
          "hidden": {
            "description": "True if the agreement is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the CC participant, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the CC participant of the agreement.",
            "type": "string"
          },
          "self": {
            "description": "True if the CC participant is the same user that is calling the API.",
            "type": "boolean"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self"
        ],
        "type": "object"
      },
      "CombinedDocumentPagesInfo": {
        "properties": {
          "documentPagesInfo": {
            "description": "List of basic information of all pages of the combined document of an Agreement.",
            "items": {
              "$ref": "#/components/schemas/DocumentPageInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "documentPagesInfo"
        ],
        "type": "object"
      },
      "ComposeViewConfiguration": {
        "properties": {
          "fileUploadOptions": {
            "$ref": "#/components/schemas/FileUploadOptions",
            "description": "Controls various file upload options available on the compose page",
            "items": {
              "$ref": "#/components/schemas/FileUploadOptions"
            }
          },
          "isPreviewSelected": {
            "description": "Should the compose page be provided with authoring mode selected?",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "DelegatedParticipantInfo": {
        "properties": {
          "email": {
            "description": "Email of the participant. In case of modifying a participant set (PUT) this is a required field. In case of GET, this is the required field and will always be returned unless it is a fax workflow (legacy agreements) that were created using fax as input",
            "type": "string"
          },
          "fullName": {
            "description": "The full name of the delegatee, if available.",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/DelegatedParticipantSecurityOption",
            "description": "Security options that apply to the participant.",
            "items": {
              "$ref": "#/components/schemas/DelegatedParticipantSecurityOption"
            }
          }
        },
        "required": [
          "email",
          "securityOption"
        ],
        "type": "object"
      },
      "DelegatedParticipantSecurityOption": {
        "properties": {
          "phoneInfo": {
            "$ref": "#/components/schemas/PhoneInfo",
            "description": "The phoneInfo required for the participant to view and sign the document",
            "items": {
              "$ref": "#/components/schemas/PhoneInfo"
            }
          }
        },
        "type": "object"
      },
      "DelegatedParticipantSetInfo": {
        "properties": {
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set. Required, unless ParticipantSet has the ELECTRONIC_SEALER role",
            "items": {
              "$ref": "#/components/schemas/DelegatedParticipantInfo"
            },
            "type": "array"
          },
          "privateMessage": {
            "description": "Participant set's private message - all participants in the set will receive the same message. This cannot be changed as part of the PUT call.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DelegationResponse": {
        "description": "A JSON that contains the id of newly created delegated participant set",
        "properties": {
          "id": {
            "description": "The unique identifier of the participant set to which the agreement was forwarded.",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "DetailedParticipantInfo": {
        "properties": {
          "company": {
            "description": "The company of the participant, if available. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the participant was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the participant. In case of modifying a participant set (PUT) this is a required field. In case of GET, this is the required field and will always be returned unless it is a fax workflow (legacy agreements) that were created using fax as input",
            "type": "string"
          },
          "hidden": {
            "description": "True if the agreement is hidden for the user that is calling the API. Only returned if self is true. Ignored (not required) if modifying a participant (PUT).",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the participant. This will be returned as part of Get call but is not mandatory to be passed as part of PUT call for agreements/{id}/members/participantSets/{id}.",
            "type": "string"
          },
          "name": {
            "description": "The name of the participant, if available. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "privateMessage": {
            "description": "The private message of the participant, if available. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/ParticipantSecurityOption",
            "description": "Security options that apply to the participant.",
            "items": {
              "$ref": "#/components/schemas/ParticipantSecurityOption"
            }
          },
          "self": {
            "description": "True if this participant is the same user that is calling the API. Returned as part of Get. Ignored (not required) if modifying a participant set (PUT).",
            "type": "boolean"
          },
          "status": {
            "description": "The status of the participant. This cannot be changed as part of the PUT call. New participants will be ignored if added with a REPLACED status.",
            "enum": [
              "REPLACED",
              "ACTIVE"
            ],
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the participant. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "email",
          "securityOption"
        ],
        "type": "object"
      },
      "DetailedParticipantSetInfo": {
        "properties": {
          "electronicSealId": {
            "description": "ID of the sealing credential, which can be obtained through <b>GET /autoseals</b> call.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the participant set. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set. Required, unless ParticipantSet has the ELECTRONIC_SEALER role",
            "items": {
              "$ref": "#/components/schemas/DetailedParticipantInfo"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of ParticipantSet (it can be empty, but needs not to be unique in a single agreement). Maximum no of characters in participant set name is restricted to 255. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "order": {
            "description": "Index indicating sequential signing group (specified for hybrid routing). This cannot be changed as part of the PUT call.",
            "type": "integer"
          },
          "privateMessage": {
            "description": "Participant set's private message - all participants in the set will receive the same message. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "role": {
            "description": "Role assumed by all participants in the set (signer, approver etc.). This cannot be changed as part of the PUT call.",
            "enum": [
              "SIGNER",
              "SENDER",
              "APPROVER",
              "ACCEPTOR",
              "CERTIFIED_RECIPIENT",
              "FORM_FILLER",
              "DELEGATE_TO_SIGNER",
              "DELEGATE_TO_APPROVER",
              "DELEGATE_TO_ACCEPTOR",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "DELEGATE_TO_FORM_FILLER",
              "SHARE",
              "NOTARY_SIGNER",
              "ELECTRONIC_SEALER"
            ],
            "type": "string"
          },
          "status": {
            "description": "The agreement status with respect to the participant set. This cannot be changed as part of the PUT call.",
            "enum": [
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "NOT_YET_VISIBLE",
              "WAITING_FOR_NOTARIZATION",
              "WAITING_FOR_OTHERS",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_MY_VERIFICATION",
              "WAITING_FOR_PREFILL"
            ],
            "type": "string"
          }
        },
        "required": [
          "order",
          "role"
        ],
        "type": "object"
      },
      "DeviceLocation": {
        "properties": {
          "latitude": {
            "description": "Latitude coordinate",
            "format": "float",
            "type": "number"
          },
          "longitude": {
            "description": "Longitude coordinate",
            "format": "float",
            "type": "number"
          }
        },
        "required": [
          "latitude",
          "longitude"
        ],
        "type": "object"
      },
      "DigAuthInfo": {
        "properties": {
          "providerDesc": {
            "description": "Digital Identity Gateway Provider Description. This will be ignored as part of POST or PUT calls.",
            "type": "string"
          },
          "providerId": {
            "description": "Digital Identity Gateway Provider Id. When replacing a participant that has DIG_ID authentication specified, you must supply a provider id for the new participant.",
            "type": "string"
          },
          "providerName": {
            "description": "Digital Identity Gateway Provider Name. This will be ignored as part of POST or PUT calls.",
            "type": "string"
          }
        },
        "required": [
          "providerId"
        ],
        "type": "object"
      },
      "DigitalSignatureInfo": {
        "properties": {
          "certificateIssuer": {
            "description": "Certificate Issuer for digital signing",
            "type": "string"
          },
          "cloudProviderIp": {
            "description": "Cloud Provider IP for digital signing",
            "type": "string"
          },
          "cloudProviderUrl": {
            "description": "Cloud Provider URL for digital signing",
            "type": "string"
          },
          "company": {
            "description": "Company name captured during digital signing",
            "type": "string"
          },
          "email": {
            "description": "Email captured during digital signing",
            "type": "string"
          },
          "name": {
            "description": "Name captured during digital signing",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "name"
        ],
        "type": "object"
      },
      "DisplayParticipantInfo": {
        "properties": {
          "company": {
            "description": "Displays the name of the company of the user, if available",
            "type": "string"
          },
          "email": {
            "description": "Displays the email of the user",
            "type": "string"
          },
          "fullName": {
            "description": "Displays the full name of the user, if available. ",
            "type": "string"
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "DisplayParticipantSetInfo": {
        "properties": {
          "displayUserSetMemberInfos": {
            "description": "Displays the info about user set",
            "items": {
              "$ref": "#/components/schemas/DisplayParticipantInfo"
            },
            "type": "array"
          },
          "displayUserSetName": {
            "description": "The name of the display user set. Returned only, if the API caller is the sender of agreement. ",
            "type": "string"
          }
        },
        "required": [
          "displayUserSetMemberInfos"
        ],
        "type": "object"
      },
      "Document": {
        "properties": {
          "createdDate": {
            "description": "The date the document was created",
            "format": "date",
            "type": "string"
          },
          "id": {
            "description": "ID of the document. In case of PUT call, this is the only field that is accepted in Document structure. Name and mimeType are ignored in case of PUT call",
            "type": "string"
          },
          "label": {
            "description": "Label of the document",
            "type": "string"
          },
          "mimeType": {
            "description": "mimeType of the original file. This is returned in GET but not accepted back in PUT",
            "type": "string"
          },
          "name": {
            "description": "Name of the original document uploaded. This is returned in GET but not accepted back in PUT",
            "type": "string"
          },
          "numPages": {
            "description": "Number of pages in the document",
            "type": "integer"
          }
        },
        "required": [
          "createdDate",
          "id",
          "label",
          "numPages"
        ],
        "type": "object"
      },
      "DocumentImageUrls": {
        "properties": {
          "imageSize": {
            "description": "ImageSize corresponding to the imageUrl returned ",
            "enum": [
              "FIXED_WIDTH_50px",
              "FIXED_WIDTH_250px",
              "FIXED_WIDTH_675px",
              "ZOOM_50_PERCENT",
              "ZOOM_75_PERCENT",
              "ZOOM_100_PERCENT",
              "ZOOM_125_PERCENT",
              "ZOOM_150_PERCENT",
              "ZOOM_200_PERCENT"
            ],
            "type": "string"
          },
          "imageURLs": {
            "description": "A list of image url (one per page).",
            "items": {
              "$ref": "#/components/schemas/PageImageUrl"
            },
            "type": "array"
          },
          "imagesAvailable": {
            "description": "true if images for the associated image size is available, else false.",
            "type": "boolean"
          }
        },
        "required": [
          "imageURLs"
        ],
        "type": "object"
      },
      "DocumentImageUrlsInfo": {
        "properties": {
          "documentId": {
            "description": "Id of the document",
            "type": "string"
          },
          "documentImageUrlsList": {
            "description": "A list of documents image URLs.",
            "items": {
              "$ref": "#/components/schemas/DocumentImageUrls"
            },
            "type": "array"
          }
        },
        "required": [
          "documentId",
          "documentImageUrlsList"
        ],
        "type": "object"
      },
      "DocumentPageInfo": {
        "properties": {
          "height": {
            "description": "Height of the page",
            "format": "double",
            "type": "number"
          },
          "index": {
            "description": "Index of the page in combined document starting from 1",
            "type": "integer"
          },
          "rotation": {
            "description": "Rotation angle of the page in clockwise direction in degree",
            "format": "double",
            "type": "number"
          },
          "width": {
            "description": "Width of the page",
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "height",
          "index",
          "rotation",
          "width"
        ],
        "type": "object"
      },
      "DocumentUrl": {
        "properties": {
          "url": {
            "description": "Secure URL of the document",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      },
      "DocumentsImageUrlsInfo": {
        "properties": {
          "originalDocumentsImageUrlsInfo": {
            "description": "A list of original document image URLs info.",
            "items": {
              "$ref": "#/components/schemas/DocumentImageUrlsInfo"
            },
            "type": "array"
          },
          "supportingDocumentsImageUrlsInfo": {
            "description": "A list of supporting document image URLs info.",
            "items": {
              "$ref": "#/components/schemas/DocumentImageUrlsInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "originalDocumentsImageUrlsInfo"
        ],
        "type": "object"
      },
      "ElectronicSealInfo": {
        "properties": {
          "company": {
            "description": "Company name that placed the electronic seal",
            "type": "string"
          },
          "id": {
            "description": "unique identifier for the electronic seal",
            "type": "string"
          },
          "name": {
            "description": "the display name of the electronic seal",
            "type": "string"
          }
        },
        "required": [
          "company",
          "id",
          "name"
        ],
        "type": "object"
      },
      "EmailOption": {
        "properties": {
          "sendOptions": {
            "$ref": "#/components/schemas/SendOptions",
            "description": "Specify emails to be sent to different participants at different steps of the agreement process. Note: ALL means  emails for the events will be sent to all participants. NONE means emails for the events will not be sent to any participant",
            "items": {
              "$ref": "#/components/schemas/SendOptions"
            }
          }
        },
        "type": "object"
      },
      "ExternalId": {
        "properties": {
          "id": {
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FetchedAgreementInfo": {
        "properties": {
          "agreementSettingsInfo": {
            "$ref": "#/components/schemas/AgreementSettingsInfo",
            "description": "Agreement Settings Info",
            "items": {
              "$ref": "#/components/schemas/AgreementSettingsInfo"
            }
          },
          "ccs": {
            "description": "A list of one or more CCs that will be copied in the agreement transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/AgreementCcInfo"
            },
            "type": "array"
          },
          "createdDate": {
            "description": "Date when agreement was created. This is a server generated attributed and can not be provided in POST/PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "deviceInfo": {
            "$ref": "#/components/schemas/OfflineDeviceInfo",
            "description": "Device info of the offline device. It should only be provided in case of offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/OfflineDeviceInfo"
            }
          },
          "documentRetentionAppliedDate": {
            "description": "Document retention applied date for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "format": "date",
            "type": "string"
          },
          "documentVisibilityEnabled": {
            "description": "If set to true, enable limited document visibility. Should not be provided in offline agreement creation.",
            "type": "boolean"
          },
          "emailOption": {
            "$ref": "#/components/schemas/EmailOption",
            "description": "Email configurations for the agreement. Should not be provided in offline agreement creation or when updating a non draft agreement.",
            "items": {
              "$ref": "#/components/schemas/EmailOption"
            }
          },
          "expirationTime": {
            "description": "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.",
            "format": "date",
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/ExternalId",
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Should not be provided in offline agreement creation. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            }
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            },
            "type": "array"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Should not be provided in offline agreement creation.",
            "type": "integer"
          },
          "formFieldGenerators": {
            "description": "List of form field generators to produce form fields on the resulting agreement",
            "items": {
              "$ref": "#/components/schemas/FormFieldGenerator"
            },
            "type": "array"
          },
          "formFieldLayerTemplates": {
            "description": "Specifies the form field layer template or source of form fields to apply on the files in this transaction. If specified, the FileInfo for this parameter must refer to a form field layer template via libraryDocumentId or libraryDocumentName, or if specified via transientDocumentId or documentURL, it must be of a supported file type. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the agreement belongs to. If not provided during agreement creation, primary group of the creator will be used",
            "type": "string"
          },
          "hasFormFieldData": {
            "description": "True if form field data is present.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "hasSignerIdentityReport": {
            "description": "True if agreement has signer identity report available.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement.If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender",
            "type": "string"
          },
          "mergeFieldInfo": {
            "description": "Optional default values for fields to merge into the document. The values will be presented to the signers for editable fields; for read-only fields the provided values will not be editable during the signing process.",
            "items": {
              "$ref": "#/components/schemas/MergefieldInfo"
            },
            "type": "array"
          },
          "message": {
            "description": "An optional message to the participants, describing what is being sent or why their signature is required",
            "type": "string"
          },
          "name": {
            "description": "The name of the agreement that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "notaryInfo": {
            "$ref": "#/components/schemas/NotaryInfo",
            "description": "Notary information",
            "items": {
              "$ref": "#/components/schemas/NotaryInfo"
            }
          },
          "parentId": {
            "description": "The parent id of a bulk send child *OR* the originating id of a web form agreement instance",
            "type": "string"
          },
          "participantSetsInfo": {
            "description": "A list of one or more participant set. A participant set may have one or more participant. If any member of the participant set takes the action that has been assigned to the set(Sign/Approve/Acknowledge etc), the action is considered as the action taken by whole participation set. For regular (non-Send in Bulk) documents, there is no limit on the number of electronic signatures in a single document. Written signatures are limited to four per document",
            "items": {
              "$ref": "#/components/schemas/ParticipantSetInfo"
            },
            "type": "array"
          },
          "postSignOption": {
            "$ref": "#/components/schemas/PostSignOption",
            "description": "URL and associated properties for the success page the user will be taken to after completing the signing process. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/PostSignOption"
            }
          },
          "reminderFrequency": {
            "description": "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used. Should not be provided in offline agreement creation. If provided in PUT as a different value than the current one, an error will be thrown.",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED",
              "ONCE"
            ],
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Optional secondary security parameters for the agreement. Should not be provided in offline agreement creation.",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          },
          "sendType": {
            "description": "Indicates the experience being used by the originator to send an agreement. <br>FILL_SIGN: originator is using Fill and Sign experience <br>SELF_SIGN: originator is using Self Signing experience <br>REGULAR_SEND: originator is using regular Send experience",
            "enum": [
              "FILL_SIGN",
              "SELF_SIGN",
              "REGULAR_SEND"
            ],
            "type": "string"
          },
          "senderEmail": {
            "description": "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored",
            "type": "string"
          },
          "signatureType": {
            "description": "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>,\nWRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system",
            "enum": [
              "ESIGN",
              "WRITTEN"
            ],
            "type": "string"
          },
          "state": {
            "description": "The state in which the agreement should land. The state field can only be provided in POST calls, will never get returned in GET /agreements/{ID} and will be ignored if provided in PUT /agreements/{ID} call. The eventual status of the agreement can be obtained from GET /agreements/ID",
            "enum": [
              "AUTHORING",
              "DRAFT",
              "IN_PROCESS",
              "RESTART"
            ],
            "type": "string"
          },
          "status": {
            "description": "This is a server generated attribute which provides the detailed status of an agreement.",
            "enum": [
              "OUT_FOR_SIGNATURE",
              "OUT_FOR_DELIVERY",
              "OUT_FOR_ACCEPTANCE",
              "OUT_FOR_FORM_FILLING",
              "OUT_FOR_APPROVAL",
              "AUTHORING",
              "CANCELLED",
              "SIGNED",
              "APPROVED",
              "DELIVERED",
              "ACCEPTED",
              "FORM_FILLED",
              "EXPIRED",
              "ARCHIVED",
              "PREFILL",
              "WIDGET_WAITING_FOR_VERIFICATION",
              "DRAFT",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "WAITING_FOR_FAXIN",
              "WAITING_FOR_VERIFICATION",
              "WAITING_FOR_NOTARIZATION"
            ],
            "type": "string"
          },
          "type": {
            "description": "The kind of agreement",
            "enum": [
              "AGREEMENT",
              "MEGASIGN_CHILD",
              "WIDGET_INSTANCE"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          },
          "workflowId": {
            "description": "The identifier of custom workflow which defines the routing path of an agreement. Should not be provided in offline agreement creation.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "participantSetsInfo",
          "signatureType",
          "status"
        ],
        "type": "object"
      },
      "FileInfo": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/Document",
            "description": "A document that is associated with the agreement. This field cannot be provided in POST call. In case of GET call, this is the only field returned in the response",
            "items": {
              "$ref": "#/components/schemas/Document"
            }
          },
          "label": {
            "description": "The unique label value of a file info element. In case of custom workflow this will map a file to corresponding file element in workflow definition. This must be specified in case of custom workflow agreement creation request ",
            "type": "string"
          },
          "libraryDocumentId": {
            "description": "ID for an existing Library document that will be added to the agreement",
            "type": "string"
          },
          "notarize": {
            "description": "Indicates that this document needs to be notarized",
            "type": "boolean"
          },
          "transientDocumentId": {
            "description": "ID for a transient document that will be added to the agreement",
            "type": "string"
          },
          "urlFileInfo": {
            "$ref": "#/components/schemas/URLFileInfo",
            "description": "URL for an external document to add to the agreement",
            "items": {
              "$ref": "#/components/schemas/URLFileInfo"
            }
          }
        },
        "type": "object"
      },
      "FileUploadOptions": {
        "properties": {
          "canEditFiles": {
            "description": "Whether the file upload section can be edited by adding or removing files. Default value is taken as true. Changing the default value will alter the compose page view configuration for this agreement, but is not an access control mechanism",
            "type": "boolean"
          },
          "libraryDocument": {
            "description": "Whether library documents link should appear or not. Default value is taken as true",
            "type": "boolean"
          },
          "localFile": {
            "description": "Whether local file upload button should appear or not. Default value is taken as true",
            "type": "boolean"
          },
          "webConnectors": {
            "description": "Whether link to attach documents from web sources like Dropbox should appear or not. Default value is taken as true",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "FormField": {
        "description": "A form field for an agreement.",
        "properties": {
          "alignment": {
            "description": "Alignment of the text.",
            "enum": [
              "LEFT",
              "RIGHT",
              "CENTER"
            ],
            "type": "string"
          },
          "assignee": {
            "description": "Who the field is assigned to. Valid values are a participant set id, null, \"NOBODY\", \"PREFILL\" or \"EVERYONE\". If set to a participant set id, then any member of that participant set may fill out the field. \"NOBODY\" indicates that the field may not be filled by anybody (e.g. autopopulated fields like transaction number). \"PREFILL\" indicates that the field will be filled by the sender before the agreement is sent out for signing. \"EVERYONE\" exists only in hyperlink fields currently and indicates that it is assigned to all participants. null indicates that anybody may fill out the field. If the propeerty isn't specified, it is treated as null.",
            "type": "string"
          },
          "backgroundColor": {
            "description": "Background color of the form field in RGB or HEX format",
            "type": "string"
          },
          "borderColor": {
            "description": "Color of the border of the field in RGB or HEX format",
            "type": "string"
          },
          "borderStyle": {
            "description": "Style of the border of the field.",
            "enum": [
              "SOLID",
              "DASHED",
              "BEVELED",
              "INSET",
              "UNDERLINE"
            ],
            "type": "string"
          },
          "borderWidth": {
            "description": "Width of the border of the field in default user space units",
            "format": "double",
            "type": "number"
          },
          "calculated": {
            "description": "true if this field's value is calculated from an expression, else false",
            "type": "boolean"
          },
          "conditionalAction": {
            "$ref": "#/components/schemas/FormFieldConditionalAction",
            "description": "A predicate (or set of predicates) that determines whether this field is visible and enabled.",
            "items": {
              "$ref": "#/components/schemas/FormFieldConditionalAction"
            }
          },
          "contentType": {
            "description": "Content Type of the form field.",
            "enum": [
              "DATA",
              "SIGNATURE_BLOCK",
              "SIGNATURE",
              "SIGNER_NAME",
              "SIGNER_FIRST_NAME",
              "SIGNER_LAST_NAME",
              "SIGNER_INITIALS",
              "SIGNER_EMAIL",
              "SIGNER_TITLE",
              "SIGNER_COMPANY",
              "SIGNATURE_DATE",
              "AGREEMENT_NAME",
              "AGREEMENT_MESSAGE",
              "TRANSACTION_ID",
              "SIGNATURE_STAMP",
              "PAYMENT",
              "DIGITAL_SIGNATURE",
              "CALC"
            ],
            "type": "string"
          },
          "currency": {
            "description": "A currency ISO code. Only applicable for payment form fields. Should be one of the currencies supported in the payment integration merchant accounts.",
            "type": "string"
          },
          "defaultValue": {
            "description": "Default value of the form field",
            "type": "string"
          },
          "displayFormat": {
            "description": "Format of the value of the field to be displayed based on the displayFormatType property.",
            "type": "string"
          },
          "displayFormatType": {
            "description": "Format type of the text field.",
            "enum": [
              "DEFAULT",
              "DATE",
              "NUMBER"
            ],
            "type": "string"
          },
          "displayLabel": {
            "description": "Display label attached to the field",
            "type": "string"
          },
          "fontColor": {
            "description": "Font color of the form field in RGB or HEX format",
            "type": "string"
          },
          "fontName": {
            "description": "Font name of the form field",
            "type": "string"
          },
          "fontSize": {
            "description": "Font size of the form field in points",
            "format": "double",
            "type": "number"
          },
          "hiddenOptions": {
            "description": "Text values which are hidden in a drop down form field",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "hyperlink": {
            "$ref": "#/components/schemas/FormFieldHyperlink",
            "description": "Hyperlink-specific data (e.g. as url, link type)",
            "items": {
              "$ref": "#/components/schemas/FormFieldHyperlink"
            }
          },
          "inputType": {
            "description": "Input type of the form field",
            "enum": [
              "TEXT_FIELD",
              "MULTILINE",
              "PASSWORD",
              "RADIO",
              "CHECKBOX",
              "DROP_DOWN",
              "LISTBOX",
              "SIGNATURE",
              "PDF_SIGNATURE",
              "BUTTON",
              "BLOCK",
              "FILE_CHOOSER",
              "COMB",
              "INLINE_IMAGE",
              "UNSUPPORTED"
            ],
            "type": "string"
          },
          "locations": {
            "description": "All locations in a document where the form field is placed",
            "items": {
              "$ref": "#/components/schemas/FormFieldLocation"
            },
            "type": "array"
          },
          "masked": {
            "description": "true if the input entered by the signer has to be masked (like password), false if it shouldn't be",
            "type": "boolean"
          },
          "maskingText": {
            "description": "Text to mask the masked form field",
            "type": "string"
          },
          "maxLength": {
            "description": "Maximum length of the input text field in terms of no. of characters",
            "type": "integer"
          },
          "maxValue": {
            "description": "Upper bound of the number that can be entered by the signer",
            "format": "double",
            "type": "number"
          },
          "minLength": {
            "description": "Minimum length of the input text field in terms of no. of characters",
            "type": "integer"
          },
          "minValue": {
            "description": "Lower bound of the number that can be entered by the signer",
            "format": "double",
            "type": "number"
          },
          "name": {
            "description": "The name of the form field",
            "type": "string"
          },
          "origin": {
            "description": "Origin of Form Field",
            "enum": [
              "AUTHORED",
              "GENERATED",
              "IMPORTED"
            ],
            "type": "string"
          },
          "radioCheckType": {
            "description": "The type of radio button (if field is radio button, identified by inputType).",
            "enum": [
              "CIRCLE",
              "CHECK",
              "CROSS",
              "DIAMOND",
              "SQUARE",
              "STAR"
            ],
            "type": "string"
          },
          "readOnly": {
            "description": "true if it is a read-only field, else false",
            "type": "boolean"
          },
          "required": {
            "description": "true if it is a mandatory field to be filled by the signer, else false",
            "type": "boolean"
          },
          "tooltip": {
            "description": "Tooltip text for the form field",
            "type": "string"
          },
          "urlOverridable": {
            "description": "For web form text fields only - true if the default value may come from the URL, else false",
            "type": "boolean"
          },
          "validation": {
            "description": "Rule for validating the field value.",
            "enum": [
              "NONE",
              "STRING",
              "NUMBER",
              "DATE",
              "DATE_CUSTOM",
              "TIME",
              "ZIP",
              "PHONE",
              "SOCIAL_SEC",
              "EMAIL",
              "CURRENCY",
              "PERCENT",
              "FORMULA",
              "CUSTOM",
              "XFA_PICTURE"
            ],
            "type": "string"
          },
          "validationData": {
            "description": "Further data for validating input with regards to the field's specified format. The contents and interpretation of formatData depends on the value of validation.",
            "type": "string"
          },
          "validationErrMsg": {
            "description": "Error message to be shown to the signer if filled value doesn't match the validations of the form field",
            "type": "string"
          },
          "valueExpression": {
            "description": "Expression to calculate value of the form field",
            "type": "string"
          },
          "visible": {
            "description": "If set to false, then the form field is hidden.  Otherwise, it is visible.",
            "type": "boolean"
          },
          "visibleOptions": {
            "description": "Text values which are visible in a drop down form field",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "locations",
          "name"
        ],
        "type": "object"
      },
      "FormFieldConditionPredicate": {
        "description": "A predicate used to determine whether the condtion succeeds",
        "properties": {
          "fieldLocationIndex": {
            "description": "Index of the location of the form field used in the predicate",
            "type": "integer"
          },
          "fieldName": {
            "description": "Name of the field whose value is the basis of predicate",
            "type": "string"
          },
          "operator": {
            "description": "Operator to be applied on the value of the predicate field.",
            "enum": [
              "EQUALS",
              "NOT_EQUALS",
              "LESS_THAN",
              "LESS_THAN_EQUALS",
              "GREATER_THAN",
              "GREATER_THAN_EQUALS",
              "IN",
              "NOT_IN",
              "CONTAINS",
              "NOT_CONTAINS"
            ],
            "type": "string"
          },
          "value": {
            "description": "Value to compare against the value of the predicate's form field, using the specified operator",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FormFieldConditionalAction": {
        "description": "Conditional actions to perfom on this form field.",
        "properties": {
          "action": {
            "description": "Action to show/hide the form field is to be taken on the basis of evaluation of conditions.",
            "enum": [
              "SHOW",
              "HIDE",
              "DISABLE",
              "ENABLE"
            ],
            "type": "string"
          },
          "anyOrAll": {
            "description": "It indicates if any one of the conditions or all of them have to be true.",
            "enum": [
              "ALL",
              "ANY"
            ],
            "type": "string"
          },
          "predicates": {
            "description": "The predicates to be evaluated in order to determine whether this condition is true",
            "items": {
              "$ref": "#/components/schemas/FormFieldConditionPredicate"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FormFieldDescription": {
        "description": "The descriptive attributes of a form field.",
        "properties": {
          "alignment": {
            "description": "Alignment of the text.",
            "enum": [
              "LEFT",
              "RIGHT",
              "CENTER"
            ],
            "type": "string"
          },
          "backgroundColor": {
            "description": "Background color of the form field in RGB or HEX format",
            "type": "string"
          },
          "borderColor": {
            "description": "Color of the border of the field in RGB or HEX format",
            "type": "string"
          },
          "borderStyle": {
            "description": "Style of the border of the field.",
            "enum": [
              "SOLID",
              "DASHED",
              "BEVELED",
              "INSET",
              "UNDERLINE"
            ],
            "type": "string"
          },
          "borderWidth": {
            "description": "Width of the border of the field in default user space units",
            "format": "double",
            "type": "number"
          },
          "calculated": {
            "description": "true if this field's value is calculated from an expression, else false",
            "type": "boolean"
          },
          "conditionalAction": {
            "$ref": "#/components/schemas/FormFieldConditionalAction",
            "description": "A predicate (or set of predicates) that determines whether this field is visible and enabled.",
            "items": {
              "$ref": "#/components/schemas/FormFieldConditionalAction"
            }
          },
          "contentType": {
            "description": "Content Type of the form field.",
            "enum": [
              "DATA",
              "SIGNATURE_BLOCK",
              "SIGNATURE",
              "SIGNER_NAME",
              "SIGNER_FIRST_NAME",
              "SIGNER_LAST_NAME",
              "SIGNER_INITIALS",
              "SIGNER_EMAIL",
              "SIGNER_TITLE",
              "SIGNER_COMPANY",
              "SIGNATURE_DATE",
              "AGREEMENT_NAME",
              "AGREEMENT_MESSAGE",
              "TRANSACTION_ID",
              "SIGNATURE_STAMP",
              "PAYMENT",
              "DIGITAL_SIGNATURE",
              "CALC"
            ],
            "type": "string"
          },
          "currency": {
            "description": "A currency ISO code. Only applicable for payment form fields. Should be one of the currencies supported in the payment integration merchant accounts.",
            "type": "string"
          },
          "defaultValue": {
            "description": "Default value of the form field",
            "type": "string"
          },
          "displayFormat": {
            "description": "Format of the value of the field to be displayed based on the displayFormatType property.",
            "type": "string"
          },
          "displayFormatType": {
            "description": "Format type of the text field.",
            "enum": [
              "DEFAULT",
              "DATE",
              "NUMBER"
            ],
            "type": "string"
          },
          "displayLabel": {
            "description": "Display label attached to the field",
            "type": "string"
          },
          "fontColor": {
            "description": "Font color of the form field in RGB or HEX format",
            "type": "string"
          },
          "fontName": {
            "description": "Font name of the form field",
            "type": "string"
          },
          "fontSize": {
            "description": "Font size of the form field in points",
            "format": "double",
            "type": "number"
          },
          "hiddenOptions": {
            "description": "Text values which are hidden in a drop down form field",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "hyperlink": {
            "$ref": "#/components/schemas/FormFieldHyperlink",
            "description": "Hyperlink-specific data (e.g. as url, link type)",
            "items": {
              "$ref": "#/components/schemas/FormFieldHyperlink"
            }
          },
          "inputType": {
            "description": "Input type of the form field",
            "enum": [
              "TEXT_FIELD",
              "MULTILINE",
              "PASSWORD",
              "RADIO",
              "CHECKBOX",
              "DROP_DOWN",
              "LISTBOX",
              "SIGNATURE",
              "PDF_SIGNATURE",
              "BUTTON",
              "BLOCK",
              "FILE_CHOOSER",
              "COMB",
              "INLINE_IMAGE",
              "UNSUPPORTED"
            ],
            "type": "string"
          },
          "masked": {
            "description": "true if the input entered by the signer has to be masked (like password), false if it shouldn't be",
            "type": "boolean"
          },
          "maskingText": {
            "description": "Text to mask the masked form field",
            "type": "string"
          },
          "maxLength": {
            "description": "Maximum length of the input text field in terms of no. of characters",
            "type": "integer"
          },
          "maxValue": {
            "description": "Upper bound of the number that can be entered by the signer",
            "format": "double",
            "type": "number"
          },
          "minLength": {
            "description": "Minimum length of the input text field in terms of no. of characters",
            "type": "integer"
          },
          "minValue": {
            "description": "Lower bound of the number that can be entered by the signer",
            "format": "double",
            "type": "number"
          },
          "origin": {
            "description": "Origin of Form Field",
            "enum": [
              "AUTHORED",
              "GENERATED",
              "IMPORTED"
            ],
            "type": "string"
          },
          "radioCheckType": {
            "description": "The type of radio button (if field is radio button, identified by inputType).",
            "enum": [
              "CIRCLE",
              "CHECK",
              "CROSS",
              "DIAMOND",
              "SQUARE",
              "STAR"
            ],
            "type": "string"
          },
          "readOnly": {
            "description": "true if it is a read-only field, else false",
            "type": "boolean"
          },
          "required": {
            "description": "true if it is a mandatory field to be filled by the signer, else false",
            "type": "boolean"
          },
          "tooltip": {
            "description": "Tooltip text for the form field",
            "type": "string"
          },
          "urlOverridable": {
            "description": "For web form text fields only - true if the default value may come from the URL, else false",
            "type": "boolean"
          },
          "validation": {
            "description": "Rule for validating the field value.",
            "enum": [
              "NONE",
              "STRING",
              "NUMBER",
              "DATE",
              "DATE_CUSTOM",
              "TIME",
              "ZIP",
              "PHONE",
              "SOCIAL_SEC",
              "EMAIL",
              "CURRENCY",
              "PERCENT",
              "FORMULA",
              "CUSTOM",
              "XFA_PICTURE"
            ],
            "type": "string"
          },
          "validationData": {
            "description": "Further data for validating input with regards to the field's specified format. The contents and interpretation of formatData depends on the value of validation.",
            "type": "string"
          },
          "validationErrMsg": {
            "description": "Error message to be shown to the signer if filled value doesn't match the validations of the form field",
            "type": "string"
          },
          "valueExpression": {
            "description": "Expression to calculate value of the form field",
            "type": "string"
          },
          "visible": {
            "description": "If set to false, then the form field is hidden.  Otherwise, it is visible.",
            "type": "boolean"
          },
          "visibleOptions": {
            "description": "Text values which are visible in a drop down form field",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FormFieldGenerator": {
        "description": "Form Field Generator providing information for generating form fields relative to text in the content of the agreement documents",
        "properties": {
          "anchorTextInfo": {
            "$ref": "#/components/schemas/AnchorTextInfo",
            "description": "Anchored text and associated information used to generate form fields relative to",
            "items": {
              "$ref": "#/components/schemas/AnchorTextInfo"
            }
          },
          "formFieldDescription": {
            "$ref": "#/components/schemas/FormFieldDescription",
            "description": "The description of the form field to generate",
            "items": {
              "$ref": "#/components/schemas/FormFieldDescription"
            }
          },
          "formFieldNamePrefix": {
            "description": "The prefix name of each generated form field",
            "type": "string"
          },
          "generatorType": {
            "description": "The type of form field generator, default ANCHOR_TEXT",
            "enum": [
              "ANCHOR_TEXT"
            ],
            "type": "string"
          },
          "linked": {
            "description": "By default duplicate generated form fields will be linked as references unless linked is false in which case unique form fields will be created",
            "type": "boolean"
          },
          "participantSetName": {
            "description": "The name of the participant set to assign the generated form field with",
            "type": "string"
          }
        },
        "required": [
          "formFieldDescription",
          "formFieldNamePrefix",
          "generatorType",
          "participantSetName"
        ],
        "type": "object"
      },
      "FormFieldHyperlink": {
        "description": "Hyperlink-specific data for hyperlink form fields",
        "properties": {
          "documentLocation": {
            "$ref": "#/components/schemas/FormFieldLocation",
            "description": "Location on the document pointed by the link in case of INTERNAL type link",
            "items": {
              "$ref": "#/components/schemas/FormFieldLocation"
            }
          },
          "linkType": {
            "description": "Type of link in an agreement.",
            "enum": [
              "INTERNAL",
              "EXTERNAL",
              "FROM_TEXT"
            ],
            "type": "string"
          },
          "url": {
            "description": "URL, in case of EXTERNAL type link",
            "type": "string"
          }
        },
        "type": "object"
      },
      "FormFieldLocation": {
        "description": "Location information for form fields",
        "properties": {
          "height": {
            "description": "Height of the form field in default user space units",
            "format": "double",
            "type": "number"
          },
          "left": {
            "description": "No. of default user space units from left of the page for form field placement",
            "format": "double",
            "type": "number"
          },
          "pageNumber": {
            "description": "Number of the page where form field has to be placed, starting from 1.",
            "type": "integer"
          },
          "top": {
            "description": "No. of default user space units from bottom of the page for form field placement",
            "format": "double",
            "type": "number"
          },
          "width": {
            "description": "Width of the form field in default user space units",
            "format": "double",
            "type": "number"
          }
        },
        "required": [
          "height",
          "left",
          "pageNumber",
          "top",
          "width"
        ],
        "type": "object"
      },
      "FormFieldMergeInfo": {
        "description": "Data for updating the default values of existing form fields",
        "properties": {
          "fieldMergeInfos": {
            "description": "A mapping of field names to default values",
            "items": {
              "$ref": "#/components/schemas/MergefieldInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "FormFieldPostInfo": {
        "description": "Information required to add or update agreement form fields",
        "properties": {
          "templateId": {
            "description": "The ID of the template from which to add new fields",
            "type": "string"
          }
        },
        "required": [
          "templateId"
        ],
        "type": "object"
      },
      "FormFieldPutInfo": {
        "description": "Information required to add or replace agreement form fields",
        "properties": {
          "fields": {
            "description": "The list of fields to update or replace.",
            "items": {
              "$ref": "#/components/schemas/FormField"
            },
            "type": "array"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "MembersInfo": {
        "properties": {
          "ccsInfo": {
            "description": "Information of CC participants of the agreement.",
            "items": {
              "$ref": "#/components/schemas/CCParticipantInfo"
            },
            "type": "array"
          },
          "nextParticipantSets": {
            "description": "Information of next participant sets.",
            "items": {
              "$ref": "#/components/schemas/DetailedParticipantSetInfo"
            },
            "type": "array"
          },
          "participantSets": {
            "description": "Information about the participant Sets.",
            "items": {
              "$ref": "#/components/schemas/DetailedParticipantSetInfo"
            },
            "type": "array"
          },
          "senderInfo": {
            "$ref": "#/components/schemas/SenderInfo",
            "description": "Information of the sender of the agreement.",
            "items": {
              "$ref": "#/components/schemas/SenderInfo"
            }
          },
          "sharesInfo": {
            "description": "Information of the participants with whom the agreement has been shared.",
            "items": {
              "$ref": "#/components/schemas/ShareParticipantInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "ccsInfo",
          "nextParticipantSets",
          "participantSets",
          "senderInfo",
          "sharesInfo"
        ],
        "type": "object"
      },
      "MergefieldInfo": {
        "properties": {
          "defaultValue": {
            "description": "The default value of the field",
            "type": "string"
          },
          "fieldName": {
            "description": "The name of the field",
            "type": "string"
          }
        },
        "required": [
          "defaultValue",
          "fieldName"
        ],
        "type": "object"
      },
      "MyAgreementInfo": {
        "properties": {
          "accountSharers": {
            "description": "A list of account sharer in relation to the api caller and this resource.",
            "items": {
              "$ref": "#/components/schemas/AccountSharerInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "accountSharers"
        ],
        "type": "object"
      },
      "NameInfo": {
        "properties": {
          "firstName": {
            "description": "Recipient's first name",
            "type": "string"
          },
          "lastName": {
            "description": "Recipient's last name",
            "type": "string"
          }
        },
        "type": "object"
      },
      "NewSenderInfo": {
        "description": "Information of the new sender of the agreement.",
        "properties": {
          "senderId": {
            "description": "The unique identifier of the new sender.",
            "type": "string"
          }
        },
        "required": [
          "senderId"
        ],
        "type": "object"
      },
      "NotaryInfo": {
        "description": "Additional information for agreements that require notarization",
        "properties": {
          "appointment": {
            "description": "A proposed appointment time specified using the yyyy-MM-dd'T'HH:mm:ssZ format.",
            "type": "string"
          },
          "notaryEmail": {
            "description": "Email address of provided notary when the notaryType is BYON_NOTARY",
            "type": "string"
          },
          "notaryType": {
            "description": "PROVIDER_NOTARY: Notary is provided by the notary provider\nBYON_NOTARY: In house Notary is provided by the customer",
            "enum": [
              "PROVIDER_NOTARY",
              "BYON_NOTARY"
            ],
            "type": "string"
          },
          "note": {
            "description": "Notes for the notary session.",
            "type": "string"
          },
          "payment": {
            "description": "BY_SENDER: When the notarization provider provides the notary and the notary fee will be paid by the sender\nBY_SIGNER: When the notarization provider provides the notary and the notary fee will be paid by the signer",
            "enum": [
              "BY_SENDER",
              "BY_SIGNER"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "Note": {
        "properties": {
          "note": {
            "description": "Content of Note field",
            "type": "string"
          }
        },
        "required": [
          "note"
        ],
        "type": "object"
      },
      "OfflineDeviceInfo": {
        "properties": {
          "applicationDescription": {
            "description": "Application Description",
            "type": "string"
          },
          "deviceDescription": {
            "description": "Device Description",
            "type": "string"
          },
          "deviceTime": {
            "description": "The device local time. The device time provided should not be before 30 days of current date.Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time, while 2016-02-25T13:46:19-05:00 represents the same time in EST",
            "format": "date",
            "type": "string"
          }
        },
        "required": [
          "applicationDescription",
          "deviceDescription"
        ],
        "type": "object"
      },
      "PageImageUrl": {
        "properties": {
          "pageNumber": {
            "description": "Page number within the document.",
            "type": "integer"
          },
          "url": {
            "description": "An image url.",
            "type": "string"
          }
        },
        "required": [
          "pageNumber",
          "url"
        ],
        "type": "object"
      },
      "ParticipantSecurityOption": {
        "properties": {
          "authenticationMethod": {
            "description": "The authentication method for the participants to have access to view and sign the document. When replacing a participant that has PASSWORD or PHONE authentication specified, you must supply a password or phone number for the new participant, and you cannot change the authentication method",
            "enum": [
              "NONE",
              "PASSWORD",
              "PHONE",
              "KBA",
              "WEB_IDENTITY",
              "ADOBE_SIGN",
              "GOV_ID",
              "DIG_ID"
            ],
            "type": "string"
          },
          "digAuthInfo": {
            "$ref": "#/components/schemas/DigAuthInfo",
            "description": "Digital Identity Gateway Provider information.",
            "items": {
              "$ref": "#/components/schemas/DigAuthInfo"
            }
          },
          "nameInfo": {
            "$ref": "#/components/schemas/NameInfo",
            "description": "Recipient's full name",
            "items": {
              "$ref": "#/components/schemas/NameInfo"
            }
          },
          "notaryAuthentication": {
            "description": "The authentication method of the notary participant to the notary",
            "enum": [
              "MULTI_FACTOR_AUTHENTICATION",
              "NONE"
            ],
            "type": "string"
          },
          "password": {
            "description": "The password required for the participant to view and sign the document. Note that Acrobat Sign will never show this password to anyone, so you will need to separately communicate it to any relevant parties. The password will not be returned in GET call. When replacing a participant that has PASSWORD authentication specified, you must supply a password for the new participant.",
            "type": "string"
          },
          "phoneInfo": {
            "$ref": "#/components/schemas/PhoneInfo",
            "description": "The phoneInfo required for the participant to view and sign the document",
            "items": {
              "$ref": "#/components/schemas/PhoneInfo"
            }
          }
        },
        "required": [
          "authenticationMethod"
        ],
        "type": "object"
      },
      "ParticipantSetInfo": {
        "properties": {
          "electronicSealId": {
            "description": "ID of the sealing credential, which can be obtained through <b>GET /autoseals</b> call.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the participant. This will be ignored as part of POST or PUT calls. The Id might be null in draft state",
            "type": "string"
          },
          "label": {
            "description": "The unique label of a participant set.<br>For custom workflows, label specified in the participation set should map it to the participation step in the custom workflow.",
            "type": "string"
          },
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set. Required, unless ParticipantSet has the ELECTRONIC_SEALER role",
            "items": {
              "$ref": "#/components/schemas/ParticipantSetMemberInfo"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of the participant set (it can be empty, but if present it must be unique within a single agreement). Maximum no of characters in participant set name is restricted to 255",
            "type": "string"
          },
          "order": {
            "description": "Index indicating position at which signing group needs to sign. Signing group to sign at first place is assigned a 1 index. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signingOrder will be considered invalid.",
            "type": "integer"
          },
          "privateMessage": {
            "description": "Participant set's private message - all participants in the set will receive the same message",
            "type": "string"
          },
          "role": {
            "description": "Role assumed by all participants in the set (signer, approver etc.)",
            "enum": [
              "SIGNER",
              "APPROVER",
              "ACCEPTOR",
              "CERTIFIED_RECIPIENT",
              "FORM_FILLER",
              "DELEGATE_TO_SIGNER",
              "DELEGATE_TO_APPROVER",
              "DELEGATE_TO_ACCEPTOR",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "DELEGATE_TO_FORM_FILLER",
              "NOTARY_SIGNER",
              "ELECTRONIC_SEALER"
            ],
            "type": "string"
          },
          "visiblePages": {
            "description": "When you enable limited document visibility (documentVisibilityEnabled), you can specify which file (fileInfo) should be made visible to which specific participant set.<br>Specify one or more label values of a fileInfos element.<br>Each signer participant sets must contain at least one required signature field in at least one visible file included in this API call; if not a page with a signature field is automatically appended for any missing participant sets. If there is a possibility that one or more participant sets do not have a required signature field in the files included in the API call, all signer participant sets should include a special index value of '0' to make this automatically appended signature page visible to the signer. Not doing so may result in an error. For all other roles, you may omit this value to exclude this page.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "order",
          "role"
        ],
        "type": "object"
      },
      "ParticipantSetMemberInfo": {
        "properties": {
          "email": {
            "description": "Email of the participant. In case of creating new Agreements(POST/PUT), this is a required field.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the participant. This will be ignored as part of POST or PUT calls. The Id might be null in draft state",
            "type": "string"
          },
          "name": {
            "description": "Recipient's full name",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/ParticipantSecurityOption",
            "description": "Security options that apply to the participant",
            "items": {
              "$ref": "#/components/schemas/ParticipantSecurityOption"
            }
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "PhoneInfo": {
        "properties": {
          "countryCode": {
            "description": "The numeric country calling code (ISD code) required for the participant to view and sign the document if authentication type is PHONE",
            "type": "string"
          },
          "countryIsoCode": {
            "description": "The country ISO Alpha-2 code required for the participant to view and sign the document if authentication method is PHONE",
            "type": "string"
          },
          "phone": {
            "description": "The phone number required for the participant to view and sign the document if authentication method is PHONE. When replacing a participant that has PHONE authentication specified, you must supply a phone number for the new participant.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PostSendOption": {
        "properties": {
          "redirectUrl": {
            "description": "URL to redirect to after completion of the SEND flow. Specified URL must be part of the allow list for application redirects, configured by a CSR Admin",
            "type": "string"
          }
        },
        "type": "object"
      },
      "PostSignOption": {
        "properties": {
          "redirectDelay": {
            "description": "The delay (in seconds) before the user is taken to the success page. If this value is greater than 0, the user will first see the standard Acrobat Sign success message, and then after a delay will be redirected to your success page",
            "type": "integer"
          },
          "redirectUrl": {
            "description": "A publicly accessible url to which the user will be sent after successfully completing the signing process",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ReminderCreationResult": {
        "properties": {
          "id": {
            "description": "An identifier of the reminder resource created on the server. If provided in POST or PUT, it will be ignored",
            "type": "string"
          }
        },
        "type": "object"
      },
      "ReminderInfo": {
        "properties": {
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Cannot be updated in a PUT",
            "type": "integer"
          },
          "frequency": {
            "description": "The frequency at which reminder will be sent until the agreement is completed.<br>If frequency is not provided, the reminder will be sent once (if the agreement is available at the specified time) with the delay based on the firstReminderDelay field and will never repeat again. If the agreement is not available at that time, reminder will not be sent. Cannot be updated in a PUT",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED",
              "ONCE"
            ],
            "type": "string"
          },
          "lastSentDate": {
            "description": "The date when the reminder was last sent. Only provided in GET. Cannot be provided in POST request. If provided in POST, it will be ignored. Cannot be updated in a PUT. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "nextSentDate": {
            "description": "The date when the reminder is scheduled to be sent next. When provided in POST request, frequency needs to be ONCE (or not specified), startReminderCounterFrom needs to be REMINDER_CREATION (or not specified) and firstReminderDelay needs to be 0 (or not specified). Cannot be updated in a PUT. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "note": {
            "description": "An optional message sent to the recipients, describing why their participation is required",
            "type": "string"
          },
          "recipientParticipantIds": {
            "description": "A list of one or more participant IDs that the reminder should be sent to. These must be recipients of the agreement and not sharees or cc's.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "reminderId": {
            "description": "An identifier of the reminder resource created on the server. If provided in POST or PUT, it will be ignored",
            "type": "string"
          },
          "startReminderCounterFrom": {
            "description": "Reminder can be sent based on when the agreement becomes available or when the reminder is created<br>AGREEMENT_AVAILABILITY: If the agreement is not available to the participant at the time of reminder creation, the reminder will be sent for the first time, only when the agreement becomes available to the participant taking the firstReminderDelay into account. Subsequent reminders will be sent based on the frequency specified.  If the agreement is already available to the participant at the time of reminder creation, the first reminder will be sent after the delay specified by firstReminderDelay from the reminder creation time.<br>REMINDER_CREATION: The first reminder will be sent after the delay specified by firstReminderDelay from the reminder creation time only if the agreement is available at that time. Subsequent reminders will be triggered based on the frequency specified and will be sent only if the agreement is available at that time.  For agreements in authoring state, creating reminder with startReminderCounterFrom as REMINDER_CREATION is not allowed.<br>Note : If firstReminderDelay, frequency and startReminderCounterFrom fields are not specified in POST, reminder will be sent right now if the agreement is available. If agreement is not available, an error will be thrown.  Cannot be updated in a PUT",
            "enum": [
              "AGREEMENT_AVAILABILITY",
              "REMINDER_CREATION"
            ],
            "type": "string"
          },
          "status": {
            "description": "Current status of the reminder.  The only valid update in a PUT is from ACTIVE to CANCELED.  Must be provided as ACTIVE in a POST.",
            "enum": [
              "ACTIVE",
              "CANCELED",
              "COMPLETE"
            ],
            "type": "string"
          }
        },
        "required": [
          "recipientParticipantIds",
          "status"
        ],
        "type": "object"
      },
      "ReminderParticipant": {
        "properties": {
          "email": {
            "description": "The email address of the participant",
            "type": "string"
          },
          "name": {
            "description": "The full name of the participant",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the participant",
            "type": "string"
          }
        },
        "required": [
          "email",
          "participantId"
        ],
        "type": "object"
      },
      "RemindersResponse": {
        "properties": {
          "reminderInfoList": {
            "description": "A list of one or more reminders created on the agreement specified by the unique identifier agreementId by the user invoking the API.",
            "items": {
              "$ref": "#/components/schemas/ReminderInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "reminderInfoList"
        ],
        "type": "object"
      },
      "SecurityOption": {
        "properties": {
          "openPassword": {
            "description": "The secondary password that will be used to secure the PDF document. Note that Acrobat Sign will never show this password to anyone, so you will need to separately communicate it to any relevant parties",
            "type": "string"
          }
        },
        "type": "object"
      },
      "SendOptions": {
        "properties": {
          "completionEmails": {
            "description": "Control notification mails for agreement completion events - COMPLETED, CANCELLED, EXPIRED and REJECTED",
            "enum": [
              "ALL",
              "NONE"
            ],
            "type": "string"
          },
          "inFlightEmails": {
            "description": "Control notification mails for agreement-in-process events - DELEGATED, REPLACED",
            "enum": [
              "ALL",
              "NONE"
            ],
            "type": "string"
          },
          "initEmails": {
            "description": "Control notification mails for Agreement initiation events - ACTION_REQUESTED and CREATED",
            "enum": [
              "ALL",
              "NONE"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "SenderInfo": {
        "properties": {
          "company": {
            "description": "Company of the sender, if available.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the sender was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the sender of the agreement.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the agreement is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the sender, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the sender of the agreement.",
            "type": "string"
          },
          "self": {
            "description": "True if the sender is the same user that is calling the API.",
            "type": "boolean"
          },
          "status": {
            "description": "The agreement status with respect to the participant set. This cannot be changed as part of the PUT call.",
            "enum": [
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "NOT_YET_VISIBLE",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_NOTARIZATION",
              "WAITING_FOR_OTHERS"
            ],
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the sender. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self",
          "status"
        ],
        "type": "object"
      },
      "ShareCreationInfo": {
        "properties": {
          "email": {
            "description": "The email address of the member with whom the agreement will be shared",
            "type": "string"
          },
          "message": {
            "description": "Optional message to the sharee",
            "type": "string"
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "ShareCreationInfoList": {
        "properties": {
          "shareCreationInfo": {
            "description": "List of ShareCreationInfo",
            "items": {
              "$ref": "#/components/schemas/ShareCreationInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "shareCreationInfo"
        ],
        "type": "object"
      },
      "ShareCreationResponse": {
        "properties": {
          "email": {
            "description": "The email address that was requested",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the participant",
            "type": "string"
          }
        },
        "required": [
          "email",
          "participantId"
        ],
        "type": "object"
      },
      "ShareCreationResponseList": {
        "properties": {
          "shareCreationResponseList": {
            "description": "List of ShareCreationResponse",
            "items": {
              "$ref": "#/components/schemas/ShareCreationResponse"
            },
            "type": "array"
          }
        },
        "required": [
          "shareCreationResponseList"
        ],
        "type": "object"
      },
      "ShareParticipantInfo": {
        "properties": {
          "company": {
            "description": "Company of the sharee participant, if available.",
            "type": "string"
          },
          "email": {
            "description": "Email of the sharee participant of the agreement.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the agreement is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the sharee participant, if available.",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the sharee participant of the agreement.",
            "type": "string"
          },
          "self": {
            "description": "True if the Share participant is the same user that is calling the API.",
            "type": "boolean"
          },
          "sharerParticipantId": {
            "description": "The unique identifier of the participant who shared the agreement.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self",
          "sharerParticipantId"
        ],
        "type": "object"
      },
      "SignerIdentityReportInfo": {
        "properties": {
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Optional secondary security parameters for the signer identity report.",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          }
        },
        "type": "object"
      },
      "SigningUrl": {
        "properties": {
          "email": {
            "description": "The email address of the signer associated with this signing url",
            "type": "string"
          },
          "esignUrl": {
            "description": "The email address of the signer associated with this signing url",
            "type": "string"
          }
        },
        "required": [
          "email",
          "esignUrl"
        ],
        "type": "object"
      },
      "SigningUrlResponse": {
        "properties": {
          "signingUrlSetInfos": {
            "description": "An array of urls for signer sets involved in this agreement.",
            "items": {
              "$ref": "#/components/schemas/SigningUrlSetInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "signingUrlSetInfos"
        ],
        "type": "object"
      },
      "SigningUrlSetInfo": {
        "properties": {
          "signingUrlSetName": {
            "description": "The name of the current signer set. Returned only, if the API caller is the sender of agreement",
            "type": "string"
          },
          "signingUrls": {
            "description": "An array of urls for current signer set.",
            "items": {
              "$ref": "#/components/schemas/SigningUrl"
            },
            "type": "array"
          }
        },
        "required": [
          "signingUrls"
        ],
        "type": "object"
      },
      "SupportingDocument": {
        "properties": {
          "displayLabel": {
            "description": "Display name of the document",
            "type": "string"
          },
          "fieldName": {
            "description": "The name of the supporting document field",
            "type": "string"
          },
          "id": {
            "description": "Id representing the document",
            "type": "string"
          },
          "mimeType": {
            "description": "Mime-type of the document",
            "type": "string"
          },
          "numPages": {
            "description": "Number of pages in the document",
            "type": "integer"
          },
          "participantId": {
            "description": "The unique identifier of the participant that uploaded the supporting document",
            "type": "string"
          }
        },
        "required": [
          "displayLabel",
          "fieldName",
          "id",
          "mimeType",
          "numPages",
          "participantId"
        ],
        "type": "object"
      },
      "URLFileInfo": {
        "properties": {
          "mimeType": {
            "description": "The mime type of the referenced file, used to determine if the file can be accepted and the necessary conversion steps can be performed",
            "type": "string"
          },
          "name": {
            "description": "The original system file name of the document being sent",
            "type": "string"
          },
          "url": {
            "description": "A publicly accessible URL for retrieving the raw file content",
            "type": "string"
          }
        },
        "required": [
          "mimeType",
          "name",
          "url"
        ],
        "type": "object"
      },
      "UserAgreement": {
        "properties": {
          "displayDate": {
            "description": "The display date for the agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "displayParticipantSetInfos": {
            "description": "The most relevant current user set for the agreement. It is typically the next signer if the agreement is from the current user, or the sender if received from another user",
            "items": {
              "$ref": "#/components/schemas/DisplayParticipantSetInfo"
            },
            "type": "array"
          },
          "esign": {
            "description": "True if this is an e-sign document",
            "type": "boolean"
          },
          "groupId": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "hidden": {
            "description": "True if agreement is hidden for the user",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement.If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "latestVersionId": {
            "description": "A version ID which uniquely identifies the current version of the agreement",
            "type": "string"
          },
          "name": {
            "description": "Name of the Agreement",
            "type": "string"
          },
          "parentId": {
            "description": "The parent id of a bulk send child *OR* the originating id of a web form agreement instance",
            "type": "string"
          },
          "status": {
            "description": "This is a server generated attribute which provides the detailed status of an agreement with respect to the apiCaller",
            "enum": [
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_NOTARIZATION",
              "OUT_FOR_SIGNATURE",
              "OUT_FOR_APPROVAL",
              "OUT_FOR_DELIVERY",
              "OUT_FOR_ACCEPTANCE",
              "OUT_FOR_FORM_FILLING",
              "SIGNED",
              "APPROVED",
              "FORM_FILLED",
              "DELIVERED",
              "ACCEPTED",
              "ARCHIVED",
              "CANCELLED",
              "EXPIRED",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_PREFILL",
              "DRAFT",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "WAITING_FOR_MY_VERIFICATION",
              "WAITING_FOR_VERIFICATION"
            ],
            "type": "string"
          },
          "type": {
            "description": "The kind of agreement",
            "enum": [
              "AGREEMENT",
              "MEGASIGN_CHILD",
              "WIDGET_INSTANCE"
            ],
            "type": "string"
          }
        },
        "required": [
          "displayDate",
          "displayParticipantSetInfos",
          "esign",
          "groupId",
          "hidden",
          "latestVersionId",
          "name"
        ],
        "type": "object"
      },
      "UserAgreements": {
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userAgreementList": {
            "description": "An array of UserAgreement items",
            "items": {
              "$ref": "#/components/schemas/UserAgreement"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userAgreementList"
        ],
        "type": "object"
      },
      "VaultEventInfo": {
        "properties": {
          "vaultEventComment": {
            "description": "The description provided by the vault provider for the vault event",
            "type": "string"
          },
          "vaultEventId": {
            "description": "The identifier assigned by the vault provider for the vault event",
            "type": "string"
          }
        },
        "required": [
          "vaultEventId"
        ],
        "type": "object"
      },
      "VaultingInfo": {
        "properties": {
          "enabled": {
            "description": "For accounts set up for document vaulting and the option to enable per agreement, this determines whether the document is to be vaulted",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "VisibilityInfo": {
        "properties": {
          "visibility": {
            "description": "Specifies the visibility. The possible values are HIDE or SHOW",
            "enum": [
              "SHOW",
              "HIDE"
            ],
            "type": "string"
          }
        },
        "required": [
          "visibility"
        ],
        "type": "object"
      },
      "BaseUriInfo": {
        "properties": {
          "apiAccessPoint": {
            "description": "The access point from where other APIs need to be accessed. In case other APIs are accessed from a different end point, it will be considered an invalid request",
            "type": "string"
          },
          "webAccessPoint": {
            "description": "The access point from where Acrobat Sign website can be be accessed",
            "type": "string"
          }
        },
        "required": [
          "apiAccessPoint",
          "webAccessPoint"
        ],
        "type": "object"
      },
      "DetailedGroupInfo": {
        "properties": {
          "created": {
            "description": "Date of creation of the group. This will be ignored as part of POST or PUT calls. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the Group. This will be returned as part of GET call but is not mandatory to be passed as part of PUT/POST call for groups/{groupId}",
            "type": "string"
          },
          "isDefaultGroup": {
            "description": "Is the default group for the account",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the group",
            "type": "string"
          }
        },
        "required": [
          "created",
          "name"
        ],
        "type": "object"
      },
      "GroupCreationResponse": {
        "description": "A JSON  that contains  id of the newly created group.",
        "properties": {
          "id": {
            "description": "Unique identifier of the group created.",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "GroupEvent": {
        "description": "A JSON of one group event, null",
        "properties": {
          "accountId": {
            "description": "Identifier of the account. This is a server generated attributed and can not be provided in POST/PUT calls. ",
            "type": "string"
          },
          "adminUserId": {
            "description": "Account admin user ID",
            "type": "string"
          },
          "date": {
            "description": "The date of the group event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "event": {
            "description": "Type of group event",
            "enum": [
              "CREATED",
              "DELETED",
              "RENAMED",
              "SHARE_REQUESTED",
              "SHARE_ACCEPTED",
              "SHARE_DECLINED",
              "SHARE_CANCELLED",
              "SHARE_REQUEST_RESENT",
              "SHARE_MODIFIED"
            ],
            "type": "string"
          },
          "groupEventId": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "groupId": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the signing participant.",
            "type": "string"
          }
        },
        "required": [
          "adminUserId",
          "date",
          "groupId",
          "userId"
        ],
        "type": "object"
      },
      "GroupEventsList": {
        "description": "A JSON list of all group events",
        "properties": {
          "groupEvents": {
            "description": "List of group events",
            "items": {
              "$ref": "#/components/schemas/GroupEvent"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "groupEvents",
          "page"
        ],
        "type": "object"
      },
      "GroupInfo": {
        "properties": {
          "createdDate": {
            "description": "Date group was created",
            "format": "date",
            "type": "string"
          },
          "groupId": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "groupName": {
            "description": "Name of the group",
            "type": "string"
          },
          "isDefaultGroup": {
            "description": "Is the default group for the account",
            "type": "boolean"
          }
        },
        "required": [
          "groupId",
          "groupName"
        ],
        "type": "object"
      },
      "GroupUserInfo": {
        "properties": {
          "company": {
            "description": "The name of company of the user",
            "type": "string"
          },
          "email": {
            "description": "The email address of the user",
            "type": "string"
          },
          "firstName": {
            "description": "The first name of the user",
            "type": "string"
          },
          "id": {
            "description": "A unique identifier of the user resource for REST APIs. This identifier can not be used in SOAP APIs",
            "type": "string"
          },
          "isGroupAdmin": {
            "description": "True if user is group admin",
            "type": "boolean"
          },
          "lastName": {
            "description": "The last name of the user",
            "type": "string"
          }
        },
        "required": [
          "email",
          "id",
          "isGroupAdmin"
        ],
        "type": "object"
      },
      "GroupUsersInfo": {
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userInfoList": {
            "description": "The list of users in the account.",
            "items": {
              "$ref": "#/components/schemas/GroupUserInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userInfoList"
        ],
        "type": "object"
      },
      "GroupsInfo": {
        "properties": {
          "groupInfoList": {
            "description": "The list of groups in the account.",
            "items": {
              "$ref": "#/components/schemas/GroupInfo"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "groupInfoList",
          "page"
        ],
        "type": "object"
      },
      "CommonViewConfiguration": {
        "properties": {
          "autoLoginUser": {
            "description": "Auto LogIn Flag. If true, the URL returned will automatically log the user in. If false, the URL returned will require the credentials. By default its value is false",
            "type": "boolean"
          },
          "frameParent": {
            "description": "An optional field to provide the comma-separated list of parent domain urls where the returned URLs may be iframed. If provided with non-empty and valid list of parent domain urls, it will be used to allow framing for the same. By default the value is null and the Acrobat Sign pages will not be viewable in an iframe.",
            "type": "string"
          },
          "locale": {
            "description": "Message template locale",
            "type": "string"
          },
          "noChrome": {
            "description": "No Chrome Flag. If true, the embedded page is shown without a navigation header or footer. If false, the standard page header and footer will be present. By default its value is false",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "Documents": {
        "properties": {
          "documents": {
            "description": "A list of documents",
            "items": {
              "$ref": "#/components/schemas/Document"
            },
            "type": "array"
          }
        },
        "required": [
          "documents"
        ],
        "type": "object"
      },
      "FileInfo1": {
        "properties": {
          "notarize": {
            "description": "Indicates that this document needs to be notarized",
            "type": "boolean"
          },
          "transientDocumentId": {
            "description": "ID for a transient document that will be added to the library document",
            "type": "string"
          },
          "urlFileInfo": {
            "$ref": "#/components/schemas/URLFileInfo",
            "description": "URL for an external document to add to the library document",
            "items": {
              "$ref": "#/components/schemas/URLFileInfo"
            }
          }
        },
        "type": "object"
      },
      "LibDocEventDeviceLocation": {
        "properties": {
          "latitude": {
            "description": "Latitude coordinate",
            "format": "float",
            "type": "number"
          },
          "longitude": {
            "description": "Longitude coordinate",
            "format": "float",
            "type": "number"
          }
        },
        "required": [
          "latitude",
          "longitude"
        ],
        "type": "object"
      },
      "LibraryDocument": {
        "properties": {
          "creatorEmail": {
            "description": "Email address of the library document creator. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the library template belongs to. If not provided during creation, primary group of the creator will be used",
            "type": "string"
          },
          "hidden": {
            "description": "True if Library Document is hidden",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier that is used to refer to the library template",
            "type": "string"
          },
          "modifiedDate": {
            "description": "The date on which the library document was last modified. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the library document",
            "type": "string"
          },
          "ownerEmail": {
            "description": "Email address of the library document owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "sharingMode": {
            "description": "Specifies who should have access to this library document. GLOBAL sharing is a restricted operation.",
            "enum": [
              "USER",
              "GROUP",
              "ACCOUNT",
              "GLOBAL"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the library document",
            "enum": [
              "AUTHORING",
              "ACTIVE",
              "REMOVED"
            ],
            "type": "string"
          },
          "templateTypes": {
            "description": "A list of one or more library template types",
            "items": {
              "enum": [
                "DOCUMENT",
                "FORM_FIELD_LAYER"
              ],
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "hidden",
          "id",
          "modifiedDate",
          "name",
          "sharingMode",
          "templateTypes"
        ],
        "type": "object"
      },
      "LibraryDocumentCreationInfoV6": {
        "properties": {
          "createdDate": {
            "description": "Date when library document was created. It will be ignored in POST/PUT requests. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "creatorEmail": {
            "description": "Email address of the library document creator. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "creatorName": {
            "description": "Name of the library document creator.  It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be used to create the template. If more than one file is provided, they will be combined into one PDF. Note: Only a single parameter in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo1"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the library template belongs to. If not provided during creation, primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier that is used to refer to the library template. It will be ignored in POST requests",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this library document",
            "format": "date",
            "type": "string"
          },
          "modifiedDate": {
            "description": "Date when library document was last modified. It will be ignored in POST/PUT requests. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the library template that will be used to identify it, in emails and on the website",
            "type": "string"
          },
          "ownerEmail": {
            "description": "Email address of the library document owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "ownerId": {
            "description": "The unique identifier of the library document owner. It will be ignored in POST requests",
            "type": "string"
          },
          "ownerName": {
            "description": "Name of the library document owner.  It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "sharingMode": {
            "description": "Specifies who should have access to this library document. GLOBAL sharing is a restricted operation.",
            "enum": [
              "USER",
              "GROUP",
              "ACCOUNT",
              "GLOBAL"
            ],
            "type": "string"
          },
          "state": {
            "description": "State of the library document.",
            "enum": [
              "AUTHORING",
              "ACTIVE"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the library document",
            "enum": [
              "AUTHORING",
              "ACTIVE",
              "REMOVED"
            ],
            "type": "string"
          },
          "templateTypes": {
            "description": "A list of one or more library template types",
            "items": {
              "enum": [
                "DOCUMENT",
                "FORM_FIELD_LAYER"
              ],
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "fileInfos",
          "name",
          "sharingMode",
          "state",
          "templateTypes"
        ],
        "type": "object"
      },
      "LibraryDocumentCreationResponse": {
        "description": "A JSON object describing the library template",
        "properties": {
          "id": {
            "description": "The unique identifier that is used to refer to the library template",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "LibraryDocumentEvent": {
        "properties": {
          "actingUserEmail": {
            "description": "Email address of the user that created the event",
            "type": "string"
          },
          "actingUserIpAddress": {
            "description": "The IP address of the user that created the event",
            "type": "string"
          },
          "actingUserName": {
            "description": "The name of the acting user",
            "type": "string"
          },
          "comment": {
            "description": "The event comment. For RECALLED or REJECTED, the reason given by the user that initiates the event. For DELEGATE or SHARE, the message from the acting user to the participant",
            "type": "string"
          },
          "date": {
            "description": "The date of the audit event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "description": {
            "description": "A description of the audit event",
            "type": "string"
          },
          "device": {
            "description": "The device used for the event.",
            "type": "string"
          },
          "deviceLocation": {
            "$ref": "#/components/schemas/LibDocEventDeviceLocation",
            "description": "Location of the device that generated the event (This value may be null due to limited privileges)",
            "items": {
              "$ref": "#/components/schemas/LibDocEventDeviceLocation"
            }
          },
          "devicePhoneNumber": {
            "description": "Phone number from the device used when the participation is completed on a mobile phone",
            "type": "string"
          },
          "digitalSignatureInfo": {
            "$ref": "#/components/schemas/DigitalSignatureInfo",
            "description": "This is present for ESIGNED events when the participation is signed digitally",
            "items": {
              "$ref": "#/components/schemas/DigitalSignatureInfo"
            }
          },
          "id": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "initiatingUserEmail": {
            "description": "Email address of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "initiatingUserName": {
            "description": "Full name of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "participantEmail": {
            "description": "Email address of the user that is the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantRole": {
            "description": "Role assumed by all participants in the participant set the participant belongs to (signer, approver etc.).",
            "enum": [
              "SIGNER",
              "DELEGATE_TO_SIGNER",
              "APPROVER",
              "DELEGATE_TO_APPROVER",
              "ACCEPTOR",
              "DELEGATE_TO_ACCEPTOR",
              "FORM_FILLER",
              "DELEGATE_TO_FORM_FILLER",
              "CERTIFIED_RECIPIENT",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "SHARE",
              "RESOURCE_SHARE",
              "SENDER",
              "NOTARY_SIGNER"
            ],
            "type": "string"
          },
          "reminderParticipants": {
            "description": "A list of one or more participants who received the reminders",
            "items": {
              "$ref": "#/components/schemas/ReminderParticipant"
            },
            "type": "array"
          },
          "replacedParticipantEmail": {
            "description": "Email of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "replacedParticipantName": {
            "description": "Full name of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "signerNewName": {
            "description": "Signer changed name at signing : new name used to sign.",
            "type": "string"
          },
          "signerOldName": {
            "description": "Signer changed name at signing : name used previous to signing.",
            "type": "string"
          },
          "signingReason": {
            "description": "Signing reason captured during ESIGN or DIGSIGN",
            "type": "string"
          },
          "synchronizationId": {
            "description": "A unique identifier linking offline events to synchronization events (specified for offline signing events and synchronization events, else null)",
            "type": "string"
          },
          "type": {
            "description": "Type of library document event",
            "enum": [
              "AUTO_CANCELLED_CONVERSION_PROBLEM",
              "CREATED",
              "MODIFIED",
              "DOCUMENTS_DELETED",
              "OWNER_CHANGED"
            ],
            "type": "string"
          },
          "vaultEventId": {
            "description": "The identifier assigned by the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "vaultProviderName": {
            "description": "Name of the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "versionId": {
            "description": "An ID which uniquely identifies the version of the document associated with this audit event",
            "type": "string"
          }
        },
        "required": [
          "actingUserEmail",
          "actingUserIpAddress",
          "actingUserName",
          "date",
          "description",
          "device",
          "deviceLocation",
          "devicePhoneNumber",
          "digitalSignatureInfo",
          "initiatingUserEmail",
          "initiatingUserName",
          "participantEmail",
          "participantId",
          "participantRole",
          "synchronizationId",
          "type",
          "vaultEventId",
          "vaultProviderName",
          "versionId"
        ],
        "type": "object"
      },
      "LibraryDocumentEventList": {
        "properties": {
          "events": {
            "description": "An array of event objects.",
            "items": {
              "$ref": "#/components/schemas/LibraryDocumentEvent"
            },
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "type": "object"
      },
      "LibraryDocumentFormFields": {
        "description": "A JSON list of all of the fields for a form",
        "properties": {
          "fields": {
            "description": "List of the form fields in an agreement",
            "items": {
              "$ref": "#/components/schemas/FormField"
            },
            "type": "array"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "LibraryDocumentInfo": {
        "properties": {
          "createdDate": {
            "description": "Date when library document was created. It will be ignored in POST/PUT requests. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "creatorEmail": {
            "description": "Email address of the library document creator. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "creatorName": {
            "description": "Name of the library document creator.  It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be used to create the template. If more than one file is provided, they will be combined into one PDF. Note: Only a single parameter in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo1"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the library template belongs to. If not provided during creation, primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier that is used to refer to the library template. It will be ignored in POST requests",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this library document",
            "format": "date",
            "type": "string"
          },
          "modifiedDate": {
            "description": "Date when library document was last modified. It will be ignored in POST/PUT requests. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the library template that will be used to identify it, in emails and on the website",
            "type": "string"
          },
          "ownerEmail": {
            "description": "Email address of the library document owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "ownerId": {
            "description": "The unique identifier of the library document owner. It will be ignored in POST requests",
            "type": "string"
          },
          "ownerName": {
            "description": "Name of the library document owner.  It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "sharingMode": {
            "description": "Specifies who should have access to this library document. GLOBAL sharing is a restricted operation.",
            "enum": [
              "USER",
              "GROUP",
              "ACCOUNT",
              "GLOBAL"
            ],
            "type": "string"
          },
          "state": {
            "description": "State of the library document.",
            "enum": [
              "AUTHORING",
              "ACTIVE"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the library document",
            "enum": [
              "AUTHORING",
              "ACTIVE",
              "REMOVED"
            ],
            "type": "string"
          },
          "templateTypes": {
            "description": "A list of one or more library template types",
            "items": {
              "enum": [
                "DOCUMENT",
                "FORM_FIELD_LAYER"
              ],
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "fileInfos",
          "name",
          "sharingMode",
          "status",
          "templateTypes"
        ],
        "type": "object"
      },
      "LibraryDocumentMembersInfo": {
        "properties": {
          "creatorInfo": {
            "$ref": "#/components/schemas/SenderInfo1",
            "description": "Information about the creator of the library document.",
            "items": {
              "$ref": "#/components/schemas/SenderInfo"
            }
          }
        },
        "required": [
          "creatorInfo"
        ],
        "type": "object"
      },
      "LibraryDocumentStateInfo": {
        "properties": {
          "state": {
            "description": "State of the library document.",
            "enum": [
              "AUTHORING",
              "ACTIVE",
              "REMOVED"
            ],
            "type": "string"
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "LibraryDocumentViewResponse": {
        "properties": {
          "libraryViewList": {
            "description": "List of library docuemnt views",
            "items": {
              "$ref": "#/components/schemas/LibraryView"
            },
            "type": "array"
          }
        },
        "required": [
          "libraryViewList"
        ],
        "type": "object"
      },
      "LibraryDocuments": {
        "properties": {
          "libraryDocumentList": {
            "description": "An array of document library items",
            "items": {
              "$ref": "#/components/schemas/LibraryDocument"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "libraryDocumentList",
          "page"
        ],
        "type": "object"
      },
      "LibraryView": {
        "properties": {
          "embeddedCode": {
            "description": "Embedded code of url of resource ",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration of user url ",
            "format": "date",
            "type": "string"
          },
          "isCurrent": {
            "description": "True if this view is the current view",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the requested libraryDocument view",
            "enum": [
              "EDIT",
              "DOCUMENT",
              "MANAGE",
              "SEND",
              "ALL"
            ],
            "type": "string"
          },
          "url": {
            "description": "Url of resource location",
            "type": "string"
          }
        },
        "required": [
          "isCurrent",
          "name"
        ],
        "type": "object"
      },
      "LibraryViewInfo": {
        "properties": {
          "commonViewConfiguration": {
            "$ref": "#/components/schemas/CommonViewConfiguration",
            "description": "Common view configuration for all the available views",
            "items": {
              "$ref": "#/components/schemas/CommonViewConfiguration"
            }
          },
          "name": {
            "description": "Name of the requested libraryDocument view",
            "enum": [
              "EDIT",
              "DOCUMENT",
              "MANAGE",
              "SEND",
              "ALL"
            ],
            "type": "string"
          },
          "sendViewConfiguration": {
            "$ref": "#/components/schemas/SendViewConfiguration",
            "description": "Send page view configuration. This will be ignored for views other than SEND.",
            "items": {
              "$ref": "#/components/schemas/SendViewConfiguration"
            }
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "SendViewConfiguration": {
        "properties": {
          "agrName": {
            "description": "The agreement name for the library document on the compose page",
            "type": "string"
          },
          "fileUploadOptions": {
            "$ref": "#/components/schemas/FileUploadOptions",
            "description": "Controls various file upload options available on the compose page",
            "items": {
              "$ref": "#/components/schemas/FileUploadOptions"
            }
          },
          "isPreviewSelected": {
            "description": "Should the compose page be provided with authoring mode selected?",
            "type": "boolean"
          }
        },
        "required": [
          "agrName"
        ],
        "type": "object"
      },
      "SenderInfo1": {
        "properties": {
          "company": {
            "description": "Company of the creator of the library document, if available.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the sender was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the creator of the library document.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the library document is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the creator of the library document, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the creator of the library document.",
            "type": "string"
          },
          "self": {
            "description": "True if the creator of the library document is the same user that is calling the API.",
            "type": "boolean"
          },
          "userId": {
            "description": "The user ID of the sender. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self"
        ],
        "type": "object"
      },
      "AgreementCancellationInfo1": {
        "properties": {
          "comment": {
            "description": "An optional comment describing to the recipients why you want to cancel the transaction",
            "type": "string"
          },
          "notifyOthers": {
            "description": "Whether or not you would like the recipients to be notified that the transaction has been cancelled. The default value is false",
            "type": "boolean"
          }
        },
        "required": [
          "notifyOthers"
        ],
        "type": "object"
      },
      "AgreementDocuments1": {
        "properties": {
          "documents": {
            "description": "A list of documents",
            "items": {
              "$ref": "#/components/schemas/Document"
            },
            "type": "array"
          }
        },
        "required": [
          "documents"
        ],
        "type": "object"
      },
      "BasicDocumentsImageUrlsInfo": {
        "properties": {
          "documentsImageUrlsInfo": {
            "description": "A list of original document image URLs info.",
            "items": {
              "$ref": "#/components/schemas/DocumentImageUrlsInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "documentsImageUrlsInfo"
        ],
        "type": "object"
      },
      "BulkInfo": {
        "properties": {
          "source": {
            "description": "The source for the bulk participants.<br>- FILE: to reference file with participant defined in the ChildAgreementsInfo object.",
            "enum": [
              "FILE"
            ],
            "type": "string"
          }
        },
        "required": [
          "source"
        ],
        "type": "object"
      },
      "BulkParticipantInfo": {
        "properties": {
          "email": {
            "description": "Email of the participant. Currently only supports sender email.",
            "type": "string"
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "BulkParticipantSetInfo": {
        "properties": {
          "bulkInfo": {
            "$ref": "#/components/schemas/BulkInfo",
            "description": "Info about the bulk participants corresponding to each child agreement of the bulk send",
            "items": {
              "$ref": "#/components/schemas/BulkInfo"
            }
          },
          "membersInfo": {
            "description": "Information about the send participants.",
            "items": {
              "$ref": "#/components/schemas/BulkParticipantInfo"
            },
            "type": "array"
          },
          "order": {
            "description": "Index indicating position at which signing group needs to sign.Signing group to sign at first place is assigned a 1 index. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signing order will be considered invalid.",
            "type": "integer"
          },
          "role": {
            "description": "Role assumed by all members in the set.",
            "enum": [
              "SIGNER"
            ],
            "type": "string"
          }
        },
        "required": [
          "order",
          "role"
        ],
        "type": "object"
      },
      "CCParticipantInfo1": {
        "properties": {
          "company": {
            "description": "Company of the CC participant, if available.",
            "type": "string"
          },
          "email": {
            "description": "Email of the CC participant of the bulk send",
            "type": "string"
          },
          "hidden": {
            "description": "True if the bulk send parent is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the CC participant, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the CC participant of the bulk send.",
            "type": "string"
          },
          "self": {
            "description": "True if the CC participant of the bulk send is the same user that is calling the API.",
            "type": "boolean"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self"
        ],
        "type": "object"
      },
      "ChildAgreementsInfo": {
        "properties": {
          "fileInfo": {
            "$ref": "#/components/schemas/MegaSignChildAgreementsFileInfo",
            "description": "File info containing per child agreement information of bulk send.",
            "items": {
              "$ref": "#/components/schemas/MegaSignChildAgreementsFileInfo"
            }
          }
        },
        "required": [
          "fileInfo"
        ],
        "type": "object"
      },
      "DetailedParticipantInfo1": {
        "properties": {
          "company": {
            "description": "The company of the participant, if available.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the participant was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the participant. This is the required field and will always be returned unless it is a fax workflow (legacy Send in Bulk) that were created using fax as input",
            "type": "string"
          },
          "hidden": {
            "description": "True if the bulk send is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the participant.",
            "type": "string"
          },
          "name": {
            "description": "The name of the participant, if available.",
            "type": "string"
          },
          "privateMessage": {
            "description": "The private message of the participant, if available. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/ParticipantSecurityOption",
            "description": "Security options that apply to the participant.",
            "items": {
              "$ref": "#/components/schemas/ParticipantSecurityOption"
            }
          },
          "self": {
            "description": "True if this participant is the same user that is calling the API.",
            "type": "boolean"
          },
          "status": {
            "description": "The status of the participant.",
            "enum": [
              "REPLACED",
              "ACTIVE"
            ],
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the participant. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "securityOption"
        ],
        "type": "object"
      },
      "DetailedParticipantSetInfo1": {
        "properties": {
          "id": {
            "description": "The unique identifier of the participant set.",
            "type": "string"
          },
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set",
            "items": {
              "$ref": "#/components/schemas/DetailedParticipantInfo1"
            },
            "type": "array"
          },
          "name": {
            "description": "Name of ParticipantSet (it can be empty, but needs not to be unique in a single bulk send). Maximum no of characters in participant set name is restricted to 255.",
            "type": "string"
          },
          "order": {
            "description": "Index indicating sequential signing group (specified for hybrid routing).",
            "type": "integer"
          },
          "privateMessage": {
            "description": "Participant set's private message - all participants in the set will receive the same message.",
            "type": "string"
          },
          "role": {
            "description": "Role assumed by all participants in the set (signer, approver etc.).",
            "enum": [
              "SIGNER",
              "SENDER",
              "APPROVER",
              "ACCEPTOR",
              "CERTIFIED_RECIPIENT",
              "FORM_FILLER",
              "DELEGATE_TO_SIGNER",
              "DELEGATE_TO_APPROVER",
              "DELEGATE_TO_ACCEPTOR",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "DELEGATE_TO_FORM_FILLER",
              "SHARE",
              "NOTARY_SIGNER"
            ],
            "type": "string"
          },
          "status": {
            "description": "The bulk send status with respect to the participant set.",
            "enum": [
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "NOT_YET_VISIBLE",
              "WAITING_FOR_NOTARIZATION",
              "WAITING_FOR_OTHERS",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_MY_VERIFICATION",
              "WAITING_FOR_PREFILL"
            ],
            "type": "string"
          }
        },
        "required": [
          "memberInfos",
          "order",
          "role"
        ],
        "type": "object"
      },
      "FetchedMegaSignInfo": {
        "properties": {
          "ccs": {
            "description": "A list of one or more CCs that will be copied in the bulk send transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file ",
            "items": {
              "$ref": "#/components/schemas/MegaSignCcInfo"
            },
            "type": "array"
          },
          "childAgreementsInfo": {
            "$ref": "#/components/schemas/ChildAgreementsInfo",
            "description": "Info corresponding to each child agreement of the bulk send ",
            "items": {
              "$ref": "#/components/schemas/ChildAgreementsInfo"
            }
          },
          "createdDate": {
            "description": "Date when bulk send was created. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "expirationTime": {
            "description": "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.",
            "format": "date",
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/ExternalId",
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            }
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo2"
            },
            "type": "array"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Cannot be updated in a PUT",
            "type": "integer"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the bulk send will belong to when it is created. If it is not provided during agreement creation the primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of bulk send ",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this bulk send.  Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender",
            "type": "string"
          },
          "message": {
            "description": "An optional message to the participants, describing what is being sent or why their signature is required",
            "type": "string"
          },
          "name": {
            "description": "The name of the agreement that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "numChildren": {
            "description": "The total number of bulk send children associated with the bulk send parent. If provided in POST, it will be ignored. If modified in PUT, it will throw error MODIFYING_IMMUTABLE_FIELDS",
            "type": "integer"
          },
          "participantSetsInfo": {
            "description": "Information about the bulk send participants set.",
            "items": {
              "$ref": "#/components/schemas/BulkParticipantSetInfo"
            },
            "type": "array"
          },
          "postSignOption": {
            "$ref": "#/components/schemas/PostSignOption",
            "description": "URL and associated properties for the success page the user will be taken to after completing the signing process",
            "items": {
              "$ref": "#/components/schemas/PostSignOption"
            }
          },
          "reminderFrequency": {
            "description": "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED"
            ],
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/MegaSignSecurityOption",
            "description": "Optional security parameters for the bulk send",
            "items": {
              "$ref": "#/components/schemas/MegaSignSecurityOption"
            }
          },
          "senderEmail": {
            "description": "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored",
            "type": "string"
          },
          "signatureType": {
            "description": "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>,\nWRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system",
            "enum": [
              "ESIGN",
              "WRITTEN"
            ],
            "type": "string"
          },
          "state": {
            "description": "State of the bulk send",
            "enum": [
              "AUTHORING",
              "IN_PROCESS"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the bulk send",
            "enum": [
              "AUTHORING",
              "IN_PROCESS",
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "PREFILL"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          }
        },
        "required": [
          "childAgreementsInfo",
          "name",
          "signatureType",
          "state"
        ],
        "type": "object"
      },
      "FileInfo2": {
        "properties": {
          "libraryDocumentId": {
            "description": "ID for an existing Library document that will be added to the agreement",
            "type": "string"
          },
          "notarize": {
            "description": "Indicates that this document needs to be notarized",
            "type": "boolean"
          },
          "transientDocumentId": {
            "description": "ID for a transient document that will be added to the agreement",
            "type": "string"
          },
          "urlFileInfo": {
            "$ref": "#/components/schemas/URLFileInfo",
            "description": "URL for an external document to add to the agreement",
            "items": {
              "$ref": "#/components/schemas/URLFileInfo"
            }
          }
        },
        "type": "object"
      },
      "FormField1": {
        "description": "A form field for an agreement.",
        "properties": {
          "alignment": {
            "description": "Alignment of the text.",
            "enum": [
              "LEFT",
              "RIGHT",
              "CENTER"
            ],
            "type": "string"
          },
          "assignee": {
            "description": "Who the field is assigned to. Valid values are a participant set id, null, \"SIGNER\", \"SENDER\", \"NOBODY\", \"PREFILL\" or \"EVERYONE\". If \"SENDER\" is specified, Sender Signs First/Last must also be defined (Sender is also a Signer of the bulk send). If set to a participant set id, then any member of that participant set may fill out the field. \"NOBODY\" indicates that the field may not be filled by anybody (e.g. autopopulated fields like transaction number). \"PREFILL\" indicates that the field will be filled by the sender before the agreement is sent out for signing. \"EVERYONE\" exists only in hyperlink fields currently and indicates that it is assigned to all participants. null indicates that anybody may fill out the field. If the property isn't specified, it is treated as null.",
            "type": "string"
          },
          "backgroundColor": {
            "description": "Background color of the form field in RGB or HEX format",
            "type": "string"
          },
          "borderColor": {
            "description": "Color of the border of the field in RGB or HEX format",
            "type": "string"
          },
          "borderStyle": {
            "description": "Style of the border of the field.",
            "enum": [
              "SOLID",
              "DASHED",
              "BEVELED",
              "INSET",
              "UNDERLINE"
            ],
            "type": "string"
          },
          "borderWidth": {
            "description": "Width of the border of the field in default user space units",
            "format": "double",
            "type": "number"
          },
          "calculated": {
            "description": "true if this field's value is calculated from an expression, else false",
            "type": "boolean"
          },
          "conditionalAction": {
            "$ref": "#/components/schemas/FormFieldConditionalAction",
            "description": "A predicate (or set of predicates) that determines whether this field is visible and enabled.",
            "items": {
              "$ref": "#/components/schemas/FormFieldConditionalAction"
            }
          },
          "contentType": {
            "description": "Content Type of the form field.",
            "enum": [
              "DATA",
              "SIGNATURE_BLOCK",
              "SIGNATURE",
              "SIGNER_NAME",
              "SIGNER_FIRST_NAME",
              "SIGNER_LAST_NAME",
              "SIGNER_INITIALS",
              "SIGNER_EMAIL",
              "SIGNER_TITLE",
              "SIGNER_COMPANY",
              "SIGNATURE_DATE",
              "AGREEMENT_NAME",
              "AGREEMENT_MESSAGE",
              "TRANSACTION_ID",
              "SIGNATURE_STAMP",
              "PAYMENT",
              "DIGITAL_SIGNATURE",
              "CALC"
            ],
            "type": "string"
          },
          "currency": {
            "description": "A currency ISO code. Only applicable for payment form fields. Should be one of the currencies supported in the payment integration merchant accounts.",
            "type": "string"
          },
          "defaultValue": {
            "description": "Default value of the form field",
            "type": "string"
          },
          "displayFormat": {
            "description": "Format of the value of the field to be displayed based on the displayFormatType property.",
            "type": "string"
          },
          "displayFormatType": {
            "description": "Format type of the text field.",
            "enum": [
              "DEFAULT",
              "DATE",
              "NUMBER"
            ],
            "type": "string"
          },
          "displayLabel": {
            "description": "Display label attached to the field",
            "type": "string"
          },
          "fontColor": {
            "description": "Font color of the form field in RGB or HEX format",
            "type": "string"
          },
          "fontName": {
            "description": "Font name of the form field",
            "type": "string"
          },
          "fontSize": {
            "description": "Font size of the form field in points",
            "format": "double",
            "type": "number"
          },
          "hiddenOptions": {
            "description": "Text values which are hidden in a drop down form field",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "hyperlink": {
            "$ref": "#/components/schemas/FormFieldHyperlink",
            "description": "Hyperlink-specific data (e.g. as url, link type)",
            "items": {
              "$ref": "#/components/schemas/FormFieldHyperlink"
            }
          },
          "inputType": {
            "description": "Input type of the form field",
            "enum": [
              "TEXT_FIELD",
              "MULTILINE",
              "PASSWORD",
              "RADIO",
              "CHECKBOX",
              "DROP_DOWN",
              "LISTBOX",
              "SIGNATURE",
              "PDF_SIGNATURE",
              "BUTTON",
              "BLOCK",
              "FILE_CHOOSER",
              "COMB",
              "INLINE_IMAGE",
              "UNSUPPORTED"
            ],
            "type": "string"
          },
          "locations": {
            "description": "All locations in a document where the form field is placed",
            "items": {
              "$ref": "#/components/schemas/FormFieldLocation"
            },
            "type": "array"
          },
          "masked": {
            "description": "true if the input entered by the signer has to be masked (like password), false if it shouldn't be",
            "type": "boolean"
          },
          "maskingText": {
            "description": "Text to mask the masked form field",
            "type": "string"
          },
          "maxLength": {
            "description": "Maximum length of the input text field in terms of no. of characters",
            "type": "integer"
          },
          "maxValue": {
            "description": "Upper bound of the number that can be entered by the signer",
            "format": "double",
            "type": "number"
          },
          "minLength": {
            "description": "Minimum length of the input text field in terms of no. of characters",
            "type": "integer"
          },
          "minValue": {
            "description": "Lower bound of the number that can be entered by the signer",
            "format": "double",
            "type": "number"
          },
          "name": {
            "description": "The name of the form field",
            "type": "string"
          },
          "origin": {
            "description": "Origin of Form Field",
            "enum": [
              "AUTHORED",
              "GENERATED",
              "IMPORTED"
            ],
            "type": "string"
          },
          "radioCheckType": {
            "description": "The type of radio button (if field is radio button, identified by inputType).",
            "enum": [
              "CIRCLE",
              "CHECK",
              "CROSS",
              "DIAMOND",
              "SQUARE",
              "STAR"
            ],
            "type": "string"
          },
          "readOnly": {
            "description": "true if it is a read-only field, else false",
            "type": "boolean"
          },
          "required": {
            "description": "true if it is a mandatory field to be filled by the signer, else false",
            "type": "boolean"
          },
          "tooltip": {
            "description": "Tooltip text for the form field",
            "type": "string"
          },
          "urlOverridable": {
            "description": "For web form text fields only - true if the default value may come from the URL, else false",
            "type": "boolean"
          },
          "validation": {
            "description": "Rule for validating the field value.",
            "enum": [
              "NONE",
              "STRING",
              "NUMBER",
              "DATE",
              "DATE_CUSTOM",
              "TIME",
              "ZIP",
              "PHONE",
              "SOCIAL_SEC",
              "EMAIL",
              "CURRENCY",
              "PERCENT",
              "FORMULA",
              "CUSTOM",
              "XFA_PICTURE"
            ],
            "type": "string"
          },
          "validationData": {
            "description": "Further data for validating input with regards to the field's specified format. The contents and interpretation of formatData depends on the value of validation.",
            "type": "string"
          },
          "validationErrMsg": {
            "description": "Error message to be shown to the signer if filled value doesn't match the validations of the form field",
            "type": "string"
          },
          "valueExpression": {
            "description": "Expression to calculate value of the form field",
            "type": "string"
          },
          "visible": {
            "description": "If set to false, then the form field is hidden.  Otherwise, it is visible.",
            "type": "boolean"
          },
          "visibleOptions": {
            "description": "Text values which are visible in a drop down form field",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "locations",
          "name"
        ],
        "type": "object"
      },
      "FormFieldPutInfo1": {
        "description": "Information required to add or replace agreement form fields",
        "properties": {
          "fields": {
            "description": "The list of fields to update or replace.",
            "items": {
              "$ref": "#/components/schemas/FormField1"
            },
            "type": "array"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "MegaSign": {
        "properties": {
          "displayDate": {
            "description": "The display date for the bulk send parent agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "esign": {
            "description": "True, if the signature type of the bulk send parent agreement is ESIGN. False, if the signature type of the bulk send parent agreement is WRITTEN",
            "type": "boolean"
          },
          "groupId": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "hidden": {
            "description": "True, if bulk send is hidden for the user",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the bulk send parent agreement",
            "type": "string"
          },
          "name": {
            "description": "Name of the bulk send parent agreement",
            "type": "string"
          },
          "status": {
            "description": "Current status of the bulk send parent agreement from the perspective of the user",
            "enum": [
              "WAITING_FOR_MY_SIGNATURE",
              "IN_PROCESS",
              "CANCELLED",
              "ARCHIVED",
              "COMPLETED",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_PREFILL"
            ],
            "type": "string"
          }
        },
        "required": [
          "displayDate",
          "esign",
          "groupId",
          "hidden",
          "id",
          "name",
          "status"
        ],
        "type": "object"
      },
      "MegaSignCcInfo": {
        "properties": {
          "email": {
            "description": "Email of the CC participant of the bulk send.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "MegaSignChildAgreement": {
        "properties": {
          "displayDate": {
            "description": "The display date for the agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "esign": {
            "description": "True if this is an e-sign document",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement.If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "name": {
            "description": "Name of the Agreement",
            "type": "string"
          },
          "parentId": {
            "description": "The parent id of a bulk send child *OR* the originating id of a web form agreement instance",
            "type": "string"
          },
          "status": {
            "description": "This is a server generated attribute which provides the detailed status of an agreement with respect to the apiCaller",
            "enum": [
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_NOTARIZATION",
              "OUT_FOR_SIGNATURE",
              "OUT_FOR_APPROVAL",
              "OUT_FOR_DELIVERY",
              "OUT_FOR_ACCEPTANCE",
              "OUT_FOR_FORM_FILLING",
              "SIGNED",
              "APPROVED",
              "FORM_FILLED",
              "DELIVERED",
              "ACCEPTED",
              "ARCHIVED",
              "CANCELLED",
              "EXPIRED",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_PREFILL",
              "DRAFT",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "WAITING_FOR_MY_VERIFICATION",
              "WAITING_FOR_VERIFICATION"
            ],
            "type": "string"
          },
          "type": {
            "description": "The kind of agreement",
            "enum": [
              "AGREEMENT",
              "MEGASIGN_CHILD",
              "WIDGET_INSTANCE"
            ],
            "type": "string"
          }
        },
        "required": [
          "displayDate",
          "esign",
          "name"
        ],
        "type": "object"
      },
      "MegaSignChildAgreements": {
        "properties": {
          "megaSignChildAgreementList": {
            "description": "A array of bulk send child agreements",
            "items": {
              "$ref": "#/components/schemas/MegaSignChildAgreement"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "megaSignChildAgreementList",
          "page"
        ],
        "type": "object"
      },
      "MegaSignChildAgreementsFileInfo": {
        "properties": {
          "childAgreementsInfoFileId": {
            "description": "id of the file containg information about the existing childAgreementsInfo associated with the bulk send. Will be ignored in POST and PUT calls and in the case of GET call, this is the only thing that will be returned. The content of the file can be fetched through GET /megaSigns/{megaSignId}/childAgreementsInfo/{childAgreementsInfoFileId} endpoint.",
            "type": "string"
          },
          "fileType": {
            "description": "Input type through which participantSetsInfos will be provided. Whichever input type is provided, the values should be provided in its corresponding value object. Currently we are supporting CSV file format for providing Send in Bulk child recipients.",
            "enum": [
              "CSV"
            ],
            "type": "string"
          },
          "transientDocumentId": {
            "description": "Transient id of the input file which contains participantSetsInfos. Currently only csv format is suppported. More details about CSV format <a href='https://www.adobe.com/go/documentcloud_megasigncsv'>here</a>  ",
            "type": "string"
          }
        },
        "required": [
          "fileType",
          "transientDocumentId"
        ],
        "type": "object"
      },
      "MegaSignCreationInfo": {
        "properties": {
          "ccs": {
            "description": "A list of one or more CCs that will be copied in the bulk send transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file ",
            "items": {
              "$ref": "#/components/schemas/MegaSignCcInfo"
            },
            "type": "array"
          },
          "childAgreementsInfo": {
            "$ref": "#/components/schemas/ChildAgreementsInfo",
            "description": "Info corresponding to each child agreement of the bulk send ",
            "items": {
              "$ref": "#/components/schemas/ChildAgreementsInfo"
            }
          },
          "createdDate": {
            "description": "Date when bulk send was created. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "expirationTime": {
            "description": "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.",
            "format": "date",
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/ExternalId",
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            }
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo2"
            },
            "type": "array"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Cannot be updated in a PUT",
            "type": "integer"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the bulk send will belong to when it is created. If it is not provided during agreement creation the primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of bulk send ",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this bulk send.  Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender",
            "type": "string"
          },
          "message": {
            "description": "An optional message to the participants, describing what is being sent or why their signature is required",
            "type": "string"
          },
          "name": {
            "description": "The name of the agreement that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "numChildren": {
            "description": "The total number of bulk send children associated with the bulk send parent. If provided in POST, it will be ignored. If modified in PUT, it will throw error MODIFYING_IMMUTABLE_FIELDS",
            "type": "integer"
          },
          "participantSetsInfo": {
            "description": "Information about the bulk send participants set.",
            "items": {
              "$ref": "#/components/schemas/BulkParticipantSetInfo"
            },
            "type": "array"
          },
          "postSignOption": {
            "$ref": "#/components/schemas/PostSignOption",
            "description": "URL and associated properties for the success page the user will be taken to after completing the signing process",
            "items": {
              "$ref": "#/components/schemas/PostSignOption"
            }
          },
          "reminderFrequency": {
            "description": "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED"
            ],
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/MegaSignSecurityOption",
            "description": "Optional security parameters for the bulk send",
            "items": {
              "$ref": "#/components/schemas/MegaSignSecurityOption"
            }
          },
          "senderEmail": {
            "description": "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored",
            "type": "string"
          },
          "signatureType": {
            "description": "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>,\nWRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system",
            "enum": [
              "ESIGN",
              "WRITTEN"
            ],
            "type": "string"
          },
          "state": {
            "description": "State of the bulk send",
            "enum": [
              "AUTHORING",
              "IN_PROCESS"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the bulk send",
            "enum": [
              "AUTHORING",
              "IN_PROCESS",
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "PREFILL"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          }
        },
        "required": [
          "childAgreementsInfo",
          "fileInfos",
          "name",
          "signatureType",
          "state"
        ],
        "type": "object"
      },
      "MegaSignCreationResponse": {
        "description": "A JSON that contains the id of the newly created bulk send",
        "properties": {
          "id": {
            "description": "Unique identifier of the bulk send parent agreement",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "MegaSignFormFields": {
        "description": "A JSON list of all of the fields for a bulk send parent agreement.",
        "properties": {
          "fields": {
            "description": "List of the form fields in an agreement",
            "items": {
              "$ref": "#/components/schemas/FormField1"
            },
            "type": "array"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "MegaSignInfo": {
        "properties": {
          "ccs": {
            "description": "A list of one or more CCs that will be copied in the bulk send transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file ",
            "items": {
              "$ref": "#/components/schemas/MegaSignCcInfo"
            },
            "type": "array"
          },
          "childAgreementsInfo": {
            "$ref": "#/components/schemas/ChildAgreementsInfo",
            "description": "Info corresponding to each child agreement of the bulk send ",
            "items": {
              "$ref": "#/components/schemas/ChildAgreementsInfo"
            }
          },
          "createdDate": {
            "description": "Date when bulk send was created. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "expirationTime": {
            "description": "Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.",
            "format": "date",
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/ExternalId",
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried. Note: the externalId value is visible to all participants through the API, so should not be used to contain a sensitive token.",
            "items": {
              "$ref": "#/components/schemas/ExternalId"
            }
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo2"
            },
            "type": "array"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Cannot be updated in a PUT",
            "type": "integer"
          },
          "groupId": {
            "description": "The unique identifier of the group to which the bulk send will belong to when it is created. If it is not provided during agreement creation the primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of bulk send ",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this bulk send.  Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender",
            "type": "string"
          },
          "message": {
            "description": "An optional message to the participants, describing what is being sent or why their signature is required",
            "type": "string"
          },
          "name": {
            "description": "The name of the agreement that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "numChildren": {
            "description": "The total number of bulk send children associated with the bulk send parent. If provided in POST, it will be ignored. If modified in PUT, it will throw error MODIFYING_IMMUTABLE_FIELDS",
            "type": "integer"
          },
          "participantSetsInfo": {
            "description": "Information about the bulk send participants set.",
            "items": {
              "$ref": "#/components/schemas/BulkParticipantSetInfo"
            },
            "type": "array"
          },
          "postSignOption": {
            "$ref": "#/components/schemas/PostSignOption",
            "description": "URL and associated properties for the success page the user will be taken to after completing the signing process",
            "items": {
              "$ref": "#/components/schemas/PostSignOption"
            }
          },
          "reminderFrequency": {
            "description": "Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED"
            ],
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/MegaSignSecurityOption",
            "description": "Optional security parameters for the bulk send",
            "items": {
              "$ref": "#/components/schemas/MegaSignSecurityOption"
            }
          },
          "senderEmail": {
            "description": "Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored",
            "type": "string"
          },
          "signatureType": {
            "description": "Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>,\nWRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system",
            "enum": [
              "ESIGN",
              "WRITTEN"
            ],
            "type": "string"
          },
          "state": {
            "description": "State of the bulk send",
            "enum": [
              "AUTHORING",
              "IN_PROCESS"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the bulk send",
            "enum": [
              "AUTHORING",
              "IN_PROCESS",
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "PREFILL"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          }
        },
        "required": [
          "childAgreementsInfo",
          "fileInfos",
          "name",
          "signatureType",
          "state"
        ],
        "type": "object"
      },
      "MegaSignMembersInfo": {
        "properties": {
          "ccsInfo": {
            "description": "Information of CC participants of the bulk send.",
            "items": {
              "$ref": "#/components/schemas/CCParticipantInfo1"
            },
            "type": "array"
          },
          "participantSets": {
            "description": "Information about the participant Sets.",
            "items": {
              "$ref": "#/components/schemas/DetailedParticipantSetInfo1"
            },
            "type": "array"
          },
          "senderInfo": {
            "$ref": "#/components/schemas/SenderInfo2",
            "description": "Information of the sender of the bulk send.",
            "items": {
              "$ref": "#/components/schemas/SenderInfo"
            }
          },
          "sharesInfo": {
            "description": "Information of the participants with whom the bulk send has been shared.",
            "items": {
              "$ref": "#/components/schemas/ShareParticipantInfo1"
            },
            "type": "array"
          }
        },
        "required": [
          "ccsInfo",
          "participantSets",
          "senderInfo",
          "sharesInfo"
        ],
        "type": "object"
      },
      "MegaSignRemindersResponse": {
        "properties": {
          "reminderInfoList": {
            "description": "A list of one or more reminders created on the bulk send parent specified by the unique identifier megasignId by the user invoking the API.",
            "items": {
              "$ref": "#/components/schemas/ReminderInfo1"
            },
            "type": "array"
          }
        },
        "required": [
          "reminderInfoList"
        ],
        "type": "object"
      },
      "MegaSignSecurityOption": {
        "properties": {
          "externalAuthenticationMethod": {
            "description": "The authentication method for the participants to have access to view and sign the document.",
            "enum": [
              "NONE",
              "WEB_IDENTITY",
              "KBA",
              "PASSWORD"
            ],
            "type": "string"
          },
          "externalPassword": {
            "description": "The secondary password that will be used to protect signing the document for internal signers. Note that Acrobat Sign will never show this password to anyone, so you will need to separately communicate it to any relevant parties. This password is applied only if password protection is specified for internal signers or all signers",
            "type": "string"
          },
          "internalAuthenticationMethod": {
            "description": "The authentication method for the participants to have access to view and sign the document.",
            "enum": [
              "NONE",
              "WEB_IDENTITY",
              "KBA",
              "PASSWORD"
            ],
            "type": "string"
          },
          "internalPassword": {
            "description": "The secondary password that will be used to protect signing the document for external signers. Note that Acrobat Sign will never show this password to anyone, so you will need to separately communicate it to any relevant parties. This password is applied only if password protection is specified for external signers or all signers",
            "type": "string"
          },
          "openPassword": {
            "description": "The secondary password that will be used to secure the PDF document. Note that Acrobat Sign will never show this password to anyone, so you will need to separately communicate it to any relevant parties",
            "type": "string"
          }
        },
        "required": [
          "externalAuthenticationMethod",
          "internalAuthenticationMethod"
        ],
        "type": "object"
      },
      "MegaSignStateInfo": {
        "properties": {
          "megaSignCancellationInfo": {
            "$ref": "#/components/schemas/AgreementCancellationInfo1",
            "description": "Cancellation information for the agreement. Mandatory while cancelling a bulk send",
            "items": {
              "$ref": "#/components/schemas/AgreementCancellationInfo"
            }
          },
          "state": {
            "description": "The state to which the bulk send is to be updated",
            "enum": [
              "IN_PROCESS",
              "CANCELLED"
            ],
            "type": "string"
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "MegaSignView": {
        "properties": {
          "embeddedCode": {
            "description": "Embedded code of url of resource ",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration of user url ",
            "format": "date",
            "type": "string"
          },
          "isCurrent": {
            "description": "True if this view is the current view",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the requested bulk send view",
            "enum": [
              "ACTIVITY_REPORT",
              "AUTHORING",
              "DOCUMENT",
              "MANAGE",
              "POST_CREATE",
              "PREFILL",
              "SIGNING",
              "ALL"
            ],
            "type": "string"
          },
          "url": {
            "description": "Url of resource location",
            "type": "string"
          }
        },
        "required": [
          "isCurrent",
          "name"
        ],
        "type": "object"
      },
      "MegaSignViewInfo": {
        "properties": {
          "commonViewConfiguration": {
            "$ref": "#/components/schemas/CommonViewConfiguration",
            "description": "Common view configuration for all the available views",
            "items": {
              "$ref": "#/components/schemas/CommonViewConfiguration"
            }
          },
          "name": {
            "description": "Name of the requested bulk send view",
            "enum": [
              "ACTIVITY_REPORT",
              "AUTHORING",
              "DOCUMENT",
              "MANAGE",
              "POST_CREATE",
              "PREFILL",
              "SIGNING",
              "ALL"
            ],
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "MegaSignViewResponse": {
        "properties": {
          "megaSignViewList": {
            "description": "List of bulk send views",
            "items": {
              "$ref": "#/components/schemas/MegaSignView"
            },
            "type": "array"
          }
        },
        "required": [
          "megaSignViewList"
        ],
        "type": "object"
      },
      "MegaSigns": {
        "properties": {
          "megaSignList": {
            "description": "An array of Send in Bulk parent agreements",
            "items": {
              "$ref": "#/components/schemas/MegaSign"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "megaSignList",
          "page"
        ],
        "type": "object"
      },
      "MegasignEvent": {
        "properties": {
          "actingUserEmail": {
            "description": "Email address of the user that created the event",
            "type": "string"
          },
          "actingUserIpAddress": {
            "description": "The IP address of the user that created the event",
            "type": "string"
          },
          "actingUserName": {
            "description": "The name of the acting user",
            "type": "string"
          },
          "comment": {
            "description": "The event comment. For RECALLED or REJECTED, the reason given by the user that initiates the event. For DELEGATE or SHARE, the message from the acting user to the participant",
            "type": "string"
          },
          "date": {
            "description": "The date of the audit event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "description": {
            "description": "A description of the audit event",
            "type": "string"
          },
          "device": {
            "description": "The device used for the event.",
            "type": "string"
          },
          "deviceLocation": {
            "$ref": "#/components/schemas/DeviceLocation",
            "description": "Location of the device that generated the event (This value may be null due to limited privileges)",
            "items": {
              "$ref": "#/components/schemas/DeviceLocation"
            }
          },
          "devicePhoneNumber": {
            "description": "Phone number from the device used when the participation is completed on a mobile phone",
            "type": "string"
          },
          "digitalSignatureInfo": {
            "$ref": "#/components/schemas/DigitalSignatureInfo",
            "description": "This is present for ESIGNED events when the participation is signed digitally",
            "items": {
              "$ref": "#/components/schemas/DigitalSignatureInfo"
            }
          },
          "id": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "initiatingUserEmail": {
            "description": "Email address of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "initiatingUserName": {
            "description": "Full name of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "participantEmail": {
            "description": "Email address of the user that is the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantRole": {
            "description": "Role assumed by all participants in the participant set the participant belongs to (signer, approver etc.).",
            "enum": [
              "SIGNER",
              "DELEGATE_TO_SIGNER",
              "APPROVER",
              "DELEGATE_TO_APPROVER",
              "ACCEPTOR",
              "DELEGATE_TO_ACCEPTOR",
              "FORM_FILLER",
              "DELEGATE_TO_FORM_FILLER",
              "CERTIFIED_RECIPIENT",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "SHARE",
              "RESOURCE_SHARE",
              "SENDER",
              "NOTARY_SIGNER"
            ],
            "type": "string"
          },
          "reminderParticipants": {
            "description": "A list of one or more participants who received the reminders",
            "items": {
              "$ref": "#/components/schemas/ReminderParticipant"
            },
            "type": "array"
          },
          "replacedParticipantEmail": {
            "description": "Email of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "replacedParticipantName": {
            "description": "Full name of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "signerNewName": {
            "description": "Signer changed name at signing : new name used to sign.",
            "type": "string"
          },
          "signerOldName": {
            "description": "Signer changed name at signing : name used previous to signing.",
            "type": "string"
          },
          "signingReason": {
            "description": "Signing reason captured during ESIGN or DIGSIGN",
            "type": "string"
          },
          "synchronizationId": {
            "description": "A unique identifier linking offline events to synchronization events (specified for offline signing events and synchronization events, else null)",
            "type": "string"
          },
          "type": {
            "description": "Type of bulk send event",
            "enum": [
              "AUTO_CANCELLED_CONVERSION_PROBLEM",
              "CREATED",
              "EXPIRED",
              "EMAIL_BOUNCED",
              "RECALLED",
              "SHARED",
              "READY_TO_VAULT",
              "VAULTED"
            ],
            "type": "string"
          },
          "vaultEventId": {
            "description": "The identifier assigned by the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "vaultProviderName": {
            "description": "Name of the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "versionId": {
            "description": "An ID which uniquely identifies the version of the document associated with this audit event",
            "type": "string"
          }
        },
        "required": [
          "actingUserEmail",
          "actingUserIpAddress",
          "actingUserName",
          "date",
          "description",
          "device",
          "deviceLocation",
          "devicePhoneNumber",
          "digitalSignatureInfo",
          "initiatingUserEmail",
          "initiatingUserName",
          "participantEmail",
          "participantId",
          "participantRole",
          "synchronizationId",
          "type",
          "vaultEventId",
          "vaultProviderName",
          "versionId"
        ],
        "type": "object"
      },
      "MegasignEventList": {
        "properties": {
          "events": {
            "description": "An array of event objects.",
            "items": {
              "$ref": "#/components/schemas/MegasignEvent"
            },
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "type": "object"
      },
      "ReminderInfo1": {
        "properties": {
          "allUnsigned": {
            "description": "If true, set a reminder on all participants (non-CCs and non-sharees) that still need to sign the bulk send agreement",
            "type": "boolean"
          },
          "firstReminderDelay": {
            "description": "Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours. Cannot be updated in a PUT",
            "type": "integer"
          },
          "frequency": {
            "description": "The frequency at which reminder will be sent until the agreement is completed.<br>If frequency is not provided, the reminder will be sent once (if the agreement is available at the specified time) with the delay based on the firstReminderDelay field and will never repeat again. If the agreement is not available at that time, reminder will not be sent. Cannot be updated in a PUT",
            "enum": [
              "DAILY_UNTIL_SIGNED",
              "WEEKDAILY_UNTIL_SIGNED",
              "EVERY_OTHER_DAY_UNTIL_SIGNED",
              "EVERY_THIRD_DAY_UNTIL_SIGNED",
              "EVERY_FIFTH_DAY_UNTIL_SIGNED",
              "WEEKLY_UNTIL_SIGNED",
              "ONCE"
            ],
            "type": "string"
          },
          "lastSentDate": {
            "description": "The date when the reminder was last sent. Only provided in GET. Cannot be provided in POST request. If provided in POST, it will be ignored. Cannot be updated in a PUT. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "nextSentDate": {
            "description": "The date when the reminder is scheduled to be sent next. When provided in POST request, frequency needs to be ONCE (or not specified), startReminderCounterFrom needs to be REMINDER_CREATION (or not specified) and firstReminderDelay needs to be 0 (or not specified). Cannot be updated in a PUT. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "note": {
            "description": "An optional message sent to the recipients, describing why their participation is required",
            "type": "string"
          },
          "recipientParticipantIds": {
            "description": "A list of one or more participant IDs that the reminder should be sent to. These must be sharees or cc's on the bulk send. In order to remind any other participant who has not signed, use the allUnsigned boolean parameter.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "reminderId": {
            "description": "An identifier of the reminder resource created on the server. If provided in POST or PUT, it will be ignored",
            "type": "string"
          },
          "startReminderCounterFrom": {
            "description": "Reminder can be sent based on when the agreement becomes available or when the reminder is created<br>AGREEMENT_AVAILABILITY: If the agreement is not available to the participant at the time of reminder creation, the reminder will be sent for the first time, only when the agreement becomes available to the participant taking the firstReminderDelay into account. Subsequent reminders will be sent based on the frequency specified.  If the agreement is already available to the participant at the time of reminder creation, the first reminder will be sent after the delay specified by firstReminderDelay from the reminder creation time.<br>REMINDER_CREATION: The first reminder will be sent after the delay specified by firstReminderDelay from the reminder creation time only if the agreement is available at that time. Subsequent reminders will be triggered based on the frequency specified and will be sent only if the agreement is available at that time.  For agreements in authoring state, creating reminder with startReminderCounterFrom as REMINDER_CREATION is not allowed.<br>Note : If firstReminderDelay, frequency and startReminderCounterFrom fields are not specified in POST, reminder will be sent right now if the agreement is available. If agreement is not available, an error will be thrown.  Cannot be updated in a PUT",
            "enum": [
              "AGREEMENT_AVAILABILITY",
              "REMINDER_CREATION"
            ],
            "type": "string"
          },
          "status": {
            "description": "Current status of the reminder.  The only valid update in a PUT is from ACTIVE to CANCELED.  Must be provided as ACTIVE in a POST.",
            "enum": [
              "ACTIVE",
              "CANCELED",
              "COMPLETE"
            ],
            "type": "string"
          }
        },
        "required": [
          "recipientParticipantIds",
          "status"
        ],
        "type": "object"
      },
      "SenderInfo2": {
        "properties": {
          "company": {
            "description": "Company of the sender of the bulk send, if available.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the sender was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the sender of the bulk send.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the bulk send is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the sender of the bulk send, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the sender of the bulk send.",
            "type": "string"
          },
          "self": {
            "description": "True if the sender of the bulk send is the same user that is calling the API.",
            "type": "boolean"
          },
          "status": {
            "description": "The bulk send status with respect to the participant set.",
            "enum": [
              "CANCELLED",
              "COMPLETED",
              "EXPIRED",
              "NOT_YET_VISIBLE",
              "WAITING_FOR_AUTHORING",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_OTHERS"
            ],
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the sender. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self",
          "status"
        ],
        "type": "object"
      },
      "ShareParticipantInfo1": {
        "properties": {
          "company": {
            "description": "Company of the sharee participant of the bulk send, if available.",
            "type": "string"
          },
          "email": {
            "description": "Email of the sharee participant of the bulk send.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the bulk send parent is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the sharee participant of the bulk send, if available.",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the sharee participant of the bulk send.",
            "type": "string"
          },
          "self": {
            "description": "True if the Share participant of the bulk send is the same user that is calling the API.",
            "type": "boolean"
          },
          "sharerParticipantId": {
            "description": "The unique identifier of the participant who shared the bulk send.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self",
          "sharerParticipantId"
        ],
        "type": "object"
      },
      "MessageTemplate": {
        "description": "Message template item",
        "properties": {
          "locale": {
            "description": "Message template locale",
            "type": "string"
          },
          "messageTemplateId": {
            "description": "Unique identifier of the message template",
            "type": "string"
          },
          "name": {
            "description": "Message template name",
            "type": "string"
          },
          "text": {
            "description": "Message template text",
            "type": "string"
          }
        },
        "required": [
          "locale",
          "messageTemplateId",
          "name",
          "text"
        ],
        "type": "object"
      },
      "MessageTemplates": {
        "description": "List of message templates",
        "properties": {
          "messageTemplateList": {
            "description": "An array of message template items",
            "items": {
              "$ref": "#/components/schemas/MessageTemplate"
            },
            "type": "array"
          },
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          }
        },
        "required": [
          "messageTemplateList",
          "page"
        ],
        "type": "object"
      },
      "AgreementAssetsCriteria": {
        "properties": {
          "createdDate": {
            "$ref": "#/components/schemas/DateRangeFilter",
            "description": "A range filter against the agreement creation date. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "items": {
              "$ref": "#/components/schemas/DateRangeFilter"
            }
          },
          "expirationDate": {
            "$ref": "#/components/schemas/DateRangeFilter",
            "description": "A range filter against the agreement expiration date. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "items": {
              "$ref": "#/components/schemas/DateRangeFilter"
            }
          },
          "externalId": {
            "description": "A filter against case-sensitive external id for which you would like to retrieve agreement asset information. External id is passed in the call to the agreement asset creation API.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "groupId": {
            "description": "A filter against group identifier, as returned by the group creation API or retrieved from the API to fetch groups.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "id": {
            "description": "A filter against case-sensitive agreement asset id for which you would like to retrieve the information.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "modifiedDate": {
            "$ref": "#/components/schemas/DateRangeFilter",
            "description": "A range filter against the last date the agreement was modified by user action (signing, canceling, etc.). The Modified value updates with every action until the agreement reaches a terminal status (Complete/Canceled/Expired). Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "items": {
              "$ref": "#/components/schemas/DateRangeFilter"
            }
          },
          "pageSize": {
            "default": 50,
            "description": "The maximum number of elements returned in the result set. The value must be greater than or equal to 1 and less than or equal to 100. If not set, the default value is 50.",
            "type": "integer"
          },
          "parentId": {
            "description": "A filter against case-sensitive parent id for which you would like to retrieve agreement asset information.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "participantEmail": {
            "description": "A filter against the email addresses of the agreement asset participants.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "queryableFields": {
            "description": "['title' or 'note' or 'message' or 'originalFileName' or 'email' or 'fullName' or 'jobTitle' or 'companyName' or 'recipientGroupName' or 'textFieldContent' or 'sharerFullName' or 'sharerRecipientGroupName' or 'externalId' or 'externalGroupId' or 'agreementId']: a list of field names against which string query specified in the 'query' field above is executed. For more information please refer here: <a href=\"https://helpx.adobe.com/sign/using/adobesign-search-users-agreements.html#NamePrefix\" target=\"_blank\">Field Name Prefix Query</a> (opens in separate window/tab).",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "role": {
            "description": "['SENDER' or 'CC' or 'SIGNER' or 'APPROVER' or 'FORM_FILLER' or 'ACCEPTOR' or 'CERTIFIED_RECIPIENT' or 'DELEGATE_TO_SIGNER' or 'DELEGATE_TO_APPROVER' or 'DELEGATE_TO_FORM_FILLER' or 'DELEGATE_TO_ACCEPTOR' or 'DELEGATE_TO_CERTIFIED_RECIPIENT' or 'NOTARY_SIGNER' or 'SHARE' or 'OTHER']: a filter against the roles the user has on agreement assets.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "sortByField": {
            "description": "['CREATED_DATE' or 'MODIFIED_DATE' or 'EXPIRATION_DATE' or 'NAME' or 'STATUS' or 'SENDER']: defines the field by which the results will be ordered.",
            "type": "string"
          },
          "sortOrder": {
            "description": "['ASC' or 'DESC']: defines the sort order for the sortField field. Please note that for date sort fields agreements with missing date values for the sort field will always appear last, irrespective of sort order. For other types of sort fields agreements with missing values for the sort field appear last if order is ascending, and first if order is descending.",
            "type": "string"
          },
          "startIndex": {
            "default": 0,
            "description": "0-based first row (offset) of the search results to return. The value must be greater than or equal to 0 and less than 10,000. If not provided, the default value is 0 and returns results from the very fist row, without offset.",
            "type": "integer"
          },
          "status": {
            "description": "['WAITING_FOR_MY_SIGNATURE' or 'WAITING_FOR_MY_APPROVAL' or 'WAITING_FOR_MY_DELEGATION' or 'WAITING_FOR_MY_ACKNOWLEDGEMENT' or 'WAITING_FOR_MY_ACCEPTANCE' or 'WAITING_FOR_MY_FORM_FILLING' or 'WAITING_FOR_PREFILL' or 'WAITING_FOR_AUTHORING' or 'WAITING_FOR_PREFILL' or 'OUT_FOR_SIGNATURE' or 'OUT_FOR_APPROVAL' or 'OUT_FOR_DELIVERY' or 'OUT_FOR_ACCEPTANCE' or 'OUT_FOR_FORM_FILLING' or 'SIGNED' or 'APPROVED' or 'FORM_FILLED' or 'DELIVERED' or 'ACCEPTED' or 'ARCHIVED' or 'CANCELLED' or 'REMOVED' or 'EXPIRED' or 'AUTHORING' or 'ACTIVE' or 'DISABLED' or 'WAITING_FOR_NOTARIZATION' or  'ACCEPT_BEFORE_NOTARIZATION' or 'OTHER']: a filter against the detailed status of the agreement asset. <b>Please note that PARTIAL and DRAFT agreements are not supported for search.</b>",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "subTypes": {
            "description": "['DOCUMENT' or 'FORM_FIELD_LAYER']: a filter against the agreement asset sub types. Only agreement assets with type LIBRARY_TEMPLATE currently have this field populated.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "type": {
            "description": "['AGREEMENT' or 'MEGASIGN_CHILD' or 'WIDGET_INSTANCE' or 'MEGASIGN_PARENT' or 'LIBRARY_TEMPLATE' or 'WIDGET']: a filter against the agreement asset type.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "userId": {
            "description": "A filter against the user id for account sharing.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "visibility": {
            "description": "['SHOW_VISIBLE' or 'SHOW_HIDDEN' or 'SHOW_ALL']: a filter indicating the visibility level of agreements that get returned in the response. SHOW_VISIBLE by default.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "AgreementAssetsResult": {
        "properties": {
          "createdDate": {
            "description": "The date on which the agreement asset was created. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time.",
            "type": "string"
          },
          "expirationDate": {
            "description": "The date on which the agreement asset expires and needs to be signed before it. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time.",
            "type": "string"
          },
          "externalId": {
            "description": "An arbitrary value from your system, which can be specified at sending time and then later returned or queried.",
            "type": "string"
          },
          "groupId": {
            "description": "Unique identifier of the group associated with the owner of the view of the agreement asset.",
            "type": "string"
          },
          "hidden": {
            "description": "True if agreement asset is hidden for the user.",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement asset.",
            "type": "string"
          },
          "modifiedDate": {
            "description": "The last date the agreement was modified by user action (signing, canceling, etc.). The Modified value updates with every action until the agreement reaches a terminal status (Complete/Canceled/Expired). Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time.",
            "type": "string"
          },
          "name": {
            "description": "Name of the agreement asset.",
            "type": "string"
          },
          "parentId": {
            "description": "the parent id of a bulk send child *OR* the originating id of a web form agreement instance.",
            "type": "string"
          },
          "participantList": {
            "description": "List of all participants for the agreement asset except where the document view owner, i.e. API caller, is a participant. Fields related to the document view owner ('userId', 'groupId', 'role', 'status', 'hidden') and their role, if any, as participant are included at the top level of AgreementAssetsResult object.",
            "items": {
              "$ref": "#/components/schemas/SearchResultParticipant"
            },
            "type": "array"
          },
          "role": {
            "description": "['SENDER' or 'CC' or 'SIGNER' or 'APPROVER' or 'FORM_FILLER' or 'ACCEPTOR' or 'CERTIFIED_RECIPIENT' or 'DELEGATE_TO_SIGNER' or 'DELEGATE_TO_APPROVER' or 'DELEGATE_TO_FORM_FILLER' or 'DELEGATE_TO_ACCEPTOR' or 'DELEGATE_TO_CERTIFIED_RECIPIENT' or 'NOTARY_SIGNER' or 'SHARE' or 'OTHER']: The roles user has on agreement assets.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "status": {
            "description": "['WAITING_FOR_MY_SIGNATURE' or 'WAITING_FOR_MY_APPROVAL' or 'WAITING_FOR_MY_DELEGATION' or 'WAITING_FOR_MY_ACKNOWLEDGEMENT' or 'WAITING_FOR_MY_ACCEPTANCE' or 'WAITING_FOR_MY_FORM_FILLING' or 'WAITING_FOR_PREFILL' or 'WAITING_FOR_AUTHORING' or 'WAITING_FOR_PREFILL' or 'OUT_FOR_SIGNATURE' or 'OUT_FOR_APPROVAL' or 'OUT_FOR_DELIVERY' or 'OUT_FOR_ACCEPTANCE' or 'OUT_FOR_FORM_FILLING' or 'SIGNED' or 'APPROVED' or 'FORM_FILLED' or 'DELIVERED' or 'ACCEPTED' or 'ARCHIVED' or 'CANCELLED' or 'REMOVED' or 'EXPIRED' or 'AUTHORING' or 'ACTIVE' or 'DISABLED' or 'WAITING_FOR_NOTARIZATION' or  'ACCEPT_BEFORE_NOTARIZATION' or 'OTHER']: detailed status of the agreement asset. <b>Please note that PARTIAL and DRAFT agreements are not supported for search.</b>",
            "type": "string"
          },
          "subTypes": {
            "description": "['DOCUMENT' or 'FORM_FIELD_LAYER']: The sub types of the agreement asset. Only agreement assets with type LIBRARY_TEMPLATE currently have this field populated.",
            "items": {},
            "type": "array"
          },
          "type": {
            "description": "['AGREEMENT' or 'MEGASIGN_CHILD' or 'WIDGET_INSTANCE' or 'MEGASIGN_PARENT' or 'LIBRARY_TEMPLATE' or 'WIDGET']: The kind of the agreement asset.",
            "type": "string"
          },
          "userId": {
            "description": "Unique identifier of the owner of the view of the agreement asset.",
            "type": "string"
          },
          "workflowId": {
            "description": "The identifier of custom workflow which defines the routing path of an agreement.",
            "type": "string"
          }
        },
        "required": [
          "groupId",
          "hidden",
          "id",
          "name",
          "role",
          "status",
          "type",
          "userId"
        ],
        "type": "object"
      },
      "AgreementAssetsResults": {
        "properties": {
          "agreementAssetsResultList": {
            "description": "An array of AgreementAssetsResult items.",
            "items": {
              "$ref": "#/components/schemas/AgreementAssetsResult"
            },
            "type": "array"
          },
          "searchPageInfo": {
            "$ref": "#/components/schemas/SearchPageInfo",
            "description": "Pagination information for navigating through the response.",
            "items": {
              "$ref": "#/components/schemas/SearchPageInfo"
            }
          },
          "status": {
            "$ref": "#/components/schemas/SearchStatusInfo",
            "description": "Status of the search response for AGREEMENT_ASSETS scope.",
            "items": {
              "$ref": "#/components/schemas/SearchStatusInfo"
            }
          },
          "totalHits": {
            "description": "Total number of search results for AGREEMENT_ASSETS scope.",
            "type": "integer"
          }
        },
        "required": [
          "agreementAssetsResultList",
          "searchPageInfo",
          "status",
          "totalHits"
        ],
        "type": "object"
      },
      "DateRange": {
        "properties": {
          "gt": {
            "description": "The maximum allowed date-time that is allowed in the result set. Values for each range field must adhere to the ISO-8601 standard. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "type": "string"
          },
          "lt": {
            "description": "The minimum allowed date-time that is allowed in the result set. Values for each range field must adhere to the ISO-8601 standard. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "type": "string"
          },
          "max": {
            "description": "The maximum allowed date-time that is allowed in the result set. Values for each range field must adhere to the ISO-8601 standard. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "type": "string"
          },
          "min": {
            "description": "The minimum allowed date-time that is allowed in the result set. Values for each range field must adhere to the ISO-8601 standard. Range terms can be defined as less-than/greater-than or min/max. If terms are mixed the JSON will be considered malformed.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "DateRangeFilter": {
        "properties": {
          "range": {
            "$ref": "#/components/schemas/DateRange",
            "description": "Unique identifier of the user this agreement view is associated with.",
            "items": {
              "$ref": "#/components/schemas/DateRange"
            }
          }
        },
        "required": [
          "range"
        ],
        "type": "object"
      },
      "SearchPageInfo": {
        "properties": {
          "nextIndex": {
            "description": "0-based row number of the last returned result + 1. Set to 0 (or not set) if there are no more search results. Set to NULL if all search results were returned and there are no more search results for the next page.",
            "type": "integer"
          }
        },
        "required": [
          "nextIndex"
        ],
        "type": "object"
      },
      "SearchRequestBody": {
        "properties": {
          "agreementAssetsCriteria": {
            "$ref": "#/components/schemas/AgreementAssetsCriteria",
            "description": "Contains all of the necessary information about filtering and sorting agreement assets search results.",
            "items": {
              "$ref": "#/components/schemas/AgreementAssetsCriteria"
            }
          },
          "query": {
            "description": "This field provides text search capability against terms in the field values of agreements that are visible to the user making the request. To find more about how text searching works please refer here: <a href=\"https://helpx.adobe.com/sign/using/adobesign-search-users-agreements.html#HowSearchWorks\" target=\"_blank\">How Adobe Sign Search Works</a> (opens in separate window/tab).",
            "type": "string"
          },
          "scope": {
            "description": "['AGREEMENT_ASSETS']: a resource scope. 'AGREEMENT_ASSETS' is the only value that is supported right now which includes the following resources: agreements, megaSigns, libraryDocuments and widgets.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "scope"
        ],
        "type": "object"
      },
      "SearchResultParticipant": {
        "properties": {
          "company": {
            "description": "The name of the company of the participant, if available.",
            "type": "string"
          },
          "email": {
            "description": "The email of the user.",
            "type": "string"
          },
          "fullName": {
            "description": "The full name of the participant, if available.",
            "type": "string"
          },
          "participantSetNames": {
            "description": "The names of the participant sets. Returned only if the participant belongs to any participant sets.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "role": {
            "description": "['ORIGINATOR' or 'CC' or 'SENDER' or 'SIGNER' or 'APPROVER' or 'FORM_FILLER' or 'ACCEPTOR' or 'CERTIFIED_RECIPIENT' or 'DELEGATE_TO_SIGNER' or 'DELEGATE_TO_APPROVER' or 'DELEGATE_TO_FORM_FILLER' or 'DELEGATE_TO_ACCEPTOR' or 'DELEGATE_TO_CERTIFIED_RECIPIENT' or 'NOTARY_SIGNER' or 'SHARE' or 'OTHER']: all roles the participant has on the agreement asset.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "required": [
          "email",
          "role"
        ],
        "type": "object"
      },
      "SearchResults": {
        "properties": {
          "agreementAssetsResults": {
            "$ref": "#/components/schemas/AgreementAssetsResults",
            "description": "Object that contains AGREEMENT_ASSETS search results.",
            "items": {
              "$ref": "#/components/schemas/AgreementAssetsResults"
            }
          },
          "totalHits": {
            "description": "Total number of search results across all scopes.",
            "type": "integer"
          }
        },
        "required": [
          "totalHits"
        ],
        "type": "object"
      },
      "SearchStatusInfo": {
        "properties": {
          "code": {
            "description": "Status code returned for the search response.",
            "type": "integer"
          },
          "message": {
            "description": "Descriptive message corresponding to the status code.",
            "type": "string"
          }
        },
        "required": [
          "code",
          "message"
        ],
        "type": "object"
      },
      "TransientDocumentResponse": {
        "properties": {
          "transientDocumentId": {
            "description": "The unique identifier of the uploaded document that can be used in an agreement or a bulk send or web form creation call",
            "type": "string"
          }
        },
        "required": [
          "transientDocumentId"
        ],
        "type": "object"
      },
      "BooleanSettingInfo": {
        "properties": {
          "inherited": {
            "description": "True if setting is inherited from its group or account value.",
            "type": "boolean"
          },
          "value": {
            "description": "Value of the setting.",
            "type": "boolean"
          }
        },
        "required": [
          "value"
        ],
        "type": "object"
      },
      "CommonViewConfiguration1": {
        "properties": {
          "autoLoginUser": {
            "description": "Auto LogIn Flag. If true, the URL returned will automatically log the user in. If false, the URL returned will require the credentials. By default its value is false",
            "type": "boolean"
          },
          "frameParent": {
            "description": "An optional field to provide the comma-separated list of parent domain urls where the returned URLs may be iframed. If provided with non-empty and valid list of parent domain urls, it will be used to allow framing for the same. By default the value is null and the Acrobat Sign pages will not be viewable in an iframe.",
            "type": "string"
          },
          "noChrome": {
            "description": "No Chrome Flag. If true, the embedded page is shown without a navigation header or footer. If false, the standard page header and footer will be present. By default its value is false",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "DetailedUserInfo": {
        "properties": {
          "accountId": {
            "description": "The account id of the user. This will be ignored as part of PUT calls.",
            "type": "string"
          },
          "accountType": {
            "description": "Type of account to which the user belongs (null if no account). If provided in POST or PUT it will be ignored.",
            "enum": [
              "FREE",
              "PRO",
              "TEAM",
              "TEAM_TRIAL",
              "ENTERPRISE",
              "ENTERPRISE_TRIAL",
              "GLOBAL",
              "GLOBAL_TRIAL"
            ],
            "type": "string"
          },
          "company": {
            "description": "The name of company of the user",
            "type": "string"
          },
          "createdDate": {
            "description": "The date the user was created. If provided in POST or PUT it will be ignored",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "The email address of the user",
            "type": "string"
          },
          "firstName": {
            "description": "The first name of the user",
            "type": "string"
          },
          "id": {
            "description": "A unique identifier of the user resource for REST APIs as issued by Acrobat Sign.",
            "type": "string"
          },
          "initials": {
            "description": "The initials of the user",
            "type": "string"
          },
          "isAccountAdmin": {
            "description": "True if the user is account admin. This will be ignored as part of PUT calls.",
            "type": "boolean"
          },
          "lastName": {
            "description": "The last name of the user",
            "type": "string"
          },
          "locale": {
            "description": "The UI locale of the user",
            "type": "string"
          },
          "phone": {
            "description": "The phone number of the user",
            "type": "string"
          },
          "primaryGroupId": {
            "description": "Primary group in which the new user should be added. Default is the default group for the account the user is being added to. This will be ignored as part of PUT calls",
            "type": "string"
          },
          "status": {
            "description": "Status of the user. If provided in POST it will be ignored.",
            "enum": [
              "ACTIVE",
              "INACTIVE",
              "CREATED",
              "UNVERIFIED"
            ],
            "type": "string"
          },
          "title": {
            "description": "The job title of the user",
            "type": "string"
          }
        },
        "required": [
          "accountType",
          "email",
          "id",
          "isAccountAdmin",
          "status"
        ],
        "type": "object"
      },
      "SettingsInfo": {
        "properties": {
          "libaryDocumentCreationVisible": {
            "$ref": "#/components/schemas/BooleanSettingInfo",
            "description": "Can user create library documents?",
            "items": {
              "$ref": "#/components/schemas/BooleanSettingInfo"
            }
          },
          "sendRestrictedToWorkflows": {
            "$ref": "#/components/schemas/BooleanSettingInfo",
            "description": "Can user only create agreeements using workflows?",
            "items": {
              "$ref": "#/components/schemas/BooleanSettingInfo"
            }
          },
          "userCanSend": {
            "$ref": "#/components/schemas/BooleanSettingInfo",
            "description": "Can user send agreements for signature to others?",
            "items": {
              "$ref": "#/components/schemas/BooleanSettingInfo"
            }
          },
          "widgetCreationVisible": {
            "$ref": "#/components/schemas/BooleanSettingInfo",
            "description": "Can user create web forms?",
            "items": {
              "$ref": "#/components/schemas/BooleanSettingInfo"
            }
          }
        },
        "type": "object"
      },
      "UserCreationResponse": {
        "properties": {
          "userId": {
            "description": "The unique identifier for user in REST APIs. This identifier will not be compatible with any existing SOAP APIs and is different from user key that SOAP APIs provide and consume. userid being provided here and userkey that SOAP uses are different and the two can not be interchanged with each other",
            "type": "string"
          },
          "userStatus": {
            "description": "Status of the user",
            "enum": [
              "ACTIVE",
              "INACTIVE",
              "CREATED",
              "PENDING",
              "UNVERIFIED"
            ],
            "type": "string"
          }
        },
        "required": [
          "userStatus"
        ],
        "type": "object"
      },
      "UserEvent": {
        "description": "A JSON of one user event, null",
        "properties": {
          "adminUserId": {
            "description": "Account admin user ID",
            "type": "string"
          },
          "date": {
            "description": "The date of the user event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "event": {
            "description": "Type of user event",
            "enum": [
              "CREATED",
              "REGISTERED",
              "CHANGE_EMAIL",
              "CHANGE_PASSWORD",
              "VERIFICATION_EMAIL_SENT",
              "VERIFIED_EMAIL",
              "VERIFIED_BY_TRANSACTION",
              "SHARE_REQUESTED",
              "SHARE_ACCEPTED",
              "SHARE_DECLINED",
              "SHARE_CANCELLED",
              "SHARE_INVITED",
              "MANUALLY_VERIFIED",
              "ACCOUNT_TYPE_UPDATED",
              "MAX_LOGIN_FAILURES_EXCEEDED",
              "MAX_PASSWORD_CHANGE_FAILURES_EXCEEDED",
              "PASSWORD_RESET",
              "EMAIL_BOUNCED",
              "SHARE_CREATED_BY_MASTER",
              "DELEGATION_PERMISSIONS_UPDATED",
              "MARKED_AS_GROUP_EMAIL",
              "MARKED_AS_INDIVIDUAL_EMAIL",
              "VERIFICATION_EMAIL_REQUESTED_BY_ADMIN",
              "REMOVED_FROM_GROUP",
              "REMOVED_FROM_ACCOUNT",
              "LOGO_UPLOADED",
              "REACTIVATED",
              "API_ENABLED",
              "API_DISABLED",
              "USER_ACCOUNT_UPDATED",
              "USER_GROUP_UPDATED",
              "LOGIN",
              "FORGET_PASSWORD_REQUESTED",
              "ACCOUNT_CHANGED",
              "MODIFIED",
              "ACCOUNT_SETUP_EMAIL_REQUESTED_BY_ADMIN",
              "ACCOUNT_SETUP_EMAIL_SENT",
              "ARCHIVED",
              "USER_ADDED_TO_GROUP",
              "ACCOUNT_ADMIN_STATUS_CHANGED",
              "GROUP_ADMIN_STATUS_CHANGED",
              "PRIMARY_GROUP_CHANGED"
            ],
            "type": "string"
          },
          "fromGroupId": {
            "description": "The identifier for the group where user is moved from.",
            "type": "string"
          },
          "participationId": {
            "description": "The identifier for participation.",
            "type": "string"
          },
          "toGroupId": {
            "description": "The identifier for the group where user is moved to.",
            "type": "string"
          },
          "userEventId": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "userId": {
            "description": "The user ID of the signing participant.",
            "type": "string"
          }
        },
        "required": [
          "adminUserId",
          "date",
          "userId"
        ],
        "type": "object"
      },
      "UserEventsList": {
        "description": "A JSON list of all user events",
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userEvents": {
            "description": "List of user events",
            "items": {
              "$ref": "#/components/schemas/UserEvent"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userEvents"
        ],
        "type": "object"
      },
      "UserGroupInfo": {
        "properties": {
          "createdDate": {
            "description": "Date group was created",
            "format": "date",
            "type": "string"
          },
          "id": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "isGroupAdmin": {
            "description": "True if user is group admin.",
            "type": "boolean"
          },
          "isPrimaryGroup": {
            "description": "True if the group is the user's primary group.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the group. This will be ignored as part of PUT call.",
            "type": "string"
          },
          "settings": {
            "$ref": "#/components/schemas/SettingsInfo",
            "description": "List of some group membership settings.",
            "items": {
              "$ref": "#/components/schemas/SettingsInfo"
            }
          },
          "status": {
            "description": "Status of the group membership",
            "enum": [
              "ACTIVE",
              "DELETED"
            ],
            "type": "string"
          }
        },
        "required": [
          "id",
          "isGroupAdmin",
          "isPrimaryGroup",
          "status"
        ],
        "type": "object"
      },
      "UserGroupsInfo": {
        "properties": {
          "groupInfoList": {
            "description": "The list of groups for given user.",
            "items": {
              "$ref": "#/components/schemas/UserGroupInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "groupInfoList"
        ],
        "type": "object"
      },
      "UserInfo": {
        "properties": {
          "accountId": {
            "description": "The account id of the user. This will be ignored as part of PUT calls.",
            "type": "string"
          },
          "company": {
            "description": "The name of company of the user",
            "type": "string"
          },
          "email": {
            "description": "The email address of the user",
            "type": "string"
          },
          "firstName": {
            "description": "The first name of the user",
            "type": "string"
          },
          "id": {
            "description": "A unique identifier of the user resource for REST APIs as issued by Acrobat Sign.",
            "type": "string"
          },
          "isAccountAdmin": {
            "description": "True if user is account admin",
            "type": "boolean"
          },
          "lastName": {
            "description": "The last name of the user",
            "type": "string"
          }
        },
        "required": [
          "email",
          "id",
          "isAccountAdmin"
        ],
        "type": "object"
      },
      "UserLocaleInfo": {
        "properties": {
          "locale": {
            "description": "The UI locale of the user",
            "enum": [
              "[en_US, in_ID, ca_ES, cs_CZ, da_DK, de_DE, en_GB, en_US_Echosign, es_ES, eu_ES, fr_FR, hr_HR, is_IS, it_IT, hu_HU, ms_MY, nl_NL, no_NO, nb_NO, nn_NO, pl_PL, pt_BR, pt_PT, ro_RO, sk_SK, sl_SI, fi_FI, sv_SE, vi_VN, tr_TR, ru_RU, uk_UA, th_TH, ja_JP, zh_CN, zh_TW, ko_KR, zz_ZZ]"
            ],
            "type": "string"
          }
        },
        "type": "object"
      },
      "UserStateInfo": {
        "properties": {
          "comment": {
            "description": "An optional comment describing why you want to activate/deactivate a given user",
            "type": "string"
          },
          "state": {
            "description": "The state to which the user is to be updated. The valid states for this variable is currently, ACTIVE and INACTIVE",
            "enum": [
              "ACTIVE",
              "INACTIVE"
            ],
            "type": "string"
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "UserStatusUpdateResponse": {
        "properties": {
          "code": {
            "description": "The result of the attempt to activate or deactivate the user",
            "enum": [
              "ALREADY_ACTIVE",
              "ALREADY_INACTIVE",
              "OK",
              "RESET_PASSWORD_WORKFLOW_INITIATED",
              "SET_PASSWORD_WORKFLOW_INITIATED"
            ],
            "type": "string"
          },
          "message": {
            "description": "String result message if there was no error",
            "type": "string"
          },
          "state": {
            "description": "A status value showing the result of this operation",
            "enum": [
              "ACTIVE",
              "INACTIVE",
              "CREATED",
              "PENDING",
              "UNVERIFIED"
            ],
            "type": "string"
          }
        },
        "required": [
          "code",
          "state"
        ],
        "type": "object"
      },
      "UserView": {
        "properties": {
          "embeddedCode": {
            "description": "Embedded code of url of resource ",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration of user url ",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "Name of the requested user view",
            "enum": [
              "MANAGE",
              "ACCOUNT_SETTINGS",
              "USER_PROFILE",
              "ALL"
            ],
            "type": "string"
          },
          "url": {
            "description": "Url of resource location",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "UserViewInfo": {
        "properties": {
          "commonViewConfiguration": {
            "$ref": "#/components/schemas/CommonViewConfiguration1",
            "description": "Common view configuration for all the available views",
            "items": {
              "$ref": "#/components/schemas/CommonViewConfiguration"
            }
          },
          "name": {
            "description": "Name of the requested user view",
            "enum": [
              "MANAGE",
              "ACCOUNT_SETTINGS",
              "USER_PROFILE",
              "ALL"
            ],
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "UserViewResponse": {
        "properties": {
          "userViewList": {
            "description": "List of user views",
            "items": {
              "$ref": "#/components/schemas/UserView"
            },
            "type": "array"
          }
        },
        "required": [
          "userViewList"
        ],
        "type": "object"
      },
      "UsersInfo": {
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userInfoList": {
            "description": "The list of users in the account.",
            "items": {
              "$ref": "#/components/schemas/UserInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userInfoList"
        ],
        "type": "object"
      },
      "UserWebhook": {
        "properties": {
          "applicationDisplayName": {
            "description": "The display name of the application through which webhook is created",
            "type": "string"
          },
          "applicationName": {
            "description": "The name of the application through which webhook is created",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the webhook. Will only be returned in GET request. Can't be modified in PUT request",
            "type": "string"
          },
          "lastModified": {
            "description": "Timestamp when the webhook was last updated. Will only be returned in GET request. Can't be modified in PUT request",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the webhook",
            "type": "string"
          },
          "problemNotificationEmails": {
            "description": "Emails of existing Acrobat Sign users to receive warnings and disablement notifications, only Admins can set this.",
            "items": {
              "$ref": "#/components/schemas/WebhookProblemNotificationEmails"
            },
            "type": "array"
          },
          "resourceId": {
            "description": "Id of the resource type for which you want to create webhook. Provide agreementId if webhook needs to be created for an agreement. Similarly, widgetId if webhook needs to be created for a web form, megaSignId if webhook needs to be created for a bulk send and libraryDocumentId if webhook needs to be created for a library document. Need to specify only if scope is 'RESOURCE'. Can't be modified in PUT request",
            "type": "string"
          },
          "resourceType": {
            "description": "The resource for which you want to create webhook. Need to specify only if scope is 'RESOURCE'. Can't be modified in PUT request. The possible values are AGREEMENT, WIDGET,  MEGASIGN AND LIBRARY_DOCUMENT",
            "enum": [
              "AGREEMENT",
              "WIDGET",
              "MEGASIGN",
              "LIBRARY_DOCUMENT"
            ],
            "type": "string"
          },
          "scope": {
            "description": "Scope of webhook. Can't be modified in PUT request. The possible values are ACCOUNT, GROUP, USER or RESOURCE",
            "enum": [
              "ACCOUNT",
              "GROUP",
              "USER",
              "RESOURCE"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the webhook. Determines whether the webhook will be actually triggered. Default: ACTIVE, if ACTIVE, this webhook will receive event requests. If INACTIVE, this webhook will not receive event requests. Can't provide status in POST/PUT requests.",
            "enum": [
              "ACTIVE",
              "INACTIVE"
            ],
            "type": "string"
          },
          "webhookSubscriptionEvents": {
            "description": "Determines events for which the webhook is triggered. The possible values are <br> AGREEMENT_CREATED : When an agreement is created <br>,\nAGREEMENT_ACTION_DELEGATED : When an agreement is delegated <br>,\nAGREEMENT_RECALLED : When an agreement is recalled <br>,\nAGREEMENT_REJECTED : When an agreement is rejected <br>,\nAGREEMENT_RESTARTED : When an agreement is restarted <br>,\nAGREEMENT_EXPIRED : When an agreement expires <br>,\nAGREEMENT_ACTION_COMPLETED : When an agreement action is completed <br>,\nAGREEMENT_WORKFLOW_COMPLETED : When an agreement workflow is completed <br>,\nAGREEMENT_EMAIL_VIEWED : When an agreement's email is viewed <br>,\nAGREEMENT_MODIFIED : When an agreement is modified <br>,\nAGREEMENT_SHARED : When an agreement is shared <br>,\nAGREEMENT_READY_TO_VAULT : When an agreement is ready to vault <br>,\nAGREEMENT_VAULTED : When an agreement is vaulted <br>,\nAGREEMENT_ACTION_REQUESTED : When an agreement action is requested <br>,\nAGREEMENT_ACTION_REPLACED_SIGNER : When signer is replaced for an agreement <br>,\nAGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM : When an agreement is auto-cancelled due to conversion problem <br>,\nAGREEMENT_DOCUMENTS_DELETED : When an agreement documents are deleted <br>,\nAGREEMENT_EMAIL_BOUNCED : When an agreement email gets bounced <br>,\nAGREEMENT_KBA_AUTHENTICATED : When an agreement KBA is authenticated <br>,\nAGREEMENT_OFFLINE_SYNC : When an agreement is synced offline <br>,\nAGREEMENT_USER_ACK_AGREEMENT_MODIFIED : User Acknowledgement when an agreement is modified <br>,\nAGREEMENT_WEB_IDENTITY_AUTHENTICATED : When an agreement web identity is authenticated <br>,\nAGREEMENT_READY_TO_NOTARIZE: When an agreement is ready for notarization <br>,\nAGREEMENT_EXPIRATION_UPDATED: When agreement expiration time is updated <br>,\nAGREEMENT_REMINDER_SENT: When an agreement reminder is sent <br>,\nAGREEMENT_SIGNER_NAME_CHANGED_BY_SIGNER : When a signer changes his name at signing <br>,\nAGREEMENT_REMINDER_INITIATED: When an agreement reminder is initiated <br>,\nAGREEMENT_ALL : All the supported agreement events for Webhooks <br>,\nMEGASIGN_CREATED : When a bulk send is created <br>,\nMEGASIGN_RECALLED : When a bulk send is recalled <br>,\nMEGASIGN_SHARED : When a bulk send is shared <br>,\nMEGASIGN_REMINDER_SENT: When a bulk send reminder is sent <br>,\nMEGASIGN_REMINDER_INITIATED: When a bulk send reminder is initiated <br>,\nMEGASIGN_ALL : All the supported Send in Bulk events for Webhooks <br>,\nWIDGET_CREATED : When a web form is created <br>,\nWIDGET_MODIFIED : When a web form is modified <br>,\nWIDGET_SHARED : When a web form is shared <br>,\nWIDGET_ENABLED : When a web form is enabled <br>,\nWIDGET_DISABLED : When a web form is disabled <br>,\nWIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM : When a web form is auto-cancelled due to conversion problem <br>,\nWIDGET_ALL : All the supported web form events for Webhooks <br>,\nLIBRARY_DOCUMENT_CREATED : When a library document  is created <br>,\nLIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM : When a library document is auto-cancelled due to conversion problem <br>,\nLIBRARY_DOCUMENT_MODIFIED : When a library document is modified <br>,\nLIBRARY_DOCUMENT_ALL : All the supported library document  events for Webhooks",
            "items": {
              "enum": [
                "AGREEMENT_CREATED",
                "AGREEMENT_ACTION_DELEGATED",
                "AGREEMENT_RECALLED",
                "AGREEMENT_REJECTED",
                "AGREEMENT_EXPIRED",
                "AGREEMENT_ACTION_COMPLETED",
                "AGREEMENT_WORKFLOW_COMPLETED",
                "AGREEMENT_RESTARTED",
                "AGREEMENT_EMAIL_VIEWED",
                "AGREEMENT_MODIFIED",
                "AGREEMENT_SHARED",
                "AGREEMENT_READY_TO_VAULT",
                "AGREEMENT_VAULTED",
                "AGREEMENT_ACTION_REQUESTED",
                "AGREEMENT_ACTION_REPLACED_SIGNER",
                "AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM",
                "AGREEMENT_DOCUMENTS_DELETED",
                "AGREEMENT_EMAIL_BOUNCED",
                "AGREEMENT_KBA_AUTHENTICATED",
                "AGREEMENT_OFFLINE_SYNC",
                "AGREEMENT_USER_ACK_AGREEMENT_MODIFIED",
                "AGREEMENT_WEB_IDENTITY_AUTHENTICATED",
                "AGREEMENT_READY_TO_NOTARIZE",
                "AGREEMENT_EXPIRATION_UPDATED",
                "AGREEMENT_REMINDER_SENT",
                "AGREEMENT_SIGNER_NAME_CHANGED_BY_SIGNER",
                "AGREEMENT_REMINDER_INITIATED",
                "AGREEMENT_ALL",
                "MEGASIGN_CREATED",
                "MEGASIGN_RECALLED",
                "MEGASIGN_SHARED",
                "MEGASIGN_REMINDER_SENT",
                "MEGASIGN_REMINDER_INITIATED",
                "MEGASIGN_ALL",
                "WIDGET_CREATED",
                "WIDGET_MODIFIED",
                "WIDGET_SHARED",
                "WIDGET_ENABLED",
                "WIDGET_DISABLED",
                "WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM",
                "WIDGET_ALL",
                "LIBRARY_DOCUMENT_CREATED",
                "LIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM",
                "LIBRARY_DOCUMENT_MODIFIED",
                "LIBRARY_DOCUMENT_ALL"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "webhookUrlInfo": {
            "$ref": "#/components/schemas/WebhookUrlInfo",
            "description": "Info of webhook url",
            "items": {
              "$ref": "#/components/schemas/WebhookUrlInfo"
            }
          }
        },
        "required": [
          "id",
          "name",
          "scope",
          "webhookSubscriptionEvents",
          "webhookUrlInfo"
        ],
        "type": "object"
      },
      "UserWebhooks": {
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userWebhookList": {
            "description": "An array of web form items",
            "items": {
              "$ref": "#/components/schemas/UserWebhook"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userWebhookList"
        ],
        "type": "object"
      },
      "WebhookAgreementEvents": {
        "properties": {
          "includeDetailedInfo": {
            "description": "Determines whether agreement detailed info will be returned in the response payload",
            "type": "boolean"
          },
          "includeDocumentsInfo": {
            "description": "Determines whether document info will be returned in the response payload",
            "type": "boolean"
          },
          "includeParticipantsInfo": {
            "description": "Determines whether participants info will be returned in the response payload",
            "type": "boolean"
          },
          "includeSignedDocuments": {
            "description": "Determines whether documents will be returned in webhook response payload. If set to true, signed document will be returned in base 64 encoded format in JSON when signing is complete",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "WebhookConditionalParams": {
        "properties": {
          "webhookAgreementEvents": {
            "$ref": "#/components/schemas/WebhookAgreementEvents",
            "description": "Conditional parameters for webhook agreement events",
            "items": {
              "$ref": "#/components/schemas/WebhookAgreementEvents"
            }
          },
          "webhookLibraryDocumentEvents": {
            "$ref": "#/components/schemas/WebhookLibraryDocumentEvents",
            "description": "Conditional parameters for webhook library document events",
            "items": {
              "$ref": "#/components/schemas/WebhookLibraryDocumentEvents"
            }
          },
          "webhookMegaSignEvents": {
            "$ref": "#/components/schemas/WebhookMegaSignEvents",
            "description": "Conditional parameters for webhook Send in Bulk events",
            "items": {
              "$ref": "#/components/schemas/WebhookMegaSignEvents"
            }
          },
          "webhookWidgetEvents": {
            "$ref": "#/components/schemas/WebhookWidgetEvents",
            "description": "Conditional parameters for webhook web form events",
            "items": {
              "$ref": "#/components/schemas/WebhookWidgetEvents"
            }
          }
        },
        "type": "object"
      },
      "WebhookCreationResponse": {
        "description": "A JSON  that contains the id of the newly created webhook",
        "properties": {
          "id": {
            "description": "An identifier of the webhook resource created",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WebhookInfo": {
        "properties": {
          "applicationDisplayName": {
            "description": "The display name of the application through which webhook is created",
            "type": "string"
          },
          "applicationName": {
            "description": "The name of the application through which webhook is created",
            "type": "string"
          },
          "created": {
            "description": "Timestamp when the webhook was created. Will only be returned in GET request. Can't be modified in PUT request",
            "format": "date",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the webhook. Will only be returned in GET request. Can't be modified in PUT request",
            "type": "string"
          },
          "lastModified": {
            "description": "Timestamp when the webhook was last updated. Will only be returned in GET request. Can't be modified in PUT request",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the webhook",
            "type": "string"
          },
          "problemNotificationEmails": {
            "description": "Emails of existing Acrobat Sign users to receive warnings and disablement notifications, only Admins can set this.",
            "items": {
              "$ref": "#/components/schemas/WebhookProblemNotificationEmails"
            },
            "type": "array"
          },
          "resourceId": {
            "description": "Id of the resource type for which you want to create webhook. Provide agreementId if webhook needs to be created for an agreement. Similarly, widgetId if webhook needs to be created for a web form, megaSignId if webhook needs to be created for a bulk send and libraryDocumentId if webhook needs to be created for a library document. Need to specify only if scope is 'RESOURCE'. Can't be modified in PUT request",
            "type": "string"
          },
          "resourceType": {
            "description": "The resource for which you want to create webhook. Need to specify only if scope is 'RESOURCE'. Can't be modified in PUT request. The possible values are AGREEMENT, WIDGET,  MEGASIGN AND LIBRARY_DOCUMENT",
            "enum": [
              "AGREEMENT",
              "WIDGET",
              "MEGASIGN",
              "LIBRARY_DOCUMENT"
            ],
            "type": "string"
          },
          "scope": {
            "description": "Scope of webhook. Can't be modified in PUT request. The possible values are ACCOUNT, GROUP, USER or RESOURCE",
            "enum": [
              "ACCOUNT",
              "GROUP",
              "USER",
              "RESOURCE"
            ],
            "type": "string"
          },
          "state": {
            "description": "The state in which the webhook should be created",
            "enum": [
              "ACTIVE"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the webhook. Determines whether the webhook will be actually triggered. Default: ACTIVE, if ACTIVE, this webhook will receive event requests. If INACTIVE, this webhook will not receive event requests. Can't provide status in POST/PUT requests.",
            "enum": [
              "ACTIVE",
              "INACTIVE"
            ],
            "type": "string"
          },
          "webhookConditionalParams": {
            "$ref": "#/components/schemas/WebhookConditionalParams",
            "description": "Conditions which webhook creator can specify for the payload while creating or updating a webhook",
            "items": {
              "$ref": "#/components/schemas/WebhookConditionalParams"
            }
          },
          "webhookSubscriptionEvents": {
            "description": "Determines events for which the webhook is triggered. The possible values are <br> AGREEMENT_CREATED : When an agreement is created <br>,\nAGREEMENT_ACTION_DELEGATED : When an agreement is delegated <br>,\nAGREEMENT_RECALLED : When an agreement is recalled <br>,\nAGREEMENT_REJECTED : When an agreement is rejected <br>,\nAGREEMENT_RESTARTED : When an agreement is restarted <br>,\nAGREEMENT_EXPIRED : When an agreement expires <br>,\nAGREEMENT_ACTION_COMPLETED : When an agreement action is completed <br>,\nAGREEMENT_WORKFLOW_COMPLETED : When an agreement workflow is completed <br>,\nAGREEMENT_EMAIL_VIEWED : When an agreement's email is viewed <br>,\nAGREEMENT_MODIFIED : When an agreement is modified <br>,\nAGREEMENT_SHARED : When an agreement is shared <br>,\nAGREEMENT_READY_TO_VAULT : When an agreement is ready to vault <br>,\nAGREEMENT_VAULTED : When an agreement is vaulted <br>,\nAGREEMENT_ACTION_REQUESTED : When an agreement action is requested <br>,\nAGREEMENT_ACTION_REPLACED_SIGNER : When signer is replaced for an agreement <br>,\nAGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM : When an agreement is auto-cancelled due to conversion problem <br>,\nAGREEMENT_DOCUMENTS_DELETED : When an agreement documents are deleted <br>,\nAGREEMENT_EMAIL_BOUNCED : When an agreement email gets bounced <br>,\nAGREEMENT_KBA_AUTHENTICATED : When an agreement KBA is authenticated <br>,\nAGREEMENT_OFFLINE_SYNC : When an agreement is synced offline <br>,\nAGREEMENT_USER_ACK_AGREEMENT_MODIFIED : User Acknowledgement when an agreement is modified <br>,\nAGREEMENT_WEB_IDENTITY_AUTHENTICATED : When an agreement web identity is authenticated <br>,\nAGREEMENT_READY_TO_NOTARIZE: When an agreement is ready for notarization <br>,\nAGREEMENT_EXPIRATION_UPDATED: When agreement expiration time is updated <br>,\nAGREEMENT_REMINDER_SENT: When an agreement reminder is sent <br>,\nAGREEMENT_SIGNER_NAME_CHANGED_BY_SIGNER : When a signer changes his name at signing <br>,\nAGREEMENT_REMINDER_INITIATED: When an agreement reminder is initiated <br>,\nAGREEMENT_ALL : All the supported agreement events for Webhooks <br>,\nMEGASIGN_CREATED : When a bulk send is created <br>,\nMEGASIGN_RECALLED : When a bulk send is recalled <br>,\nMEGASIGN_SHARED : When a bulk send is shared <br>,\nMEGASIGN_REMINDER_SENT: When a bulk send reminder is sent <br>,\nMEGASIGN_REMINDER_INITIATED: When a bulk send reminder is initiated <br>,\nMEGASIGN_ALL : All the supported Send in Bulk events for Webhooks <br>,\nWIDGET_CREATED : When a web form is created <br>,\nWIDGET_MODIFIED : When a web form is modified <br>,\nWIDGET_SHARED : When a web form is shared <br>,\nWIDGET_ENABLED : When a web form is enabled <br>,\nWIDGET_DISABLED : When a web form is disabled <br>,\nWIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM : When a web form is auto-cancelled due to conversion problem <br>,\nWIDGET_ALL : All the supported web form events for Webhooks <br>,\nLIBRARY_DOCUMENT_CREATED : When a library document  is created <br>,\nLIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM : When a library document is auto-cancelled due to conversion problem <br>,\nLIBRARY_DOCUMENT_MODIFIED : When a library document is modified <br>,\nLIBRARY_DOCUMENT_ALL : All the supported library document  events for Webhooks",
            "items": {
              "enum": [
                "AGREEMENT_CREATED",
                "AGREEMENT_ACTION_DELEGATED",
                "AGREEMENT_RECALLED",
                "AGREEMENT_REJECTED",
                "AGREEMENT_EXPIRED",
                "AGREEMENT_ACTION_COMPLETED",
                "AGREEMENT_WORKFLOW_COMPLETED",
                "AGREEMENT_RESTARTED",
                "AGREEMENT_EMAIL_VIEWED",
                "AGREEMENT_MODIFIED",
                "AGREEMENT_SHARED",
                "AGREEMENT_READY_TO_VAULT",
                "AGREEMENT_VAULTED",
                "AGREEMENT_ACTION_REQUESTED",
                "AGREEMENT_ACTION_REPLACED_SIGNER",
                "AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM",
                "AGREEMENT_DOCUMENTS_DELETED",
                "AGREEMENT_EMAIL_BOUNCED",
                "AGREEMENT_KBA_AUTHENTICATED",
                "AGREEMENT_OFFLINE_SYNC",
                "AGREEMENT_USER_ACK_AGREEMENT_MODIFIED",
                "AGREEMENT_WEB_IDENTITY_AUTHENTICATED",
                "AGREEMENT_READY_TO_NOTARIZE",
                "AGREEMENT_EXPIRATION_UPDATED",
                "AGREEMENT_REMINDER_SENT",
                "AGREEMENT_SIGNER_NAME_CHANGED_BY_SIGNER",
                "AGREEMENT_REMINDER_INITIATED",
                "AGREEMENT_ALL",
                "MEGASIGN_CREATED",
                "MEGASIGN_RECALLED",
                "MEGASIGN_SHARED",
                "MEGASIGN_REMINDER_SENT",
                "MEGASIGN_REMINDER_INITIATED",
                "MEGASIGN_ALL",
                "WIDGET_CREATED",
                "WIDGET_MODIFIED",
                "WIDGET_SHARED",
                "WIDGET_ENABLED",
                "WIDGET_DISABLED",
                "WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM",
                "WIDGET_ALL",
                "LIBRARY_DOCUMENT_CREATED",
                "LIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM",
                "LIBRARY_DOCUMENT_MODIFIED",
                "LIBRARY_DOCUMENT_ALL"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "webhookUrlInfo": {
            "$ref": "#/components/schemas/WebhookUrlInfo",
            "description": "Info of webhook url",
            "items": {
              "$ref": "#/components/schemas/WebhookUrlInfo"
            }
          }
        },
        "required": [
          "name",
          "scope",
          "state",
          "webhookSubscriptionEvents",
          "webhookUrlInfo"
        ],
        "type": "object"
      },
      "WebhookLibraryDocumentEvents": {
        "properties": {
          "includeDetailedInfo": {
            "description": "Determines whether agreement detailed info will be returned in the response payload",
            "type": "boolean"
          },
          "includeDocumentsInfo": {
            "description": "Determines whether document info will be returned in the response payload",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "WebhookMegaSignEvents": {
        "properties": {
          "includeDetailedInfo": {
            "description": "Determines whether megaign detailed info will be returned in the response payload",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "WebhookProblemNotificationEmails": {
        "properties": {
          "email": {
            "description": "Email of existing Acrobat Sign user in the same account or group as the API caller",
            "type": "string"
          }
        },
        "type": "object"
      },
      "WebhookStateInfo": {
        "properties": {
          "state": {
            "description": "The state to which the webhook should be changed to",
            "enum": [
              "ACTIVE",
              "INACTIVE"
            ],
            "type": "string"
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "WebhookUrlInfo": {
        "properties": {
          "url": {
            "description": "Info of webhook url",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      },
      "WebhookWidgetEvents": {
        "properties": {
          "includeDetailedInfo": {
            "description": "Determines whether agreement detailed info will be returned in the response payload",
            "type": "boolean"
          },
          "includeDocumentsInfo": {
            "description": "Determines whether document info will be returned in the response payload",
            "type": "boolean"
          },
          "includeParticipantsInfo": {
            "description": "Determines whether participants info will be returned in the response payload",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "CCParticipantInfo2": {
        "properties": {
          "company": {
            "description": "Company of the CC participant, if available.",
            "type": "string"
          },
          "email": {
            "description": "Email of the CC participant of the web form",
            "type": "string"
          },
          "hidden": {
            "description": "True if the web form is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the CC participant, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the CC participant of the web form.",
            "type": "string"
          },
          "self": {
            "description": "True if the CC participant of the web form is the same user that is calling the API.",
            "type": "boolean"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self"
        ],
        "type": "object"
      },
      "CcInfos": {
        "properties": {
          "ccInfoList": {
            "description": "List of emails of all the CC participant of the web form",
            "items": {
              "$ref": "#/components/schemas/WidgetCcInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "ccInfoList"
        ],
        "type": "object"
      },
      "CommonViewConfiguration2": {
        "properties": {
          "autoLoginUser": {
            "description": "Auto LogIn Flag. If true, the URL returned will automatically log the user in. If false, the URL returned will require the credentials. By default its value is false",
            "type": "boolean"
          },
          "frameParent": {
            "description": "An optional field to provide the comma-separated list of parent domain urls where the returned URLs may be iframed. If provided with non-empty and valid list of parent domain urls, it will be used to allow framing for the same. By default the value is null and the Acrobat Sign pages will not be viewable in an iframe. frameParent will be ignored for SIGNING view",
            "type": "string"
          },
          "locale": {
            "description": "Message template locale",
            "type": "string"
          },
          "noChrome": {
            "description": "No Chrome Flag. If true, the embedded page is shown without a navigation header or footer. If false, the standard page header and footer will be present. By default its value is false",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "DetailedParticipantInfo2": {
        "properties": {
          "company": {
            "description": "The company of the participant, if available. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the participant was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the participant. In case of modifying a participant set (PUT) this is a required field. In case of GET, this is the required field and will always be returned unless it is a fax workflow (legacy agreements) that were created using fax as input",
            "type": "string"
          },
          "hidden": {
            "description": "True if the agreement is hidden for the user that is calling the API. Only returned if self is true. Ignored (not required) if modifying a participant (PUT).",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the participant. This will be returned as part of Get call.",
            "type": "string"
          },
          "name": {
            "description": "The name of the participant, if available. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/ParticipantSecurityOption1",
            "description": "Security options that apply to the participant.",
            "items": {
              "$ref": "#/components/schemas/ParticipantSecurityOption"
            }
          },
          "self": {
            "description": "True if this participant is the same user that is calling the API. Returned as part of Get. Ignored (not required) if modifying a participant set (PUT).",
            "type": "boolean"
          },
          "userId": {
            "description": "The user ID of the participant. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "email",
          "id",
          "securityOption"
        ],
        "type": "object"
      },
      "DetailedWidgetParticipantSetInfo": {
        "properties": {
          "id": {
            "description": "The unique identifier of the participant set. This cannot be changed as part of the PUT call.",
            "type": "string"
          },
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set",
            "items": {
              "$ref": "#/components/schemas/DetailedParticipantInfo2"
            },
            "type": "array"
          },
          "order": {
            "description": "Index indicating sequential signing group (specified for hybrid routing). This cannot be changed as part of the PUT call.",
            "type": "integer"
          },
          "providerParticipantSetInfo": {
            "$ref": "#/components/schemas/ProviderParticipantSetInfo",
            "description": "Represents the attributes related to a unknown participant's provider.",
            "items": {
              "$ref": "#/components/schemas/ProviderParticipantSetInfo"
            }
          },
          "role": {
            "description": "Role assumed by all participants in the set (signer, approver etc.). This cannot be changed as part of the PUT call.",
            "enum": [
              "SIGNER",
              "SENDER",
              "APPROVER",
              "ACCEPTOR",
              "CERTIFIED_RECIPIENT",
              "FORM_FILLER",
              "DELEGATE_TO_SIGNER",
              "DELEGATE_TO_APPROVER",
              "DELEGATE_TO_ACCEPTOR",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "DELEGATE_TO_FORM_FILLER",
              "SHARE",
              "NOTARY_SIGNER",
              "ELECTRONIC_SEALER"
            ],
            "type": "string"
          }
        },
        "required": [
          "memberInfos",
          "order",
          "role"
        ],
        "type": "object"
      },
      "DisplayWidgetParticipantSetInfo": {
        "properties": {
          "displayUserSetMemberInfos": {
            "description": "Displays the info about user set",
            "items": {
              "$ref": "#/components/schemas/DisplayParticipantInfo"
            },
            "type": "array"
          }
        },
        "required": [
          "displayUserSetMemberInfos"
        ],
        "type": "object"
      },
      "FetchedWidgetInfo": {
        "properties": {
          "additionalParticipantSetsInfo": {
            "description": "List of all the participants in the web form except web form signer",
            "items": {
              "$ref": "#/components/schemas/WidgetAdditionalParticipationSetInfo"
            },
            "type": "array"
          },
          "authFailureInfo": {
            "$ref": "#/components/schemas/WidgetRedirectionInfo",
            "description": "URL and associated properties for the error page the web form signer will be taken after failing to authenticate",
            "items": {
              "$ref": "#/components/schemas/WidgetRedirectionInfo"
            }
          },
          "ccs": {
            "description": "A list of one or more email addresses that you want to copy on this transaction. The email addresses will each receive an email when the final agreement created through web form is signed. The email addresses will also receive a copy of the document, attached as a PDF file",
            "items": {
              "$ref": "#/components/schemas/WidgetCcInfo"
            },
            "type": "array"
          },
          "completionInfo": {
            "$ref": "#/components/schemas/WidgetRedirectionInfo",
            "description": "URL and associated properties for the success page the web form signer will be taken to after performing desired action on the web form",
            "items": {
              "$ref": "#/components/schemas/WidgetRedirectionInfo"
            }
          },
          "createdDate": {
            "description": "Date when web form was created. If provided in POST, it will simply be ignored. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "creatorEmail": {
            "description": "Email of web form creator. Only returned in GET response. Cannot be provided in POST/PUT request. If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "creatorName": {
            "description": "Name of web form creator. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be used to create the web form. If more than one file is provided, they will be combined before the web form is created. Library documents are not permitted. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo3"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The ID of the group to which the web form belongs to. If not provided during creation, primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "A resource identifier that can be used to uniquely identify the web form in other apis. If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this web form.  Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this web form - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the web form creator",
            "type": "string"
          },
          "name": {
            "description": "The name of the web form that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "ownerEmail": {
            "description": "Email of web form owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "ownerId": {
            "description": "The unique identifier of the web form owner. It will be ignored in POST requests",
            "type": "string"
          },
          "ownerName": {
            "description": "Name of web form owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Secondary security parameters for the web form",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          },
          "state": {
            "description": "The state in which the web form should land. For example in order to create a web form in DRAFT state, field should be DRAFT. The state field will never get returned in GET /widgets/{ID} and will be ignored if provided in PUT /widgets/{ID} call. The eventual status of the web form can be obtained from GET /widgets/ID",
            "enum": [
              "DRAFT",
              "ACTIVE",
              "AUTHORING"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the Web Form. If provided in POST, it will simply be ignored",
            "enum": [
              "DRAFT",
              "AUTHORING",
              "ACTIVE",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "DISABLED",
              "DISCARDED"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          },
          "widgetInActiveInfo": {
            "$ref": "#/components/schemas/WidgetInActiveInfo",
            "description": "The custom message which will be displayed to the user or the URL to which user will be redirected when the web form is accessed in a disabled state. This can only be specified in PUT request",
            "items": {
              "$ref": "#/components/schemas/WidgetInActiveInfo"
            }
          },
          "widgetParticipantSetInfo": {
            "$ref": "#/components/schemas/WidgetParticipantSetInfo",
            "description": "Represents web form participant for whom email should not be provided",
            "items": {
              "$ref": "#/components/schemas/WidgetParticipantSetInfo"
            }
          }
        },
        "required": [
          "name",
          "widgetParticipantSetInfo"
        ],
        "type": "object"
      },
      "FileInfo3": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/Document",
            "description": "A document that is associated with the web form. This field cannot be provided in POST call. In case of GET call, this is the only field returned in the response",
            "items": {
              "$ref": "#/components/schemas/Document"
            }
          },
          "notarize": {
            "description": "Indicates that this document needs to be notarized",
            "type": "boolean"
          },
          "transientDocumentId": {
            "description": "ID for a transient document that will be added to the web form",
            "type": "string"
          },
          "urlFileInfo": {
            "$ref": "#/components/schemas/URLFileInfo",
            "description": "URL for an external document to add to the agreement",
            "items": {
              "$ref": "#/components/schemas/URLFileInfo"
            }
          }
        },
        "type": "object"
      },
      "ParticipantSecurityOption1": {
        "properties": {
          "authenticationMethod": {
            "description": "The authentication method for the participants to have access to view and sign the document. When replacing a participant that has PASSWORD or PHONE authentication specified, you must supply a password or phone number for the new participant, and you cannot change the authentication method. \nFor unknown participants, only email based authentication is allowed. Hence, only ‘NONE’ authenticaiton method is permitted",
            "enum": [
              "NONE",
              "PASSWORD",
              "PHONE",
              "KBA",
              "WEB_IDENTITY",
              "ADOBE_SIGN"
            ],
            "type": "string"
          },
          "digAuthInfo": {
            "$ref": "#/components/schemas/DigAuthInfo",
            "description": "Digital Identity Gateway Provider information.",
            "items": {
              "$ref": "#/components/schemas/DigAuthInfo"
            }
          },
          "nameInfo": {
            "$ref": "#/components/schemas/NameInfo",
            "description": "Recipient's full name",
            "items": {
              "$ref": "#/components/schemas/NameInfo"
            }
          },
          "notaryAuthentication": {
            "description": "The authentication method of the notary participant to the notary",
            "enum": [
              "MULTI_FACTOR_AUTHENTICATION",
              "NONE"
            ],
            "type": "string"
          },
          "password": {
            "description": "The password required for the participant to view and sign the document. Note that Acrobat Sign will never show this password to anyone, so you will need to separately communicate it to any relevant parties. The password will not be returned in GET call. When replacing a participant that has PASSWORD authentication specified, you must supply a password for the new participant.",
            "type": "string"
          },
          "phoneInfo": {
            "$ref": "#/components/schemas/PhoneInfo",
            "description": "The phoneInfo required for the participant to view and sign the document",
            "items": {
              "$ref": "#/components/schemas/PhoneInfo"
            }
          }
        },
        "required": [
          "authenticationMethod"
        ],
        "type": "object"
      },
      "ParticipantSetMemberInfo1": {
        "properties": {
          "email": {
            "description": "Email of the participant. It should be blank for the unknown participants.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the participant. This will be ignored as part of POST or PUT calls. The Id might be null in draft state",
            "type": "string"
          },
          "name": {
            "description": "Recipient's full name",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/ParticipantSecurityOption1",
            "description": "Security options that apply to the participant",
            "items": {
              "$ref": "#/components/schemas/ParticipantSecurityOption"
            }
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "PersonalizedSigningViewConfiguration": {
        "properties": {
          "comment": {
            "description": "Comment describing how the API caller established the signer's identity - will appear in the audit trail",
            "type": "string"
          },
          "email": {
            "description": "The email address of the person who will be receiving this web form",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration date for the personalization of this web form. After this date, the identity of the signer will not be assumed by Acrobat Sign. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2022-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "reusable": {
            "description": "Should the intended signer be allowed to sign this web form more than once",
            "type": "boolean"
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "ProviderParticipantSetInfo": {
        "properties": {
          "actionDescription": {
            "description": "The description for the provider participant who is responsible to provide details like name, email for the unknown participant.",
            "type": "string"
          },
          "actionRequired": {
            "description": "It indicates whether it is mandatory or not for the provider participant to provide the details for the unknown participant",
            "type": "boolean"
          }
        },
        "required": [
          "actionRequired"
        ],
        "type": "object"
      },
      "SenderInfo3": {
        "properties": {
          "company": {
            "description": "Company of the creator, if available.",
            "type": "string"
          },
          "createdDate": {
            "description": "The date when the sender was added. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "format": "date",
            "type": "string"
          },
          "email": {
            "description": "Email of the creator of the web form.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the web form is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the creator, if available.",
            "type": "string"
          },
          "participantId": {
            "description": " The unique identifier of the creator of the web form.",
            "type": "string"
          },
          "self": {
            "description": "True if the creator of the web form is the same user that is calling the API.",
            "type": "boolean"
          },
          "userId": {
            "description": "The user ID of the sender. This will be returned as part of GET call but is ignored if passed as part of PUT call.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self"
        ],
        "type": "object"
      },
      "ShareParticipantInfo2": {
        "properties": {
          "company": {
            "description": "Company of the sharee participant of the web form, if available.",
            "type": "string"
          },
          "email": {
            "description": "Email of the sharee participant of the web form.",
            "type": "string"
          },
          "hidden": {
            "description": "True if the web form is hidden for the user that is calling the API. Only returned if self is true.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the sharee participant of the web form, if available.",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the sharee participant of the web form.",
            "type": "string"
          },
          "self": {
            "description": "True if the Share participant of the web form is the same user that is calling the API.",
            "type": "boolean"
          },
          "sharerParticipantId": {
            "description": "The unique identifier of the participant who shared the web form.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "email",
          "hidden",
          "name",
          "participantId",
          "self",
          "sharerParticipantId"
        ],
        "type": "object"
      },
      "UserWidget": {
        "properties": {
          "groupId": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "hidden": {
            "description": "True if agreement is hidden for the user",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of a web form",
            "type": "string"
          },
          "javascript": {
            "description": "The embedded javascript code of the web form",
            "type": "string"
          },
          "modifiedDate": {
            "description": "The date on which the web form was last modified. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the web form.",
            "type": "string"
          },
          "status": {
            "description": "The web form status (AUTHORING, ACTIVE, DRAFT, DISABLED)",
            "enum": [
              "AUTHORING",
              "ACTIVE",
              "DRAFT",
              "DISABLED"
            ],
            "type": "string"
          },
          "url": {
            "description": "The hosted url of the web form",
            "type": "string"
          }
        },
        "required": [
          "groupId",
          "hidden",
          "id",
          "javascript",
          "modifiedDate",
          "name",
          "status",
          "url"
        ],
        "type": "object"
      },
      "UserWidgets": {
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userWidgetList": {
            "description": "An array of web form items",
            "items": {
              "$ref": "#/components/schemas/UserWidget"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userWidgetList"
        ],
        "type": "object"
      },
      "WidgetAdditionalParticipationSetInfo": {
        "properties": {
          "electronicSealId": {
            "description": "ID of the sealing credential, which can be obtained through <b>GET /autoseals</b> call.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of the Web form participant. This will be ignored as part of POST or PUT calls.The Id might be null in draft state,",
            "type": "string"
          },
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant-specific data (email, e.g.) for all the additional participants in the web form. If the email of the participant is unknown at the time of web form creation, the email should be left empty. Required, unless ParticipantSet has the ELECTRONIC_SEALER role, ",
            "items": {
              "$ref": "#/components/schemas/ParticipantSetMemberInfo1"
            },
            "type": "array"
          },
          "order": {
            "description": "Index indicating position at which signing group needs to sign. Additional participant to sign at first place is assigned a index of 1. Web Form participant should not have any order specified. Web Form participant should not have any email address and and can not have phone authentication applied. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signingOrder will be considered invalid,",
            "type": "integer"
          },
          "providerParticipantSetInfo": {
            "$ref": "#/components/schemas/ProviderParticipantSetInfo",
            "description": "Represents all the attributes related to the unknown participant and its provider. If it is defined then the participant will be treated as an unknown participant.",
            "items": {
              "$ref": "#/components/schemas/ProviderParticipantSetInfo"
            }
          },
          "role": {
            "description": "Role assumed by all participants in the set (signer, approver, etc.) Web Form First Participant will only have roles - Signer, Approver, Acceptor and Form Filler",
            "enum": [
              "SIGNER",
              "DELEGATE_TO_SIGNER",
              "APPROVER",
              "DELEGATE_TO_APPROVER",
              "ACCEPTOR",
              "DELEGATE_TO_ACCEPTOR",
              "FORM_FILLER",
              "DELEGATE_TO_FORM_FILLER",
              "CERTIFIED_RECIPIENT",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "ELECTRONIC_SEALER"
            ],
            "type": "string"
          }
        },
        "required": [
          "memberInfos",
          "role"
        ],
        "type": "object"
      },
      "WidgetAgreement": {
        "properties": {
          "displayDate": {
            "description": "The display date for the agreement. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "displayParticipantSetInfos": {
            "description": "The most relevant current user set for the agreement. It is typically the next signer if the agreement is from the current user, or the sender if received from another user",
            "items": {
              "$ref": "#/components/schemas/DisplayWidgetParticipantSetInfo"
            },
            "type": "array"
          },
          "esign": {
            "description": "True if this is an e-sign document",
            "type": "boolean"
          },
          "groupId": {
            "description": "Unique identifier of the group",
            "type": "string"
          },
          "hidden": {
            "description": "True if agreement is hidden for the user",
            "type": "boolean"
          },
          "id": {
            "description": "The unique identifier of the agreement.If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "latestVersionId": {
            "description": "A version ID which uniquely identifies the current version of the agreement",
            "type": "string"
          },
          "name": {
            "description": "Name of the Agreement",
            "type": "string"
          },
          "parentId": {
            "description": "The parent id of a bulk send child *OR* the originating id of a web form agreement instance",
            "type": "string"
          },
          "status": {
            "description": "The current status of the document from the perspective of the originator",
            "enum": [
              "WAITING_FOR_MY_SIGNATURE",
              "WAITING_FOR_MY_APPROVAL",
              "WAITING_FOR_MY_DELEGATION",
              "WAITING_FOR_MY_ACKNOWLEDGEMENT",
              "WAITING_FOR_MY_ACCEPTANCE",
              "WAITING_FOR_MY_FORM_FILLING",
              "WAITING_FOR_NOTARIZATION",
              "OUT_FOR_SIGNATURE",
              "OUT_FOR_APPROVAL",
              "OUT_FOR_DELIVERY",
              "OUT_FOR_ACCEPTANCE",
              "OUT_FOR_FORM_FILLING",
              "SIGNED",
              "APPROVED",
              "FORM_FILLED",
              "DELIVERED",
              "ACCEPTED",
              "ARCHIVED",
              "CANCELLED",
              "EXPIRED",
              "WAITING_FOR_PREFILL",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "WAITING_FOR_MY_VERIFICATION",
              "WAITING_FOR_VERIFICATION"
            ],
            "type": "string"
          },
          "type": {
            "description": "The kind of agreement",
            "enum": [
              "AGREEMENT",
              "MEGASIGN_CHILD",
              "WIDGET_INSTANCE"
            ],
            "type": "string"
          }
        },
        "required": [
          "displayDate",
          "displayParticipantSetInfos",
          "esign",
          "groupId",
          "hidden",
          "latestVersionId",
          "name",
          "status"
        ],
        "type": "object"
      },
      "WidgetAgreements": {
        "properties": {
          "page": {
            "$ref": "#/components/schemas/PageInfo",
            "description": "Pagination information for navigating through the response",
            "items": {
              "$ref": "#/components/schemas/PageInfo"
            }
          },
          "userAgreementList": {
            "description": "An array of UserAgreement items",
            "items": {
              "$ref": "#/components/schemas/WidgetAgreement"
            },
            "type": "array"
          }
        },
        "required": [
          "page",
          "userAgreementList"
        ],
        "type": "object"
      },
      "WidgetCcInfo": {
        "properties": {
          "email": {
            "description": "Email of the CC participant of the web form",
            "type": "string"
          }
        },
        "required": [
          "email"
        ],
        "type": "object"
      },
      "WidgetCreationInfoV6": {
        "properties": {
          "additionalParticipantSetsInfo": {
            "description": "List of all the participants in the web form except web form signer",
            "items": {
              "$ref": "#/components/schemas/WidgetAdditionalParticipationSetInfo"
            },
            "type": "array"
          },
          "authFailureInfo": {
            "$ref": "#/components/schemas/WidgetRedirectionInfo",
            "description": "URL and associated properties for the error page the web form signer will be taken after failing to authenticate",
            "items": {
              "$ref": "#/components/schemas/WidgetRedirectionInfo"
            }
          },
          "ccs": {
            "description": "A list of one or more email addresses that you want to copy on this transaction. The email addresses will each receive an email when the final agreement created through web form is signed. The email addresses will also receive a copy of the document, attached as a PDF file",
            "items": {
              "$ref": "#/components/schemas/WidgetCcInfo"
            },
            "type": "array"
          },
          "completionInfo": {
            "$ref": "#/components/schemas/WidgetRedirectionInfo",
            "description": "URL and associated properties for the success page the web form signer will be taken to after performing desired action on the web form",
            "items": {
              "$ref": "#/components/schemas/WidgetRedirectionInfo"
            }
          },
          "createdDate": {
            "description": "Date when web form was created. If provided in POST, it will simply be ignored. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "creatorEmail": {
            "description": "Email of web form creator. Only returned in GET response. Cannot be provided in POST/PUT request. If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "creatorName": {
            "description": "Name of web form creator. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be used to create the web form. If more than one file is provided, they will be combined before the web form is created. Library documents are not permitted. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo3"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The ID of the group to which the web form belongs to. If not provided during creation, primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "A resource identifier that can be used to uniquely identify the web form in other apis. If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this web form.  Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this web form - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the web form creator",
            "type": "string"
          },
          "name": {
            "description": "The name of the web form that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "ownerEmail": {
            "description": "Email of web form owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "ownerId": {
            "description": "The unique identifier of the web form owner. It will be ignored in POST requests",
            "type": "string"
          },
          "ownerName": {
            "description": "Name of web form owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Secondary security parameters for the web form",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          },
          "state": {
            "description": "The state in which the web form should land. For example in order to create a web form in DRAFT state, field should be DRAFT. The state field will never get returned in GET /widgets/{ID} and will be ignored if provided in PUT /widgets/{ID} call. The eventual status of the web form can be obtained from GET /widgets/ID",
            "enum": [
              "DRAFT",
              "ACTIVE",
              "AUTHORING"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the Web Form. If provided in POST, it will simply be ignored",
            "enum": [
              "DRAFT",
              "AUTHORING",
              "ACTIVE",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "DISABLED",
              "DISCARDED"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          },
          "widgetInActiveInfo": {
            "$ref": "#/components/schemas/WidgetInActiveInfo",
            "description": "The custom message which will be displayed to the user or the URL to which user will be redirected when the web form is accessed in a disabled state. This can only be specified in PUT request",
            "items": {
              "$ref": "#/components/schemas/WidgetInActiveInfo"
            }
          },
          "widgetParticipantSetInfo": {
            "$ref": "#/components/schemas/WidgetParticipantSetInfo",
            "description": "Represents web form participant for whom email should not be provided",
            "items": {
              "$ref": "#/components/schemas/WidgetParticipantSetInfo"
            }
          }
        },
        "required": [
          "fileInfos",
          "name",
          "state",
          "widgetParticipantSetInfo"
        ],
        "type": "object"
      },
      "WidgetCreationResponse": {
        "description": "A JSON object describing the web form",
        "properties": {
          "id": {
            "description": "The unique identifier of web form which can be used to retrieve the data entered by the signers.",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "type": "object"
      },
      "WidgetDocuments": {
        "properties": {
          "documents": {
            "description": "A list of documents",
            "items": {
              "$ref": "#/components/schemas/Document"
            },
            "type": "array"
          }
        },
        "required": [
          "documents"
        ],
        "type": "object"
      },
      "WidgetEvent": {
        "properties": {
          "actingUserEmail": {
            "description": "Email address of the user that created the event",
            "type": "string"
          },
          "actingUserIpAddress": {
            "description": "The IP address of the user that created the event",
            "type": "string"
          },
          "actingUserName": {
            "description": "The name of the acting user",
            "type": "string"
          },
          "comment": {
            "description": "The event comment. For RECALLED or REJECTED, the reason given by the user that initiates the event. For DELEGATE or SHARE, the message from the acting user to the participant",
            "type": "string"
          },
          "date": {
            "description": "The date of the audit event. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "description": {
            "description": "A description of the audit event",
            "type": "string"
          },
          "device": {
            "description": "The device used for the event.",
            "type": "string"
          },
          "deviceLocation": {
            "$ref": "#/components/schemas/WidgetEventDeviceLocation",
            "description": "Location of the device that generated the event (This value may be null due to limited privileges)",
            "items": {
              "$ref": "#/components/schemas/WidgetEventDeviceLocation"
            }
          },
          "devicePhoneNumber": {
            "description": "Phone number from the device used when the participation is completed on a mobile phone",
            "type": "string"
          },
          "digitalSignatureInfo": {
            "$ref": "#/components/schemas/DigitalSignatureInfo",
            "description": "This is present for ESIGNED events when the participation is signed digitally",
            "items": {
              "$ref": "#/components/schemas/DigitalSignatureInfo"
            }
          },
          "id": {
            "description": "The identifier for the event.",
            "type": "string"
          },
          "initiatingUserEmail": {
            "description": "Email address of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "initiatingUserName": {
            "description": "Full name of the user that initiated the event on behalf of the acting user when the account is shared. Will be empty if there is no account sharing in effect",
            "type": "string"
          },
          "participantEmail": {
            "description": "Email address of the user that is the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantId": {
            "description": "The unique identifier of the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "participantRole": {
            "description": "Role assumed by all participants in the participant set the participant belongs to (signer, approver etc.).",
            "enum": [
              "SIGNER",
              "DELEGATE_TO_SIGNER",
              "APPROVER",
              "DELEGATE_TO_APPROVER",
              "ACCEPTOR",
              "DELEGATE_TO_ACCEPTOR",
              "FORM_FILLER",
              "DELEGATE_TO_FORM_FILLER",
              "CERTIFIED_RECIPIENT",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "SHARE",
              "RESOURCE_SHARE",
              "SENDER",
              "NOTARY_SIGNER"
            ],
            "type": "string"
          },
          "reminderParticipants": {
            "description": "A list of one or more participants who received the reminders",
            "items": {
              "$ref": "#/components/schemas/ReminderParticipant"
            },
            "type": "array"
          },
          "replacedParticipantEmail": {
            "description": "Email of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "replacedParticipantName": {
            "description": "Full name of the user that was replaced by the participant for the event. This may be different than the acting user for certain event types. For example, for a DELEGATION event, this is the user who was delegated to",
            "type": "string"
          },
          "signerNewName": {
            "description": "Signer changed name at signing : new name used to sign.",
            "type": "string"
          },
          "signerOldName": {
            "description": "Signer changed name at signing : name used previous to signing.",
            "type": "string"
          },
          "signingReason": {
            "description": "Signing reason captured during ESIGN or DIGSIGN",
            "type": "string"
          },
          "synchronizationId": {
            "description": "A unique identifier linking offline events to synchronization events (specified for offline signing events and synchronization events, else null)",
            "type": "string"
          },
          "type": {
            "description": "Type of web form event",
            "enum": [
              "AUTO_CANCELLED_CONVERSION_PROBLEM",
              "ACTIVATED",
              "CREATED",
              "DEACTIVATED",
              "MODIFIED",
              "OWNER_CHANGED"
            ],
            "type": "string"
          },
          "vaultEventId": {
            "description": "The identifier assigned by the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "vaultProviderName": {
            "description": "Name of the vault provider for the vault event (if vaulted, otherwise null)",
            "type": "string"
          },
          "versionId": {
            "description": "An ID which uniquely identifies the version of the document associated with this audit event",
            "type": "string"
          }
        },
        "required": [
          "actingUserEmail",
          "actingUserIpAddress",
          "actingUserName",
          "date",
          "description",
          "device",
          "deviceLocation",
          "devicePhoneNumber",
          "digitalSignatureInfo",
          "initiatingUserEmail",
          "initiatingUserName",
          "participantEmail",
          "participantId",
          "participantRole",
          "synchronizationId",
          "type",
          "vaultEventId",
          "vaultProviderName",
          "versionId"
        ],
        "type": "object"
      },
      "WidgetEventDeviceLocation": {
        "properties": {
          "latitude": {
            "description": "Latitude coordinate",
            "format": "float",
            "type": "number"
          },
          "longitude": {
            "description": "Longitude coordinate",
            "format": "float",
            "type": "number"
          }
        },
        "required": [
          "latitude",
          "longitude"
        ],
        "type": "object"
      },
      "WidgetEventList": {
        "properties": {
          "events": {
            "description": "An array of event objects.",
            "items": {
              "$ref": "#/components/schemas/WidgetEvent"
            },
            "type": "array"
          }
        },
        "required": [
          "events"
        ],
        "type": "object"
      },
      "WidgetFormFields": {
        "description": "A JSON list of all of the fields for a form",
        "properties": {
          "fields": {
            "description": "List of the form fields in an agreement",
            "items": {
              "$ref": "#/components/schemas/FormField"
            },
            "type": "array"
          }
        },
        "required": [
          "fields"
        ],
        "type": "object"
      },
      "WidgetInActiveInfo": {
        "properties": {
          "message": {
            "description": "Display this custom message to the user when the web form is accessed. Note that this can contain wiki markup to include clickable links in the message. This is required if redirectUrl is not provided. Both message and redirectUrl cannot be specified.",
            "type": "string"
          },
          "redirectUrl": {
            "description": "Redirect the user to this URL when the web form is accessed. This is required if message is not provided. Both message and redirectUrl cannot be specified.",
            "type": "string"
          }
        },
        "required": [
          "message",
          "redirectUrl"
        ],
        "type": "object"
      },
      "WidgetInfo": {
        "properties": {
          "additionalParticipantSetsInfo": {
            "description": "List of all the participants in the web form except web form signer",
            "items": {
              "$ref": "#/components/schemas/WidgetAdditionalParticipationSetInfo"
            },
            "type": "array"
          },
          "authFailureInfo": {
            "$ref": "#/components/schemas/WidgetRedirectionInfo",
            "description": "URL and associated properties for the error page the web form signer will be taken after failing to authenticate",
            "items": {
              "$ref": "#/components/schemas/WidgetRedirectionInfo"
            }
          },
          "ccs": {
            "description": "A list of one or more email addresses that you want to copy on this transaction. The email addresses will each receive an email when the final agreement created through web form is signed. The email addresses will also receive a copy of the document, attached as a PDF file",
            "items": {
              "$ref": "#/components/schemas/WidgetCcInfo"
            },
            "type": "array"
          },
          "completionInfo": {
            "$ref": "#/components/schemas/WidgetRedirectionInfo",
            "description": "URL and associated properties for the success page the web form signer will be taken to after performing desired action on the web form",
            "items": {
              "$ref": "#/components/schemas/WidgetRedirectionInfo"
            }
          },
          "createdDate": {
            "description": "Date when web form was created. If provided in POST, it will simply be ignored. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "creatorEmail": {
            "description": "Email of web form creator. Only returned in GET response. Cannot be provided in POST/PUT request. If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "creatorName": {
            "description": "Name of web form creator. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "fileInfos": {
            "description": "A list of one or more files (or references to files) that will be used to create the web form. If more than one file is provided, they will be combined before the web form is created. Library documents are not permitted. Note: Only one of the four parameters in every FileInfo object must be specified",
            "items": {
              "$ref": "#/components/schemas/FileInfo3"
            },
            "type": "array"
          },
          "groupId": {
            "description": "The ID of the group to which the web form belongs to. If not provided during creation, primary group of the creator will be used",
            "type": "string"
          },
          "id": {
            "description": "A resource identifier that can be used to uniquely identify the web form in other apis. If provided in POST, it will simply be ignored",
            "type": "string"
          },
          "isDocumentRetentionApplied": {
            "description": "Is document retention applied for this resource.  If provided in POST or PUT, it will simply be ignored.",
            "type": "boolean"
          },
          "lastEventDate": {
            "description": "The date of the last event that occurred for this web form.  Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "locale": {
            "description": "The locale associated with this web form - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the web form creator",
            "type": "string"
          },
          "name": {
            "description": "The name of the web form that will be used to identify it, in emails, website and other places",
            "type": "string"
          },
          "ownerEmail": {
            "description": "Email of web form owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "ownerId": {
            "description": "The unique identifier of the web form owner. It will be ignored in POST requests",
            "type": "string"
          },
          "ownerName": {
            "description": "Name of web form owner. It will be ignored in POST/PUT requests",
            "type": "string"
          },
          "securityOption": {
            "$ref": "#/components/schemas/SecurityOption",
            "description": "Secondary security parameters for the web form",
            "items": {
              "$ref": "#/components/schemas/SecurityOption"
            }
          },
          "state": {
            "description": "The state in which the web form should land. For example in order to create a web form in DRAFT state, field should be DRAFT. The state field will never get returned in GET /widgets/{ID} and will be ignored if provided in PUT /widgets/{ID} call. The eventual status of the web form can be obtained from GET /widgets/ID",
            "enum": [
              "DRAFT",
              "ACTIVE",
              "AUTHORING"
            ],
            "type": "string"
          },
          "status": {
            "description": "Status of the Web Form. If provided in POST, it will simply be ignored",
            "enum": [
              "DRAFT",
              "AUTHORING",
              "ACTIVE",
              "DOCUMENTS_NOT_YET_PROCESSED",
              "DISABLED",
              "DISCARDED"
            ],
            "type": "string"
          },
          "vaultingInfo": {
            "$ref": "#/components/schemas/VaultingInfo",
            "description": "Vaulting properties that allows Acrobat Sign to securely store documents with a vault provider",
            "items": {
              "$ref": "#/components/schemas/VaultingInfo"
            }
          },
          "widgetInActiveInfo": {
            "$ref": "#/components/schemas/WidgetInActiveInfo",
            "description": "The custom message which will be displayed to the user or the URL to which user will be redirected when the web form is accessed in a disabled state. This can only be specified in PUT request",
            "items": {
              "$ref": "#/components/schemas/WidgetInActiveInfo"
            }
          },
          "widgetParticipantSetInfo": {
            "$ref": "#/components/schemas/WidgetParticipantSetInfo",
            "description": "Represents web form participant for whom email should not be provided",
            "items": {
              "$ref": "#/components/schemas/WidgetParticipantSetInfo"
            }
          }
        },
        "required": [
          "fileInfos",
          "name",
          "status",
          "widgetParticipantSetInfo"
        ],
        "type": "object"
      },
      "WidgetMembersInfo": {
        "properties": {
          "additionalParticipantSets": {
            "description": "Information about the web form additional participant Sets",
            "items": {
              "$ref": "#/components/schemas/DetailedWidgetParticipantSetInfo"
            },
            "type": "array"
          },
          "ccsInfo": {
            "description": "Information of CC participants of the web form.",
            "items": {
              "$ref": "#/components/schemas/CCParticipantInfo2"
            },
            "type": "array"
          },
          "creatorInfo": {
            "$ref": "#/components/schemas/SenderInfo3",
            "description": "Information of the creator of the web form.",
            "items": {
              "$ref": "#/components/schemas/SenderInfo"
            }
          },
          "sharesInfo": {
            "description": "Information of the participants with whom the web form has been shared.",
            "items": {
              "$ref": "#/components/schemas/ShareParticipantInfo2"
            },
            "type": "array"
          },
          "widgetParticipantSet": {
            "$ref": "#/components/schemas/DetailedWidgetParticipantSetInfo",
            "description": "Information about the web form participant Set",
            "items": {
              "$ref": "#/components/schemas/DetailedWidgetParticipantSetInfo"
            }
          }
        },
        "required": [
          "ccsInfo",
          "creatorInfo",
          "sharesInfo"
        ],
        "type": "object"
      },
      "WidgetParticipantSetInfo": {
        "properties": {
          "memberInfos": {
            "description": "Array of ParticipantInfo objects, containing participant - specific data (email, e.g.). All participants in the array belong to the same set. Currently we are supporting only one member in the set. Since the email of the web form signer is unknown at the time of web form creation, the email should be left empty and its optional security options should be provided. ",
            "items": {
              "$ref": "#/components/schemas/ParticipantSetMemberInfo1"
            },
            "type": "array"
          },
          "role": {
            "description": "Role assumed by all participants in the set (signer, approver, etc.) Web Form First Participant will only have roles - Signer, Approver, Acceptor and Form Filler",
            "enum": [
              "SIGNER",
              "DELEGATE_TO_SIGNER",
              "APPROVER",
              "DELEGATE_TO_APPROVER",
              "ACCEPTOR",
              "DELEGATE_TO_ACCEPTOR",
              "FORM_FILLER",
              "DELEGATE_TO_FORM_FILLER",
              "CERTIFIED_RECIPIENT",
              "DELEGATE_TO_CERTIFIED_RECIPIENT",
              "ELECTRONIC_SEALER"
            ],
            "type": "string"
          }
        },
        "required": [
          "memberInfos",
          "role"
        ],
        "type": "object"
      },
      "WidgetRedirectionInfo": {
        "properties": {
          "deframe": {
            "description": "If deframe is false, the resultant page will be shown inside the web form frame. If deframe is true, the resultant page will be shown in the full browser window. \n Note that in the case of embedded web forms, browser security restrictions do not permit automatic redirection in the full browser window, so if deframe is true the user will instead just see a link to the success page. We recommend this scenario be avoided - in other words, setting deframe to false is recommended for embedded web forms",
            "type": "boolean"
          },
          "delay": {
            "description": "The delay (in seconds) before the user is taken to the resultant page. If this value is greater than 0, the user will first see the standard Acrobat Sign result message, and then after a delay will be redirected to your resultant page. \n Note that this parameter has no effect for embedded web forms when deframe is true",
            "type": "integer"
          },
          "url": {
            "description": "A publicly accessible url to which the user will be sent after successfully completing the web form. \nIf the URL you provide includes information that allows you to identify the specific transaction, such as your own unique identifier, you can use the browser request to this URL as a callback to notify you that this transaction is completed. \nIn addition, Acrobat Sign will append a documentKey parameter to the URL which will contain the Acrobat Sign DocumentKey for this signed web form, but only if the sender is the same as the API key user. Your application can use this value to get the form data for this web form",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "type": "object"
      },
      "WidgetStateInfo": {
        "properties": {
          "state": {
            "description": "State of the Web Form",
            "enum": [
              "ACTIVE",
              "INACTIVE",
              "AUTHORING",
              "CANCELLED"
            ],
            "type": "string"
          },
          "widgetInActiveInfo": {
            "$ref": "#/components/schemas/WidgetInActiveInfo",
            "description": "The custom message which will be displayed to the user or the URL to which user will be redirected when the web form is accessed in a disabled state. This can only be specified in PUT request",
            "items": {
              "$ref": "#/components/schemas/WidgetInActiveInfo"
            }
          }
        },
        "required": [
          "state"
        ],
        "type": "object"
      },
      "WidgetView": {
        "properties": {
          "embeddedCode": {
            "description": "Embedded code of url of resource ",
            "type": "string"
          },
          "expiration": {
            "description": "Expiration of user url ",
            "format": "date",
            "type": "string"
          },
          "isCurrent": {
            "description": "True if this view is the current view",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the requested web form view",
            "enum": [
              "MODIFY",
              "AUTHORING",
              "DOCUMENT",
              "MANAGE",
              "POST_CREATE",
              "SIGNING",
              "ALL"
            ],
            "type": "string"
          },
          "url": {
            "description": "Url of resource location",
            "type": "string"
          }
        },
        "required": [
          "isCurrent",
          "name"
        ],
        "type": "object"
      },
      "WidgetViewInfo": {
        "properties": {
          "commonViewConfiguration": {
            "$ref": "#/components/schemas/CommonViewConfiguration2",
            "description": "Common view configuration for all the available views",
            "items": {
              "$ref": "#/components/schemas/CommonViewConfiguration"
            }
          },
          "name": {
            "description": "Name of the requested web form view",
            "enum": [
              "MODIFY",
              "AUTHORING",
              "DOCUMENT",
              "MANAGE",
              "POST_CREATE",
              "SIGNING",
              "ALL"
            ],
            "type": "string"
          },
          "personalizedSigningViewConfiguration": {
            "$ref": "#/components/schemas/PersonalizedSigningViewConfiguration",
            "description": "Personalized SIGNING view configuration",
            "items": {
              "$ref": "#/components/schemas/PersonalizedSigningViewConfiguration"
            }
          }
        },
        "required": [
          "name"
        ],
        "type": "object"
      },
      "WidgetViews": {
        "properties": {
          "widgetViewList": {
            "description": "List of web form views",
            "items": {
              "$ref": "#/components/schemas/WidgetView"
            },
            "type": "array"
          }
        },
        "required": [
          "widgetViewList"
        ],
        "type": "object"
      },
      "CCsListInfoDescription": {
        "properties": {
          "defaultValues": {
            "description": "An array of default emails that will be used if no input is provided for this list element.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "editable": {
            "description": "Whether current field can be edited. If editable attribute for this field is false then this field should not be provided in the agreement creation request and default value of this field will be used in agreement creation",
            "type": "boolean"
          },
          "label": {
            "description": "A display text for the workflow user that can be used for the current CC list",
            "type": "string"
          },
          "maxListCount": {
            "description": "maximum number of entries allowed in the current CC list",
            "type": "integer"
          },
          "minListCount": {
            "description": "minimum number of entries allowed in the current CC list",
            "type": "integer"
          },
          "name": {
            "description": "Name of the current CC list",
            "type": "string"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "visible": {
            "description": "Whether current field is visible or not. If visible attribute for this field is false then this field should not be shown in the agreement creation page using this workflow",
            "type": "boolean"
          }
        },
        "required": [
          "defaultValues",
          "editable",
          "label",
          "maxListCount",
          "minListCount",
          "name",
          "required",
          "visible"
        ],
        "type": "object"
      },
      "ExpirationFieldInfoDescription": {
        "properties": {
          "defaultValue": {
            "description": "default value of the field if input for this field is not provided and this field is required",
            "type": "string"
          },
          "editable": {
            "description": "Whether current field can be edited. If editable attribute for this field is false then this field should not be provided in the agreement creation request and default value of this field will be used in agreement creation",
            "type": "boolean"
          },
          "maxDays": {
            "description": "Maximum number of days for agreement expiration",
            "type": "integer"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "visible": {
            "description": "Whether current field is visible or not. If visible attribute for this field is false then this field should not be visible in the agreement creation UI using this workflow to user",
            "type": "boolean"
          }
        },
        "required": [
          "defaultValue",
          "editable",
          "maxDays",
          "required",
          "visible"
        ],
        "type": "object"
      },
      "FileInfosDescription": {
        "properties": {
          "label": {
            "description": "Display label of this field for external users",
            "type": "string"
          },
          "name": {
            "description": "Name of the fileInfo element",
            "type": "string"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "workflowLibraryDocumentSelectorList": {
            "description": "A list of workflow library documents out of which one workflow library document can be selected with this fileInfo object",
            "items": {
              "$ref": "#/components/schemas/WorkflowLibraryDocument"
            },
            "type": "array"
          }
        },
        "required": [
          "label",
          "name",
          "required",
          "workflowLibraryDocumentSelectorList"
        ],
        "type": "object"
      },
      "LocaleFieldInfoDescription": {
        "properties": {
          "availableLocales": {
            "description": "Which locales can be chosen for this workflow",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "defaultValue": {
            "description": "default value of the field if input for this field is not provided and this field is required",
            "type": "string"
          },
          "editable": {
            "description": "Whether current field can be edited. If editable attribute for this field is false then this field should not be provided in the agreement creation request and default value of this field will be used in agreement creation",
            "type": "boolean"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "visible": {
            "description": "Whether current field is visible or not. If visible attribute for this field is false then this field should not be visible in the agreement creation UI using this workflow to user",
            "type": "boolean"
          }
        },
        "required": [
          "availableLocales",
          "defaultValue",
          "editable",
          "required",
          "visible"
        ],
        "type": "object"
      },
      "MergeFieldInfoDescription": {
        "properties": {
          "defaultValue": {
            "description": "default value of the field if input for this field is not provided and this field is required",
            "type": "string"
          },
          "displayName": {
            "description": "The display text that can be shown for this custom field",
            "type": "string"
          },
          "editable": {
            "description": "Whether current field can be edited. If editable attribute for this field is false then this field should not be provided in the agreement creation request and default value of this field will be used in agreement creation",
            "type": "boolean"
          },
          "fieldName": {
            "description": "Name of the custom field in this workflow",
            "type": "string"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "visible": {
            "description": "Whether current field should be visible on agreement creation page. If visible attribute for this field is false then this field should not be shown on the agreement creation page using this workflow",
            "type": "boolean"
          }
        },
        "required": [
          "defaultValue",
          "displayName",
          "editable",
          "fieldName",
          "required",
          "visible"
        ],
        "type": "object"
      },
      "PasswordFieldInfoDescription": {
        "properties": {
          "defaultValue": {
            "description": "Default value of the password info field",
            "type": "string"
          },
          "editable": {
            "description": "Default value of the password info field",
            "type": "boolean"
          },
          "label": {
            "description": "Label of password field",
            "type": "string"
          },
          "name": {
            "description": "Name of password field",
            "type": "string"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "visible": {
            "description": "Whether password info field is visible on agreement creation page",
            "type": "boolean"
          }
        },
        "required": [
          "defaultValue",
          "editable",
          "label",
          "name",
          "required",
          "visible"
        ],
        "type": "object"
      },
      "RecipientsListInfoDescription": {
        "properties": {
          "allowSender": {
            "description": "whether sender is allowed as a recipient",
            "type": "boolean"
          },
          "allowfax": {
            "description": "whether fax is allowed or not",
            "type": "boolean"
          },
          "authenticationMethod": {
            "description": "authentication method for the current recipient list to have access to view and sign the document",
            "enum": [
              "NONE",
              "KBA",
              "PASSWORD",
              "WEB_IDENTITY",
              "PHONE",
              "ADOBE_SIGN"
            ],
            "type": "string"
          },
          "defaultValue": {
            "description": "A default  email or fax number",
            "type": "string"
          },
          "editable": {
            "description": "Whether current field can be edited. If editable attribute for this field is false then this field should not be provided in the agreement creation request and default value of this field will be used in agreement creation",
            "type": "boolean"
          },
          "label": {
            "description": "A display text for the workflow user that can be used for the current recipients list",
            "type": "string"
          },
          "maxListCount": {
            "description": "maximum number of entries allowed in the current recipient list",
            "format": "int32",
            "type": "integer"
          },
          "minListCount": {
            "description": "minimum number of entries allowed in the current recipient list",
            "format": "int32",
            "type": "integer"
          },
          "name": {
            "description": "Name of the current RecipientInfo list",
            "type": "string"
          },
          "role": {
            "description": "The current roles of the participant. A participant can have one or more roles",
            "items": {
              "enum": [
                "SIGNER",
                "APPROVER",
                "ACCEPTOR",
                "FORM_FILLER",
                "CERTIFIED_RECIPIENT",
                "DELEGATE_TO_SIGNER",
                "DELEGATE_TO_APPROVER",
                "DELEGATE_TO_ACCEPTOR",
                "DELEGATE_TO_FORM_FILLER",
                "DELEGATE_TO_CERTIFIED_RECIPIENT"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "visible": {
            "description": "Whether current field is visible. If visible attribute for this field is false then this field should not be shown in the agreement creation UI using this workflow to user",
            "type": "boolean"
          }
        },
        "required": [
          "allowSender",
          "allowfax",
          "authenticationMethod",
          "defaultValue",
          "editable",
          "label",
          "maxListCount",
          "minListCount",
          "name",
          "role",
          "visible"
        ],
        "type": "object"
      },
      "UserWorkflow": {
        "properties": {
          "created": {
            "description": "The date on which the workflow was created. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "description": {
            "description": "Description provided for this workflow at the time of its creation",
            "type": "string"
          },
          "displayName": {
            "description": "The display name of the workflow.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifier of a workflow",
            "type": "string"
          },
          "modified": {
            "description": "The date on which the workflow was modified. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the workflow.",
            "type": "string"
          },
          "originatorId": {
            "description": "Initial originator of the workflow",
            "type": "string"
          },
          "scope": {
            "description": "The workflow scope (ACCOUNT or GROUP or OTHER)",
            "enum": [
              "ACCOUNT",
              "GROUP"
            ],
            "type": "string"
          },
          "scopeId": {
            "description": "Identifier of scope. Currently it is applicable for scope GROUP only and the value will be groupId.",
            "type": "string"
          },
          "status": {
            "description": "The workflow status (ACTIVE or DRAFT or INACTIVE or OTHER)",
            "enum": [
              "ACTIVE",
              "DRAFT",
              "HIDDEN"
            ],
            "type": "string"
          }
        },
        "required": [
          "created",
          "description",
          "displayName",
          "id",
          "modified",
          "name",
          "scope",
          "status"
        ],
        "type": "object"
      },
      "UserWorkflows": {
        "properties": {
          "userWorkflowList": {
            "description": "An array of workflows",
            "items": {
              "$ref": "#/components/schemas/UserWorkflow"
            },
            "type": "array"
          }
        },
        "required": [
          "userWorkflowList"
        ],
        "type": "object"
      },
      "WorkflowDefaultParams": {
        "properties": {
          "defaultValue": {
            "description": "default value of the field if input for this field is not provided and this field is required",
            "type": "string"
          },
          "editable": {
            "description": "Whether current field can be edited. If editable attribute for this field is false then this field should not be provided in the agreement creation request and default value of this field will be used in agreement creation",
            "type": "boolean"
          },
          "required": {
            "description": "Whether this field is required or optional",
            "type": "boolean"
          },
          "visible": {
            "description": "Whether current field is visible or not. If visible attribute for this field is false then this field should not be visible in the agreement creation UI using this workflow to user",
            "type": "boolean"
          }
        },
        "required": [
          "defaultValue",
          "editable",
          "required",
          "visible"
        ],
        "type": "object"
      },
      "WorkflowDescription": {
        "properties": {
          "agreementNameInfo": {
            "$ref": "#/components/schemas/WorkflowDefaultParams",
            "description": "Information about name field in DocumentCreationInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/WorkflowDefaultParams"
            }
          },
          "authoringInfo": {
            "$ref": "#/components/schemas/WorkflowDefaultParams",
            "description": "Information about authoringRequested field in SendDocumentInteractiveOptions input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/WorkflowDefaultParams"
            }
          },
          "ccsListInfo": {
            "description": "Information about CCList input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/CCsListInfoDescription"
            },
            "type": "array"
          },
          "created": {
            "description": "The day on which the workflow was created",
            "format": "date",
            "type": "string"
          },
          "description": {
            "description": "Description provided for this workflow at the time of its creation",
            "type": "string"
          },
          "displayName": {
            "description": "The display name of the workflow.",
            "type": "string"
          },
          "expirationInfo": {
            "$ref": "#/components/schemas/ExpirationFieldInfoDescription",
            "description": "Information about daysUntilSigningDeadline field in DocumentCreationInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/ExpirationFieldInfoDescription"
            }
          },
          "fileInfos": {
            "description": "Information about FileInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/FileInfosDescription"
            },
            "type": "array"
          },
          "localeInfo": {
            "$ref": "#/components/schemas/LocaleFieldInfoDescription",
            "description": "Information about locale  field in DocumentCreationInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/LocaleFieldInfoDescription"
            }
          },
          "mergeFieldsInfo": {
            "description": "Information about customFieldInfos in DocumentCreationInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/MergeFieldInfoDescription"
            },
            "type": "array"
          },
          "messageInfo": {
            "$ref": "#/components/schemas/WorkflowDefaultParams",
            "description": "Information about message field in DocumentCreationInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/WorkflowDefaultParams"
            }
          },
          "modified": {
            "description": "The day on which the workflow was last modified",
            "format": "date",
            "type": "string"
          },
          "name": {
            "description": "The name of the workflow.",
            "type": "string"
          },
          "originatorId": {
            "description": "Initial originator of the workflow",
            "type": "string"
          },
          "passwordInfo": {
            "$ref": "#/components/schemas/PasswordFieldInfoDescription",
            "description": "Information about openPassword field in SecurityOptions input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/PasswordFieldInfoDescription"
            }
          },
          "recipientsListInfo": {
            "description": "Information about RecepientsInfo input field in the agreement creation request when using the API which creates an agreement in a workflow",
            "items": {
              "$ref": "#/components/schemas/RecipientsListInfoDescription"
            },
            "type": "array"
          },
          "scope": {
            "description": "The workflow scope (ACCOUNT or GROUP or OTHER)",
            "enum": [
              "ACCOUNT",
              "GROUP"
            ],
            "type": "string"
          },
          "scopeId": {
            "description": "Identifier of scope. Currently it is applicable for scope GROUP only and the value will be groupId.",
            "type": "string"
          },
          "status": {
            "description": "The workflow status (ACTIVE or DRAFT or INACTIVE or OTHER)",
            "enum": [
              "ACTIVE",
              "DRAFT",
              "HIDDEN"
            ],
            "type": "string"
          }
        },
        "required": [
          "agreementNameInfo",
          "authoringInfo",
          "ccsListInfo",
          "created",
          "description",
          "displayName",
          "expirationInfo",
          "fileInfos",
          "localeInfo",
          "mergeFieldsInfo",
          "messageInfo",
          "modified",
          "name",
          "passwordInfo",
          "recipientsListInfo",
          "scope",
          "status"
        ],
        "type": "object"
      },
      "WorkflowLibraryDocument": {
        "properties": {
          "label": {
            "description": "A display text for this form for workflow users",
            "type": "string"
          },
          "modifiedDate": {
            "description": "The date on which the library document was last modified. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time",
            "format": "date",
            "type": "string"
          },
          "sharingMode": {
            "description": "Specifies who should have access to this library document. GLOBAL sharing is a restricted operation.",
            "enum": [
              "USER",
              "GROUP",
              "ACCOUNT",
              "GLOBAL"
            ],
            "type": "string"
          },
          "templateTypes": {
            "description": "A list of one or more library template types",
            "items": {
              "enum": [
                "DOCUMENT",
                "FORM_FIELD_LAYER"
              ],
              "type": "string"
            },
            "type": "array"
          },
          "workflowLibDoc": {
            "description": "An id of the workflow library document that can be provided as an input file in the custom workflow agreement creation request",
            "type": "string"
          }
        },
        "required": [
          "label",
          "modifiedDate",
          "sharingMode",
          "templateTypes",
          "workflowLibDoc"
        ],
        "type": "object"
      }
    },
    "requestBodies": {
      "ReminderInfo": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ReminderInfo"
            }
          }
        },
        "description": "The information about a reminder associated with a recipient of an agreement.",
        "required": true
      },
      "ReminderInfo1": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ReminderInfo1"
            }
          }
        },
        "description": "The information about a reminder associated with a recipient of an agreement.",
        "required": true
      }
    }
  }
}